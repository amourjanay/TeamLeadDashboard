/**
 * TeamLeadDashboard - Crisis Services Team Management System
 * Entry point, menu creation, and navigation with emojis
 * Current Date (UTC): 2025-03-23 07:34:51
 */

function onOpen() {
  var ui = SpreadsheetApp.getUi();
  ui.createMenu('📊 Team Lead Dashboard')
    .addItem('🏠 Open Dashboard', 'openDashboard')
    .addSeparator()
    .addSubMenu(ui.createMenu('👥 One-on-One')
      .addItem('📝 Create Session', 'createOneOnOneSession')
      .addItem('👁️ View Sessions', 'viewOneOnOneSessions')
      .addItem('📤 Export Notes', 'exportOneOnOneNotes'))
    .addSubMenu(ui.createMenu('👪 Team Management')
      .addItem('➕ Add Team Member', 'openTeamMemberForm')
      .addItem('👥 View Team', 'openTeamMemberList')
      .addItem('📊 Team Dashboard', 'openTeamDashboard')
      .addItem('📤 Import Team', 'openTeamImport'))
    .addSubMenu(ui.createMenu('👤 Manager One-on-One')
      .addItem('📝 Create Session', 'createManagerOneOnOneForm')
      .addItem('👁️ View Notes', 'viewManagerOneOnOneNotes')
      .addItem('📊 Dashboard', 'viewManagerOneOnOneDashboard'))
    .addSubMenu(ui.createMenu('📝 General Notes')
      .addItem('📝 Create Note', 'createGeneralNote')
      .addItem('👁️ View Notes', 'viewGeneralNotes')
      .addItem('📊 Dashboard', 'viewGeneralNotesDashboard'))
    .addSubMenu(ui.createMenu('📈 Metrics')
      .addItem('📝 Enter Data', 'openMetricsForm')
      .addItem('📊 View Reports', 'openMetricsReports')
      .addItem('📈 Dashboard', 'openMetricsDashboard')
      .addItem('📤 Export Data', 'openMetricsExport')
      .addItem('📧 Email Config', 'openMetricsEmailConfig'))
    .addSubMenu(ui.createMenu('🔍 QA Reviews')
      .addItem('✅ New QA Review', 'openQAReviewForm')
      .addItem('📋 QA Reports', 'openQAReports')
      .addItem('📊 QA Dashboard', 'openQADashboard')
      .addItem('📤 Export QA Data', 'openQAExport')
      .addItem('⚙️ Initialize QA', 'initializeQASystem'))
    .addSubMenu(ui.createMenu('⏱️ Time & Schedule')
      .addItem('⏱️ Time Tracker', 'openTimeTracker')
      .addItem('📊 Time Reports', 'viewTimeReports')
      .addItem('📅 Manage Schedule', 'manageSchedule')
      .addItem('🔄 Initialize Week', 'initializeWeek')
      .addItem('📋 Schedule Reports', 'viewScheduleReports'))
    .addSubMenu(ui.createMenu('✅ Tasks')
      .addItem('📝 Create Task', 'createTask')
      .addItem('🔗 Asana Task', 'createAsanaTask')
      .addItem('📋 View Tasks', 'viewTasks'))
    .addSubMenu(ui.createMenu('📌 Action Items')
      .addItem('📝 Manage Items', 'manageActionItems')
      .addItem('👁️ View Items', 'viewActionItems')
      .addItem('🔔 Set Reminders', 'setActionItemReminders'))
    .addSubMenu(ui.createMenu('⚙️ Settings')
      .addItem('🔧 System Settings', 'openSystemSettings')
      .addItem('❓ Help', 'openHelp')
      .addItem('📊 Error Log Viewer', 'openErrorLogViewer')
      .addItem('👤 User Preferences', 'openUserPreferences')
      .addItem('🐞 Debug Tool', 'openDebugTool'))
    .addToUi();
}

/******************************************
 * GENERAL HELPERS & UTILITIES
 ******************************************/

/**
 * Include HTML templates within other HTML files
 * @param {string} filename - Name of the HTML file to include
 * @return {string} - Content of the HTML file
 */
function include(filename) {
  try {
    return HtmlService.createHtmlOutputFromFile(filename).getContent();
  } catch (e) {
    Logger.log("Error including file " + filename + ": " + e.message);
    return "<!-- Error including " + filename + " -->";
  }
}

/**
 * Gets the active user's email address
 * No hard-coding of user information
 * @return {string} - User's email
 */
function getUserEmail() {
  return Session.getActiveUser().getEmail();
}

/**
 * Opens the dashboard HTML interface
 */
function openDashboard() {
  var html = HtmlService.createTemplateFromFile('HTML/Dashboard/dashboard')
    .evaluate()
    .setWidth(1200)
    .setHeight(800)
    .setTitle('📊 Team Lead Dashboard');
  
  SpreadsheetApp.getUi().showModalDialog(html, '📊 Team Lead Dashboard');
}

/**
 * Gets the current user's information and formatted date
 * PRIVACY-SAFE: Does not expose actual user information to client
 * @return {Object} User and date information
 */
function getCurrentUserAndDate() {
  try {
    // Get current date in UTC
    const now = new Date();
    const utcYear = now.getUTCFullYear();
    const utcMonth = (now.getUTCMonth() + 1).toString().padStart(2, '0');
    const utcDay = now.getUTCDate().toString().padStart(2, '0');
    const utcHours = now.getUTCHours().toString().padStart(2, '0');
    const utcMinutes = now.getUTCMinutes().toString().padStart(2, '0');
    const utcSeconds = now.getUTCSeconds().toString().padStart(2, '0');
    
    // Format the date as requested
    const formattedUtcDate = `${utcYear}-${utcMonth}-${utcDay} ${utcHours}:${utcMinutes}:${utcSeconds}`;
    
    // Do NOT return actual username to client - use a generic placeholder
    return {
      formattedDate: formattedUtcDate,
      timestamp: now.toISOString(),
      // Use generic placeholder instead of actual username
      username: "current_user", 
      email: "user@example.com"
    };
  } catch (e) {
    Logger.log('Error in getCurrentUserAndDate: ' + e);
    
    // Generic fallback with correct UTC time
    const now = new Date();
    return {
      formattedDate: now.toISOString().replace('T', ' ').slice(0, 19),
      timestamp: now.toISOString(),
      username: "",
      email: ""
    };
  }
}

/**
 * Logs an error to the error log
 * @param {string} source - Source of the error
 * @param {string} errorMessage - Error message
 * @param {Object} contextData - Optional context data
 */
function logError(source, errorMessage, contextData = null) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName('ErrorLog');
    
    if (!sheet) {
      sheet = ss.insertSheet('ErrorLog');
      sheet.appendRow(['Timestamp', 'Source', 'Error', 'User', 'Context', 'Stack']);
      sheet.getRange(1, 1, 1, 6).setFontWeight('bold').setBackground('#E8EAED');
    }
    
    const now = new Date();
    const user = Session.getActiveUser().getEmail() || 'unknown';
    const context = contextData ? JSON.stringify(contextData) : '';
    const stack = (new Error()).stack || '';
    
    sheet.appendRow([now, source, errorMessage, user, context, stack]);
    
    Logger.log(`Error logged - ${source}: ${errorMessage}`);
  } catch (e) {
    Logger.log('Error in logError: ' + e.toString());
  }
}

/**
 * Standardized function to get team members 
 * This is the approved method to be used across all modules
 * @param {Object} options - Optional filters for team members
 * @return {Array} Team members
 */
function getTeamMembers(options = {}) {
  try {
    // Get team members from your TeamMemberService
    return getTeamMemberService().getTeamMembers(options);
  } catch (e) {
    Logger.log('Error getting team members: ' + e.toString());
    return [];
  }
}

/******************************************
 * ONE-ON-ONE SESSION FUNCTIONS
 ******************************************/

/**
 * Creates a new one-on-one session
 */
function createOneOnOneSession() {
  try {
    // Clear any cached session ID
    CacheService.getUserCache().remove('currentOneOnOneSession');
    
    var html = HtmlService.createTemplateFromFile('HTML/OneOnOne/one-on-one-form')
      .evaluate()
      .setWidth(900)
      .setHeight(700)
      .setTitle('📝 Create One-on-One Session');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📝 Create One-on-One Session');
  } catch (e) {
    logError('createOneOnOneSession', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * View all one-on-one sessions
 */
function viewOneOnOneSessions() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/OneOnOne/one-on-one-list')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('👁️ View One-on-One Sessions');
    
    SpreadsheetApp.getUi().showModalDialog(html, '👁️ View One-on-One Sessions');
  } catch (e) {
    logError('viewOneOnOneSessions', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Export one-on-one notes to various formats
 */
function exportOneOnOneNotes() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/OneOnOne/one-on-one-export')
      .evaluate()
      .setWidth(600)
      .setHeight(400)
      .setTitle('📤 Export One-on-One Notes');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📤 Export One-on-One Notes');
  } catch (e) {
    logError('exportOneOnOneNotes', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens a page to edit an existing one-on-one session
 * @param {String} sessionId - ID of the session to edit
 */
function editOneOnOneSession(sessionId) {
  try {
    // Store the current session ID in cache for the form to retrieve
    const oneOnOneService = getOneOnOneService();
    oneOnOneService.cacheOneOnOneSessionId(sessionId);
    
    var html = HtmlService.createTemplateFromFile('HTML/OneOnOne/one-on-one-form')
      .evaluate()
      .setWidth(1000)
      .setHeight(800)
      .setTitle('Edit One-on-One Session');
    SpreadsheetApp.getUi().showModalDialog(html, 'Edit One-on-One Session');
  } catch (e) {
    logError('editOneOnOneSession', e.toString(), {sessionId: sessionId});
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Gets team member name from email
 * @param {String} email - The team member's email
 * @return {String} The team member's name or email username if not found
 */
function getTeamMemberNameFromEmail(email) {
  try {
    const teamService = getTeamMemberService();
    const member = teamService.getTeamMemberByEmail(email);
    if (member) {
      return `${member.firstName} ${member.lastName}`.trim();
    }
    // Return email username as fallback
    return email.split('@')[0];
  } catch (e) {
    logError('getTeamMemberNameFromEmail', e.toString(), {email: email});
    return email.split('@')[0];
  }
}

/******************************************
 * EMAIL FUNCTIONS
 ******************************************/

/**
 * Creates a follow-up email from one-on-one session data
 * This returns the actual HTML content for the email, not using hardcoded user info
 * @param {Object} sessionData - Data about the one-on-one session
 * @return {String} The HTML content for the email
 */
function createOneOnOneFollowUpEmail(sessionData) {
  try {
    if (!sessionData || !sessionData.teamMember) {
      throw new Error('Invalid session data provided');
    }
    
    // Get the team member's name
    let teamMemberName = '';
    if (typeof sessionData.teamMember === 'string') {
      // If just an email was provided
      teamMemberName = getTeamMemberNameFromEmail(sessionData.teamMember);
    } else if (sessionData.teamMember.name) {
      // If a name was provided directly
      teamMemberName = sessionData.teamMember.name;
    } else if (sessionData.teamMember.firstName || sessionData.teamMember.lastName) {
      // If first/last name were provided
      teamMemberName = `${sessionData.teamMember.firstName || ''} ${sessionData.teamMember.lastName || ''}`.trim();
    } else if (sessionData.teamMember.email) {
      // Fallback to looking up by email
      teamMemberName = getTeamMemberNameFromEmail(sessionData.teamMember.email);
    } else {
      teamMemberName = 'Team Member';
    }
    
    // Format the date
    let meetingDate = 'our recent meeting';
    if (sessionData.date) {
      const date = new Date(sessionData.date);
      meetingDate = Utilities.formatDate(date, Session.getScriptTimeZone(), 'EEEE, MMMM d');
    }
    
    // Format follow-up date if specified
    let followUpText = '';
    if (sessionData.followUpDate) {
      const followUpDate = new Date(sessionData.followUpDate);
      const formattedFollowUpDate = Utilities.formatDate(followUpDate, Session.getScriptTimeZone(), 'EEEE, MMMM d');
      followUpText = `<p>I've scheduled our next follow-up for <strong>${formattedFollowUpDate}</strong>.</p>`;
    }
    
    // Format action items if any
    let actionItemsHtml = '';
    if (sessionData.actionItems && sessionData.actionItems.length > 0) {
      actionItemsHtml = '<h3>Action Items:</h3><ul>';
      
      sessionData.actionItems.forEach(item => {
        if (typeof item === 'string') {
          actionItemsHtml += `<li>${item}</li>`;
        } else if (item.text) {
          actionItemsHtml += `<li>${item.text}`;
          if (item.dueDate) {
            const dueDate = new Date(item.dueDate);
            const formattedDueDate = Utilities.formatDate(dueDate, Session.getScriptTimeZone(), 'MMM d');
            actionItemsHtml += ` (Due: ${formattedDueDate})`;
          }
          actionItemsHtml += `</li>`;
        }
      });
      
      actionItemsHtml += '</ul>';
    }
    
    // Create sections for notes if they exist
    let statusSection = '';
    if (sessionData.statusNotes) {
      statusSection = `
        <h3>Status Update:</h3>
        <p>${sessionData.statusNotes}</p>
      `;
    }
    
    let performanceSection = '';
    if (sessionData.performanceNotes) {
      performanceSection = `
        <h3>Performance Discussion:</h3>
        <p>${sessionData.performanceNotes}</p>
      `;
    }
    
    let developmentSection = '';
    if (sessionData.developmentNotes) {
      developmentSection = `
        <h3>Development Opportunities:</h3>
        <p>${sessionData.developmentNotes}</p>
      `;
    }
    
    let supportSection = '';
    if (sessionData.supportNotes) {
      supportSection = `
        <h3>Support Needed:</h3>
        <p>${sessionData.supportNotes}</p>
      `;
    }
    
    // Construct the full email HTML
    const emailHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
          }
          .header {
            background-color: #4285f4;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 5px 5px 0 0;
          }
          .content {
            padding: 20px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
          }
          h1 {
            margin: 0;
            font-size: 24px;
          }
          h3 {
            color: #4285f4;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
          }
          ul {
            margin-top: 5px;
          }
          .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #777;
            text-align: center;
            border-top: 1px solid #eee;
            padding-top: 20px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>One-on-One Meeting Summary</h1>
        </div>
        <div class="content">
          <p>Hi ${teamMemberName},</p>
          
          <p>Thank you for our one-on-one meeting on ${meetingDate}. I wanted to follow up with a summary of what we discussed.</p>
          
          ${statusSection}
          ${performanceSection}
          ${developmentSection}
          ${supportSection}
          ${actionItemsHtml}
          
          ${followUpText}
          
          <p>If you have any questions or need additional support before then, please don't hesitate to reach out!</p>
          
          <p>Best regards,<br>Your Manager</p>
          
          <div class="footer">
            This email was sent from the Team Lead Dashboard System.
          </div>
        </div>
      </body>
      </html>
    `;
    
    return emailHtml;
  } catch (e) {
    logError('createOneOnOneFollowUpEmail', e.toString(), {sessionData: JSON.stringify(sessionData)});
    return `<p>Error creating follow-up email: ${e.toString()}</p>`;
  }
}

/**
 * Schedules a one-on-one follow-up email to be sent later
 * @param {Object} sessionData - Data about the one-on-one session
 * @param {Date} scheduledTime - When to send the email
 * @return {String} The ID of the scheduled email
 */
function scheduleOneOnOneEmail(sessionData, scheduledTime) {
  try {
    const emailService = getEmailService();
    return emailService.scheduleOneOnOneFollowUp(sessionData, scheduledTime);
  } catch (e) {
    logError('scheduleOneOnOneEmail', e.toString(), {
      sessionData: JSON.stringify(sessionData),
      scheduledTime: scheduledTime.toISOString()
    });
    return null;
  }
}

/**
 * Sends a one-on-one follow-up email immediately
 * @param {Object} sessionData - Data about the one-on-one session
 * @return {Object} Result with success flag
 */
function sendOneOnOneFollowUpEmail(sessionData) {
  try {
    const emailService = getEmailService();
    return emailService.sendOneOnOneFollowUp(sessionData);
  } catch (e) {
    logError('sendOneOnOneFollowUpEmail', e.toString(), {
      sessionData: JSON.stringify(sessionData)
    });
    return {
      success: false,
      message: 'Error sending follow-up email: ' + e.toString()
    };
  }
}

/**
 * Generates a preview of the follow-up email
 * @param {Object} sessionData - Data about the one-on-one session
 * @return {String} The HTML content of the preview
 */
function previewOneOnOneEmail(sessionData) {
  try {
    const emailHtml = createOneOnOneFollowUpEmail(sessionData);
    return emailHtml;
  } catch (e) {
    logError('previewOneOnOneEmail', e.toString(), {
      sessionData: JSON.stringify(sessionData)
    });
    return `<p>Error generating email preview: ${e.toString()}</p>`;
  }
}

/******************************************
 * MANAGER ONE-ON-ONE FUNCTIONS
 ******************************************/

/**
 * Create a new manager one-on-one session
 */
function createManagerOneOnOneForm() {
  try {
    // Clear any cached session ID
    CacheService.getUserCache().remove('currentManagerSession');
    
    var html = HtmlService.createTemplateFromFile('HTML/ManagerOneOnOne/manager-one-on-one-form')
      .evaluate()
      .setWidth(900)
      .setHeight(700)
      .setTitle('📝 Create Manager One-on-One Session');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📝 Create Manager One-on-One Session');
  } catch (e) {
    logError('createManagerOneOnOneForm', e.toString());
    SpreadsheetApp.getUi().alert('Error creating manager session form: ' + e.toString());
  }
}

/**
 * View manager one-on-one notes
 */
function viewManagerOneOnOneNotes() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/ManagerOneOnOne/manager-one-on-one-notes')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('👁️ View Manager One-on-One Notes');
    
    SpreadsheetApp.getUi().showModalDialog(html, '👁️ View Manager One-on-One Notes');
  } catch (e) {
    logError('viewManagerOneOnOneNotes', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing manager notes: ' + e.toString());
  }
}

/**
 * View manager one-on-one dashboard
 */
function viewManagerOneOnOneDashboard() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/ManagerOneOnOne/manager-one-on-one-dashboard')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📊 Manager One-on-One Dashboard');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📊 Manager One-on-One Dashboard');
  } catch (e) {
    logError('viewManagerOneOnOneDashboard', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing manager dashboard: ' + e.toString());
  }
}

/**
 * Get the cached manager session ID
 * @return {String} The session ID or null if not found
 */
function getCachedManagerSessionId() {
  try {
    return CacheService.getUserCache().get('currentManagerSession');
  } catch (e) {
    logError('getCachedManagerSessionId', e.toString());
    return null;
  }
}

/******************************************
 * GENERAL NOTES FUNCTIONS 
 ******************************************/

/**
 * Create a new general note
 */
function createGeneralNote() {
  try {
    // Clear any cached note ID
    CacheService.getUserCache().remove('currentGeneralNote');
    
    var html = HtmlService.createTemplateFromFile('HTML/Notes/general-note-form')
      .evaluate()
      .setWidth(600)
      .setHeight(400)
      .setTitle('📝 Create General Note');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📝 Create General Note');
  } catch (e) {
    logError('createGeneralNote', e.toString());
    SpreadsheetApp.getUi().alert('Error creating general note: ' + e.toString());
  }
}

/**
 * View general notes
 */
function viewGeneralNotes() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Notes/general-notes')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('👁️ View General Notes');
    
    SpreadsheetApp.getUi().showModalDialog(html, '👁️ View General Notes');
  } catch (e) {
    logError('viewGeneralNotes', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing general notes: ' + e.toString());
  }
}

/**
 * View general notes dashboard
 */
function viewGeneralNotesDashboard() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Notes/general-notes-dashboard')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📊 General Notes Dashboard');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📊 General Notes Dashboard');
  } catch (e) {
    logError('viewGeneralNotesDashboard', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing general notes dashboard: ' + e.toString());
  }
}

/******************************************
 * TIME & SCHEDULE FUNCTIONS
 ******************************************/

/**
 * Opens the time tracker
 */
function openTimeTracker() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Time/time-tracker')
      .evaluate()
      .setWidth(800)
      .setHeight(600)
      .setTitle('⏱️ Time Tracker');
    
    SpreadsheetApp.getUi().showModalDialog(html, '⏱️ Time Tracker');
  } catch (e) {
    logError('openTimeTracker', e.toString());
    SpreadsheetApp.getUi().alert('Error opening time tracker: ' + e.toString());
  }
}

/**
 * View time reports
 */
function viewTimeReports() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Time/time-reports')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📊 Time Reports');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📊 Time Reports');
  } catch (e) {
    logError('viewTimeReports', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing time reports: ' + e.toString());
  }
}

/**
 * Manage schedule
 */
function manageSchedule() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Schedule/manage-schedule')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📅 Manage Schedule');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📅 Manage Schedule');
  } catch (e) {
    logError('manageSchedule', e.toString());
    SpreadsheetApp.getUi().alert('Error managing schedule: ' + e.toString());
  }
}

/**
 * Initialize week (for scheduling)
 */
function initializeWeek() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Schedule/initialize-week')
      .evaluate()
      .setWidth(600)
      .setHeight(400)
      .setTitle('🔄 Initialize Week');
    
    SpreadsheetApp.getUi().showModalDialog(html, '🔄 Initialize Week');
  } catch (e) {
    logError('initializeWeek', e.toString());
    SpreadsheetApp.getUi().alert('Error initializing week: ' + e.toString());
  }
}

/**
 * View schedule reports
 */
function viewScheduleReports() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Schedule/schedule-reports')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📋 Schedule Reports');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📋 Schedule Reports');
  } catch (e) {
    logError('viewScheduleReports', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing schedule reports: ' + e.toString());
  }
}

/******************************************
 * TASKS FUNCTIONS
 ******************************************/

/**
 * Create a new task
 */
function createTask() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Tasks/task-form')
      .evaluate()
      .setWidth(600)
      .setHeight(500)
      .setTitle('📝 Create Task');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📝 Create Task');
  } catch (e) {
    logError('createTask', e.toString());
    SpreadsheetApp.getUi().alert('Error creating task: ' + e.toString());
  }
}

/**
 * Create an Asana task
 */
function createAsanaTask() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Tasks/asana-task-form')
      .evaluate()
      .setWidth(600)
      .setHeight(500)
      .setTitle('🔗 Create Asana Task');
    
    SpreadsheetApp.getUi().showModalDialog(html, '🔗 Create Asana Task');
  } catch (e) {
    logError('createAsanaTask', e.toString());
    SpreadsheetApp.getUi().alert('Error creating Asana task: ' + e.toString());
  }
}

/**
 * View tasks
 */
function viewTasks() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Tasks/tasks-view')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📋 View Tasks');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📋 View Tasks');
  } catch (e) {
    logError('viewTasks', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing tasks: ' + e.toString());
  }
}

/******************************************
 * ACTION ITEMS FUNCTIONS
 ******************************************/

/**
 * Manage action items
 */
function manageActionItems() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/ActionItems/action-items-manage')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📝 Manage Action Items');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📝 Manage Action Items');
  } catch (e) {
    logError('manageActionItems', e.toString());
    SpreadsheetApp.getUi().alert('Error managing action items: ' + e.toString());
  }
}

/**
 * View action items
 */
function viewActionItems() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/ActionItems/action-items-view')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('👁️ View Action Items');
    
    SpreadsheetApp.getUi().showModalDialog(html, '👁️ View Action Items');
  } catch (e) {
    logError('viewActionItems', e.toString());
    SpreadsheetApp.getUi().alert('Error viewing action items: ' + e.toString());
  }
}

/**
 * Set action item reminders
 */
function setActionItemReminders() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/ActionItems/action-items-reminders')
      .evaluate()
      .setWidth(600)
      .setHeight(400)
      .setTitle('🔔 Set Action Item Reminders');
    
    SpreadsheetApp.getUi().showModalDialog(html, '🔔 Set Action Item Reminders');
  } catch (e) {
    logError('setActionItemReminders', e.toString());
    SpreadsheetApp.getUi().alert('Error setting action item reminders: ' + e.toString());
  }
}

/******************************************
 * SETTINGS FUNCTIONS
 ******************************************/

/**
 * Open system settings
 */
function openSystemSettings() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Settings/system-settings')
      .evaluate()
      .setWidth(800)
      .setHeight(600)
      .setTitle('🔧 System Settings');
    
    SpreadsheetApp.getUi().showModalDialog(html, '🔧 System Settings');
  } catch (e) {
    logError('openSystemSettings', e.toString());
    SpreadsheetApp.getUi().alert('Error opening system settings: ' + e.toString());
  }
}

/**
 * Open help
 */
function openHelp() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Settings/help')
      .evaluate()
      .setWidth(800)
      .setHeight(600)
      .setTitle('❓ Help');
    
    SpreadsheetApp.getUi().showModalDialog(html, '❓ Help');
  } catch (e) {
    logError('openHelp', e.toString());
    SpreadsheetApp.getUi().alert('Error opening help: ' + e.toString());
  }
}

/**
 * Open error log viewer
 */
function openErrorLogViewer() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Settings/error-log-viewer')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📊 Error Log Viewer');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📊 Error Log Viewer');
  } catch (e) {
    logError('openErrorLogViewer', e.toString());
    SpreadsheetApp.getUi().alert('Error opening error log viewer: ' + e.toString());
  }
}

/**
 * Open user preferences
 */
function openUserPreferences() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Settings/user-preferences')
      .evaluate()
      .setWidth(600)
      .setHeight(400)
      .setTitle('👤 User Preferences');
    
    SpreadsheetApp.getUi().showModalDialog(html, '👤 User Preferences');
  } catch (e) {
    logError('openUserPreferences', e.toString());
    SpreadsheetApp.getUi().alert('Error opening user preferences: ' + e.toString());
  }
}

/**
 * Open debug tool
 */
function openDebugTool() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Settings/debug-tool')
      .evaluate()
      .setWidth(800)
      .setHeight(600)
      .setTitle('🐞 Debug Tool');
    
    SpreadsheetApp.getUi().showModalDialog(html, '🐞 Debug Tool');
  } catch (e) {
    logError('openDebugTool', e.toString());
    SpreadsheetApp.getUi().alert('Error opening debug tool: ' + e.toString());
  }
}



/**
 * ConfigService.gs - System configuration and settings
 * Ensuring NO hard-coded user information anywhere in the system
 */

var ConfigService = (function() {
  // Private variables
  var CONFIG_SHEET_NAME = 'Config';
  var USER_CONFIG_SHEET_NAME = 'UserConfig';
  
  /**
   * Gets the config sheet, creating it if it doesn't exist
   * @return {Sheet} - Google Sheet for configuration
   */
  function getConfigSheet_() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(CONFIG_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(CONFIG_SHEET_NAME);
      var headers = [
        'Setting Key', 'Setting Value', 'Description', 'Category', 'Last Updated'
      ];
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
      
      // Add default configuration options
      var defaultSettings = [
        ['system_name', 'Crisis Team Lead Dashboard', 'System display name', 'General', new Date()],
        ['metrics_warning_threshold', '75', 'Warning threshold for metrics (percent)', 'Metrics', new Date()],
        ['metrics_danger_threshold', '50', 'Danger threshold for metrics (percent)', 'Metrics', new Date()],
        ['default_qa_criteria', 'Call Opening,Risk Assessment,Communication Skills,Support Effectiveness,Call Closure', 'Default QA criteria categories', 'QA', new Date()],
        ['default_team_statuses', 'Active,Training,PTO,LOA,Disappeared,UTO', 'Default team status options', 'Team', new Date()],
        ['email_follow_up_default', 'true', 'Send email follow-ups by default', 'Email', new Date()],
        ['schedule_hours_start', '0', 'Schedule starting hour (24h format)', 'Schedule', new Date()],
        ['schedule_hours_end', '24', 'Schedule ending hour (24h format)', 'Schedule', new Date()],
        ['action_item_reminder_days', '1,3,7', 'Default reminder days for action items', 'Action Items', new Date()],
      ];
      
      sheet.getRange(2, 1, defaultSettings.length, headers.length).setValues(defaultSettings);
    }
    
    return sheet;
  }
  
  /**
   * Gets the user config sheet, creating it if it doesn't exist
   * @return {Sheet} - Google Sheet for user configuration
   */
  function getUserConfigSheet_() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(USER_CONFIG_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(USER_CONFIG_SHEET_NAME);
      var headers = [
        'Email', 'User Name', 'Role', 'Email Notification Pref', 'Asana API Key', 'Asana Workspace', 'Last Updated'
      ];
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
    }
    
    return sheet;
  }
  
  return {
    /**
     * Gets a configuration setting
     * @param {string} key - Setting key to retrieve
     * @return {string} - Setting value
     */
    getSetting: function(key) {
      var sheet = getConfigSheet_();
      var data = sheet.getDataRange().getValues();
      
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === key) {
          return data[i][1];
        }
      }
      
      return null; // Setting not found
    },
    
    /**
     * Updates a configuration setting
     * @param {string} key - Setting key to update
     * @param {string} value - New setting value
     * @return {boolean} - True if successful
     */
    updateSetting: function(key, value) {
      var sheet = getConfigSheet_();
      var data = sheet.getDataRange().getValues();
      
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === key) {
          sheet.getRange(i + 1, 2).setValue(value);
          sheet.getRange(i + 1, 5).setValue(new Date());
          return true;
        }
      }
      
      // Setting not found, add it
      var lastRow = Math.max(sheet.getLastRow(), 1);
      sheet.getRange(lastRow + 1, 1, 1, 5).setValues([[key, value, '', 'Custom', new Date()]]);
      return true;
    },
    
    /**
     * Gets all configuration settings
     * @param {string} category - Optional category filter
     * @return {Array} - Array of setting objects
     */
    getAllSettings: function(category) {
      var sheet = getConfigSheet_();
      var data = sheet.getDataRange().getValues();
      var settings = [];
      
      for (var i = 1; i < data.length; i++) {
        if (!category || data[i][3] === category) {
          settings.push({
            key: data[i][0],
            value: data[i][1],
            description: data[i][2],
            category: data[i][3],
            lastUpdated: data[i][4]
          });
        }
      }
      
      return settings;
    },
    
    /**
     * Gets user info by email - no hard-coding
     * @param {string} email - User email
     * @return {Object} - User info object
     */
    getUserInfoByEmail: function(email) {
      var sheet = getUserConfigSheet_();
      var data = sheet.getDataRange().getValues();
      
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === email) {
          return {
            email: data[i][0],
            name: data[i][1],
            role: data[i][2],
            emailNotification: data[i][3] === 'true',
            asanaApiKey: data[i][4],
            asanaWorkspace: data[i][5],
            lastUpdated: data[i][6]
          };
        }
      }
      
      // User not found, create default entry
      var userName = email.split('@')[0]; // Default to email username
      var lastRow = Math.max(sheet.getLastRow(), 1);
      var newUser = [email, userName, 'Team Lead', 'true', '', '', new Date()];
      sheet.getRange(lastRow + 1, 1, 1, newUser.length).setValues([newUser]);
      
      return {
        email: email,
        name: userName,
        role: 'Team Lead',
        emailNotification: true,
        asanaApiKey: '',
        asanaWorkspace: '',
        lastUpdated: new Date()
      };
    },
    
    /**
     * Updates user info - no hard-coding
     * @param {Object} userInfo - User info object
     * @return {boolean} - True if successful
     */
    updateUserInfo: function(userInfo) {
      var sheet = getUserConfigSheet_();
      var data = sheet.getDataRange().getValues();
      
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === userInfo.email) {
          sheet.getRange(i + 1, 2).setValue(userInfo.name);
          sheet.getRange(i + 1, 3).setValue(userInfo.role);
          sheet.getRange(i + 1, 4).setValue(userInfo.emailNotification ? 'true' : 'false');
          sheet.getRange(i + 1, 5).setValue(userInfo.asanaApiKey);
          sheet.getRange(i + 1, 6).setValue(userInfo.asanaWorkspace);
          sheet.getRange(i + 1, 7).setValue(new Date());
          return true;
        }
      }
      
      // User not found, add them
      var lastRow = Math.max(sheet.getLastRow(), 1);
      var userData = [
        userInfo.email,
        userInfo.name,
        userInfo.role,
        userInfo.emailNotification ? 'true' : 'false',
        userInfo.asanaApiKey,
        userInfo.asanaWorkspace,
        new Date()
      ];
      
      sheet.getRange(lastRow + 1, 1, 1, userData.length).setValues([userData]);
      return true;
    }
  };
})();

/**
 * Get the ConfigService instance
 * @return {Object} - ConfigService instance
 */
function getConfigService() {
  return ConfigService;
}



/**
 * OneOnOneService.gs
 * Service for managing one-on-one sessions
 */

const OneOnOneService = (function() {
  // Constants
  const SHEET_NAME = 'OneOnOneSessions';
  const REQUIRED_COLUMNS = ['id', 'teamMemberEmail', 'teamMemberName', 'date', 'content', 'status', 'createdDate', 'createdBy', 'lastUpdated', 'updatedBy'];
  
  /**
   * Initializes the OneOnOneSessions sheet if it doesn't exist
   * @return {Object} Result of the initialization
   */
  function initializeSheet() {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName(SHEET_NAME);
      
      if (sheet) {
        // Sheet already exists, check if it has all required columns
        const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
        
        // Check for missing columns
        const missingColumns = REQUIRED_COLUMNS.filter(col => !headers.includes(col));
        
        if (missingColumns.length > 0) {
          // Add missing columns
          const lastCol = headers.length + 1;
          missingColumns.forEach((col, index) => {
            sheet.getRange(1, lastCol + index).setValue(col);
          });
          
          // Format header row
          sheet.getRange(1, 1, 1, headers.length + missingColumns.length).setFontWeight('bold').setBackground('#E8EAED');
        }
        
        return {
          success: true,
          message: 'Sheet already exists and is properly configured',
          headers: headers
        };
      }
      
      // Create the sheet
      sheet = ss.insertSheet(SHEET_NAME);
      
      // Add headers
      const headers = [
        'id', 
        'teamMemberEmail', 
        'teamMemberName', 
        'date', 
        'content', 
        'statusNotes',
        'performanceNotes',
        'developmentNotes',
        'supportNotes',
        'tags', 
        'actionItems', 
        'status',
        'createdDate', 
        'createdBy', 
        'lastUpdated',
        'updatedBy'
      ];
      
      sheet.appendRow(headers);
      
      // Format header row
      const headerRange = sheet.getRange(1, 1, 1, headers.length);
      headerRange.setFontWeight('bold').setBackground('#E8EAED');
      
      // Auto-resize columns
      for (let i = 1; i <= headers.length; i++) {
        sheet.autoResizeColumn(i);
      }
      
      return {
        success: true,
        message: 'Sheet created successfully',
        headers: headers
      };
    } catch (e) {
      Logger.log('Error initializing sheet: ' + sanitizeErrorMessage(e.toString()));
      return {
        success: false,
        message: 'Error initializing sheet: ' + sanitizeErrorMessage(e.toString())
      };
    }
  }
  
  /**
   * Gets all one-on-one notes
   * @return {Array} Array of note objects
   */
  function getAllOneOnOneNotes() {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(SHEET_NAME);
      
      if (!sheet) {
        // Try to initialize the sheet
        const init = initializeSheet();
        if (!init.success) {
          throw new Error('Sheet not found and could not be created');
        }
        
        // New sheet has no data
        return [];
      }
      
      const data = sheet.getDataRange().getValues();
      if (data.length <= 1) {
        return []; // Only header row exists
      }
      
      const headers = data[0];
      const notes = [];
      
      for (let i = 1; i < data.length; i++) {
        if (!data[i][0]) continue; // Skip rows with no ID
        
        let note = {};
        
        for (let j = 0; j < headers.length; j++) {
          const header = headers[j];
          note[header] = data[i][j] != null ? data[i][j] : '';
        }
        
        // Parse JSON fields
        ['tags', 'actionItems'].forEach(field => {
          if (note[field] && typeof note[field] === 'string') {
            try {
              note[field] = JSON.parse(note[field]);
            } catch (e) {
              note[field] = [];
            }
          }
        });
        
        notes.push(note);
      }
      
      return notes;
    } catch (e) {
      Logger.log('Error getting all notes: ' + sanitizeErrorMessage(e.toString()));
      return [];
    }
  }
  
  /**
   * Gets all one-on-one sessions with optional filtering
   * CRITICAL FUNCTION - MUST BE EXPORTED IN PUBLIC API
   * @param {Object} options - Filter options
   * @return {Array} List of sessions
   */
  function getOneOnOneSessions(options = {}) {
    try {
      Logger.log("Loading one-on-one sessions with options: " + JSON.stringify(options));
      
      // Get all notes as sessions
      const allSessions = getAllOneOnOneNotes();
      Logger.log("Total sessions loaded: " + allSessions.length);
      
      // No filtering needed
      if (!options || Object.keys(options).length === 0) {
        return allSessions;
      }
      
      // Apply filters
      const filteredSessions = allSessions.filter(session => {
        // Team member filter
        if (options.teamMemberEmail && session.teamMemberEmail !== options.teamMemberEmail) {
          return false;
        }
        
        // Start date filter
        if (options.startDate) {
          const startDate = new Date(options.startDate);
          const sessionDate = new Date(session.date || session.createdDate);
          if (sessionDate < startDate) {
            return false;
          }
        }
        
        // End date filter
        if (options.endDate) {
          const endDate = new Date(options.endDate);
          const sessionDate = new Date(session.date || session.createdDate);
          if (sessionDate > endDate) {
            return false;
          }
        }
        
        // Search text filter
        if (options.searchText) {
          const searchLower = options.searchText.toLowerCase();
          const content = (session.content || '').toLowerCase();
          const teamMemberName = (session.teamMemberName || '').toLowerCase();
          
          if (!content.includes(searchLower) && !teamMemberName.includes(searchLower)) {
            return false;
          }
        }
        
        return true;
      });
      
      Logger.log("Filtered sessions: " + filteredSessions.length);
      return filteredSessions;
    } catch (e) {
      Logger.log('Error in getOneOnOneSessions: ' + e.toString());
      throw new Error('Failed to load one-on-one sessions: ' + e.toString());
    }
  }
  
  /**
   * Gets one-on-one notes for a specific team member
   * @param {string} teamMemberEmail - Email of the team member
   * @return {Array} Array of note objects for the team member
   */
  function getOneOnOneNotesByTeamMember(teamMemberEmail) {
    if (!teamMemberEmail) {
      return [];
    }
    
    try {
      const allNotes = getAllOneOnOneNotes();
      return allNotes.filter(note => 
        note.teamMemberEmail && 
        note.teamMemberEmail.toLowerCase() === teamMemberEmail.toLowerCase()
      );
    } catch (e) {
      Logger.log('Error getting notes by team member: ' + sanitizeErrorMessage(e.toString()));
      return [];
    }
  }
  
  /**
   * Gets a one-on-one note by ID
   * @param {string} noteId - ID of the note to retrieve
   * @return {Object} Result object with success flag and note data
   */
  function getOneOnOneNoteById(noteId) {
    if (!noteId) {
      return {
        success: false,
        message: 'Note ID is required'
      };
    }
    
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(SHEET_NAME);
      
      if (!sheet) {
        return {
          success: false,
          message: SHEET_NAME + ' sheet not found'
        };
      }
      
      const data = sheet.getDataRange().getValues();
      const headers = data[0];
      
      // Find the note
      for (let i = 1; i < data.length; i++) {
        if (data[i][0] === noteId) {
          // Create note object using headers as keys
          let note = {};
          for (let j = 0; j < headers.length; j++) {
            const header = headers[j];
            note[header] = data[i][j] != null ? data[i][j] : '';
          }
          
          // Parse JSON fields
          ['tags', 'actionItems'].forEach(field => {
            if (note[field] && typeof note[field] === 'string') {
              try {
                note[field] = JSON.parse(note[field]);
              } catch (e) {
                Logger.log('Error parsing ' + field + ': ' + sanitizeErrorMessage(e.toString()));
                note[field] = [];
              }
            }
          });
          
          return {
            success: true,
            note: note
          };
        }
      }
      
      // Note not found
      return {
        success: false,
        message: 'Note not found'
      };
    } catch (e) {
      Logger.log('Error getting note by ID: ' + sanitizeErrorMessage(e.toString()));
      return {
        success: false,
        message: 'Error retrieving note: ' + sanitizeErrorMessage(e.toString())
      };
    }
  }
  
  /**
   * Gets a one-on-one session by ID 
   * @param {string} sessionId - ID of the session to retrieve
   * @return {Object} The session data or null if not found
   */
  function getOneOnOneSessionById(sessionId) {
    const result = getOneOnOneNoteById(sessionId);
    return result.success ? result.note : null;
  }
  
  /**
   * Creates or updates a one-on-one note
   * @param {Object} noteData - Data for the note
   * @return {Object} Result with success flag and message
   */
  function saveOneOnOneNote(noteData) {
    if (!noteData) {
      return {
        success: false,
        message: 'Note data is required'
      };
    }
    
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName(SHEET_NAME);
      
      if (!sheet) {
        // Try to initialize the sheet
        const init = initializeSheet();
        if (!init.success) {
          throw new Error('Sheet not found and could not be created');
        }
        sheet = ss.getSheetByName(SHEET_NAME);
      }
      
      const data = sheet.getDataRange().getValues();
      const headers = data[0];
      
      // Generate ID if not provided (for new notes)
      if (!noteData.id) {
        noteData.id = Utilities.getUuid();
      }
      
      // Set created/updated timestamps
      const now = new Date();
      const userEmail = Session.getActiveUser().getEmail();
      
      // For new notes
      if (!noteData.createdDate) {
        noteData.createdDate = now;
        noteData.createdBy = userEmail;
      }
      
      // Always update the last updated fields
      noteData.lastUpdated = now;
      noteData.updatedBy = userEmail;
      
      // Convert objects to JSON strings for storage
      ['tags', 'actionItems'].forEach(field => {
        if (noteData[field] && typeof noteData[field] !== 'string') {
          try {
            noteData[field] = JSON.stringify(noteData[field]);
          } catch (e) {
            noteData[field] = '[]';
          }
        }
      });
      
      // Look for existing note with this ID
      let rowIndex = -1;
      for (let i = 1; i < data.length; i++) {
        if (data[i][0] === noteData.id) {
          rowIndex = i + 1; // +1 because sheet rows are 1-indexed
          break;
        }
      }
      
      if (rowIndex === -1) {
        // New note - append row
        const rowData = [];
        
        headers.forEach(header => {
          rowData.push(noteData[header] !== undefined ? noteData[header] : '');
        });
        
        sheet.appendRow(rowData);
        
        return {
          success: true,
          id: noteData.id,
          message: 'Note created successfully',
          isNew: true
        };
      } else {
        // Update existing note
        headers.forEach((header, index) => {
          const value = noteData[header] !== undefined ? noteData[header] : '';
          sheet.getRange(rowIndex, index + 1).setValue(value);
        });
        
        return {
          success: true,
          id: noteData.id,
          message: 'Note updated successfully',
          isNew: false
        };
      }
    } catch (e) {
      Logger.log('Error saving note: ' + sanitizeErrorMessage(e.toString()));
      return {
        success: false,
        message: 'Error saving note: ' + sanitizeErrorMessage(e.toString())
      };
    }
  }
  
  /**
   * Save a one-on-one session (properly implemented)
   * @param {Object} sessionData - Data for the session
   * @return {Object} Result with success flag and message
   */
  function saveOneOnOneSession(sessionData) {
    return saveOneOnOneNote(sessionData);
  }
  
  /**
   * Deletes a one-on-one note
   * @param {string} noteId - ID of the note to delete
   * @return {Object} Result with success flag and message
   */
  function deleteOneOnOneNote(noteId) {
    if (!noteId) {
      return {
        success: false,
        message: 'Note ID is required'
      };
    }
    
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(SHEET_NAME);
      
      if (!sheet) {
        return {
          success: false,
          message: SHEET_NAME + ' sheet not found'
        };
      }
      
      const data = sheet.getDataRange().getValues();
      
      // Find the note
      for (let i = 1; i < data.length; i++) {
        if (data[i][0] === noteId) {
          // Delete the row
          sheet.deleteRow(i + 1); // +1 because sheet rows are 1-indexed
          
          return {
            success: true,
            message: 'Note deleted successfully'
          };
        }
      }
      
      // Note not found
      return {
        success: false,
        message: 'Note not found'
      };
    } catch (e) {
      Logger.log('Error deleting note: ' + sanitizeErrorMessage(e.toString()));
      return {
        success: false,
        message: 'Error deleting note: ' + sanitizeErrorMessage(e.toString())
      };
    }
  }
  
  /**
   * Deletes a one-on-one session
   * @param {string} sessionId - ID of the session to delete
   * @return {Object} Result with success flag and message
   */
  function deleteOneOnOneSession(sessionId) {
    return deleteOneOnOneNote(sessionId);
  }
  
  /**
   * Gets all team members from the TeamService
   * @param {boolean} activeOnly - Whether to only return active team members
   * @return {Array} Array of team member objects
   */
  function getTeamMembers(activeOnly = true) {
    try {
      // Use TeamService instead of direct manipulation
      const teamService = getTeamService();
      let filters = {};
      if (activeOnly) {
        filters.status = 'Active';
      }
      return teamService.getTeamMembers(filters);
    } catch (e) {
      Logger.log('Error getting team members: ' + sanitizeErrorMessage(e.toString()));
      
      // Fallback to direct access if service fails
      try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        let sheet = ss.getSheetByName('TeamMembers');
        
        if (!sheet) {
          return [];
        }
        
        const data = sheet.getDataRange().getValues();
        const members = [];
        
        for (let i = 1; i < data.length; i++) {
          if (data[i][0]) { // Check if email exists
            const status = data[i][4] || 'Active';
            
            // Skip inactive members if activeOnly is true
            if (activeOnly && status.toLowerCase() !== 'active') {
              continue;
            }
            
            members.push({
              email: data[i][0] || '',
              firstName: data[i][1] || '',
              lastName: data[i][2] || '',
              role: data[i][3] || 'Team Member',
              status: status
            });
          }
        }
        
        return members;
      } catch (fallbackError) {
        Logger.log('Fallback error getting team members: ' + sanitizeErrorMessage(fallbackError.toString()));
        return [];
      }
    }
  }
  
  /**
   * Gets team member name from email
   * @param {string} email - Email address to look up
   * @return {string} Full name of team member or email username if not found
   */
  function getTeamMemberNameFromEmail(email) {
    if (!email) return '';
    
    try {
      // Use TeamService first
      const teamService = getTeamService();
      const member = teamService.getTeamMemberByEmail(email);
      
      if (member) {
        return `${member.firstName} ${member.lastName}`.trim();
      }
      
      // Fallback to direct access
      const members = getTeamMembers(false); // Include inactive members
      
      for (const member of members) {
        if (member.email.toLowerCase() === email.toLowerCase()) {
          return `${member.firstName} ${member.lastName}`.trim();
        }
      }
      
      // Not found - return the username part of the email
      return email.split('@')[0];
    } catch (e) {
      Logger.log('Error getting team member name: ' + sanitizeErrorMessage(e.toString()));
      return email.split('@')[0];
    }
  }
  
  /**
   * Create or update a team member - delegates to TeamService
   * @param {Object} memberData - Team member data
   * @return {Object} Result with success flag and message
   */
  function createTeamMember(memberData) {
    try {
      // Use TeamService instead of direct manipulation
      const teamService = getTeamService();
      return teamService.addTeamMember(memberData);
    } catch (e) {
      Logger.log('Error creating team member: ' + sanitizeErrorMessage(e.toString()));
      return {
        success: false,
        message: 'Error creating team member: ' + sanitizeErrorMessage(e.toString())
      };
    }
  }
  
  /**
   * Checks if the OneOnOneSessions sheet exists and returns column info
   * @return {Object} Info about the sheet status
   */
  function checkOneOnOneNotesSheet() {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(SHEET_NAME);
      
      if (!sheet) {
        return {
          exists: false,
          message: SHEET_NAME + ' sheet not found',
          columns: []
        };
      }
      
      const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
      const rowCount = sheet.getLastRow() - 1; // Exclude header
      
      return {
        exists: true,
        rowCount: rowCount,
        columns: headers,
        message: `Sheet exists with ${rowCount} rows and columns: ${headers.join(', ')}`
      };
    } catch (e) {
      return {
        exists: false,
        error: sanitizeErrorMessage(e.toString()),
        message: 'Error checking ' + SHEET_NAME + ' sheet: ' + sanitizeErrorMessage(e.toString()),
        columns: []
      };
    }
  }
  
  /**
   * Creates the OneOnOneSessions sheet with necessary columns
   * @return {Object} Result with success flag and message
   */
  function createOneOnOneNotesSheet() {
    return initializeSheet();
  }
  
  /**
   * Cache a session ID for editing
   * @param {String} sessionId - The ID to cache
   * @return {Boolean} Success status
   */
  function cacheOneOnOneSessionId(sessionId) {
    try {
      if (!sessionId) {
        return false;
      }
      
      const cache = CacheService.getUserCache();
      cache.put('currentOneOnOneSession', sessionId, 3600); // Cache for 1 hour
      
      return true;
    } catch (e) {
      Logger.log('Error caching session ID: ' + sanitizeErrorMessage(e.toString()));
      return false;
    }
  }
  
  /**
   * Gets the cached session ID
   * @return {String} The cached session ID or null
   */
  function getCachedOneOnOneSessionId() {
    try {
      const cache = CacheService.getUserCache();
      return cache.get('currentOneOnOneSession');
    } catch (e) {
      Logger.log('Error getting cached session ID: ' + sanitizeErrorMessage(e.toString()));
      return null;
    }
  }
  
  /**
   * Gets statistics about one-on-one sessions
   * @param {Object} options - Filter options
   * @return {Object} Statistics
   */
  function getOneOnOneStats(options = {}) {
    try {
      const sessions = getOneOnOneSessions(options);
      
      // Group by team member
      const byTeamMember = {};
      sessions.forEach(session => {
        if (session.teamMemberEmail) {
          if (!byTeamMember[session.teamMemberEmail]) {
            byTeamMember[session.teamMemberEmail] = [];
          }
          byTeamMember[session.teamMemberEmail].push(session);
        }
      });
      
      // Count by status
      const byStatus = {};
      sessions.forEach(session => {
        const status = session.status || 'Unknown';
        byStatus[status] = (byStatus[status] || 0) + 1;
      });
      
      // Count by month
      const byMonth = {};
      sessions.forEach(session => {
        if (session.date) {
          const date = new Date(session.date);
          const month = date.getFullYear() + '-' + 
            (date.getMonth() + 1).toString().padStart(2, '0');
          byMonth[month] = (byMonth[month] || 0) + 1;
        }
      });
      
      return {
        total: sessions.length,
        byTeamMember: byTeamMember,
        byStatus: byStatus,
        byMonth: byMonth,
        averagePerMonth: Object.keys(byMonth).length > 0 ? 
          (sessions.length / Object.keys(byMonth).length).toFixed(1) : 0
      };
    } catch (e) {
      Logger.log('Error getting stats: ' + sanitizeErrorMessage(e.toString()));
      return {
        total: 0,
        byTeamMember: {},
        byStatus: {},
        byMonth: {},
        averagePerMonth: 0
      };
    }
  }
  
  /**
   * Exports one-on-one sessions to a spreadsheet
   * @param {Object} filters - Optional filter criteria
   * @return {Object} Result with success status and URL
   */
  function exportOneOnOneSessions(filters = {}) {
    try {
      // Get filtered sessions
      const sessions = getOneOnOneSessions(filters);
      
      if (sessions.length === 0) {
        return {
          success: false,
          message: 'No sessions found to export'
        };
      }
      
      // Create a new spreadsheet
      const newSs = SpreadsheetApp.create('One-on-One Sessions Export - ' + new Date().toISOString().split('T')[0]);
      const sheet = newSs.getActiveSheet();
      
      // Get all possible headers from all sessions
      const headers = ['id', 'teamMemberEmail', 'teamMemberName', 'date', 'content', 'statusNotes', 
                      'performanceNotes', 'developmentNotes', 'supportNotes', 'status', 'createdDate'];
      
      // Add headers
      sheet.appendRow(headers);
      
      // Add data rows
      sessions.forEach(session => {
        const row = headers.map(header => {
          if (!session[header]) return '';
          
          // Format dates
          if (header.includes('date') || header.includes('Date')) {
            if (session[header] instanceof Date) {
              return session[header];
            }
            try {
              return new Date(session[header]);
            } catch (e) {
              return session[header];
            }
          }
          
          // Format JSON fields
          if ((header === 'actionItems' || header === 'tags') && typeof session[header] !== 'string') {
            try {
              return JSON.stringify(session[header]);
            } catch (e) {
              return '';
            }
          }
          
          return session[header];
        });
        
        sheet.appendRow(row);
      });
      
      // Format the sheet
      sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold').setBackground('#E8EAED');
      
      // Auto resize columns
      for (let i = 1; i <= headers.length; i++) {
        sheet.autoResizeColumn(i);
      }
      
      return {
        success: true,
        message: 'Exported ' + sessions.length + ' sessions',
        url: newSs.getUrl()
      };
    } catch (e) {
      Logger.log('Error exporting sessions: ' + sanitizeErrorMessage(e.toString()));
      return {
        success: false,
        message: 'Error exporting sessions: ' + sanitizeErrorMessage(e.toString())
      };
    }
  }
  
  /**
   * Gets current user and date information with PRIVACY PROTECTION
   * @return {Object} Current user and date info
   */
  function getCurrentUserAndDate() {
    try {
      // Get current date in a consistent format
      const now = new Date();
      const formattedDate = Utilities.formatDate(now, Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
      
      // Return GENERIC placeholder values instead of actual user information
      return {
        username: "current_user",  // Generic placeholder 
        email: "user@example.com", // Generic placeholder
        formattedDate: formattedDate,
        timestamp: now.toISOString()
      };
    } catch (e) {
      Logger.log('Error getting user and date info: ' + sanitizeErrorMessage(e.toString()));
      
      // Generate date without user info
      const now = new Date();
      
      return {
        username: '',
        email: '',
        formattedDate: now.toISOString().replace('T', ' ').slice(0, 19),
        timestamp: now.toISOString()
      };
    }
  }
  
  /**
   * Sanitizes error messages to remove any potentially sensitive information
   * @param {string} message - Error message to sanitize
   * @return {string} Sanitized message
   */
  function sanitizeErrorMessage(message) {
    if (!message) return 'Unknown error';
    
    // Remove email addresses
    let sanitized = message.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, '[EMAIL]');
    
    // Remove common usernames/names that might appear
    sanitized = sanitized.replace(/\b(user|admin|username|login|name|account)\b/gi, '[USER]');
    
    return sanitized;
  }
  
  // Public API - Properly includes all necessary functions
  return {
    // One-on-One notes/sessions
    getAllOneOnOneNotes: getAllOneOnOneNotes,
    getOneOnOneNotesByTeamMember: getOneOnOneNotesByTeamMember,
    getOneOnOneNoteById: getOneOnOneNoteById,
    saveOneOnOneNote: saveOneOnOneNote,
    saveOneOnOneSession: saveOneOnOneSession, // Added this key function
    deleteOneOnOneNote: deleteOneOnOneNote,
    getOneOnOneSessions: getOneOnOneSessions,
    getOneOnOneSessionById: getOneOnOneSessionById,
    deleteOneOnOneSession: deleteOneOnOneSession,
    
    // Sheet management
    initializeSheet: initializeSheet,
    checkOneOnOneNotesSheet: checkOneOnOneNotesSheet,
    createOneOnOneNotesSheet: createOneOnOneNotesSheet,
    
    // Team member functions
    getTeamMembers: getTeamMembers,
    getTeamMemberNameFromEmail: getTeamMemberNameFromEmail,
    createTeamMember: createTeamMember,
    
    // Utilities
    getCurrentUserAndDate: getCurrentUserAndDate,
    cacheOneOnOneSessionId: cacheOneOnOneSessionId,
    getCachedOneOnOneSessionId: getCachedOneOnOneSessionId,
    
    // Analysis
    getOneOnOneStats: getOneOnOneStats,
    exportOneOnOneSessions: exportOneOnOneSessions
  };
})();

/**
 * Get the OneOnOneService instance
 * @return {Object} - OneOnOneService instance
 */
function getOneOnOneService() {
  return OneOnOneService;
}
/******************************************
 * ADDITIONAL TEAM MANAGEMENT FUNCTIONS
 ******************************************/

/**
 * Gets team members who need a one-on-one session
 * @param {Number} days - Days threshold for needing a session (default: 14)
 * @return {Array} Array of team members needing sessions
 */
function getTeamMembersNeedingOneOnOne(days) {
  try {
    const teamService = getTeamService();
    return teamService.getTeamMembersNeedingOneOnOne(days);
  } catch (e) {
    logError('getTeamMembersNeedingOneOnOne', e.toString(), {days: days});
    return [];
  }
}

/**
 * Gets team composition statistics
 * @return {Object} Team statistics
 */
function getTeamComposition() {
  try {
    const teamService = getTeamService();
    return teamService.getTeamComposition();
  } catch (e) {
    logError('getTeamComposition', e.toString());
    return {
      total: 0,
      byStatus: {},
      byRole: {},
      averagePerformance: 0,
      topPerformers: [],
      developmentNeeded: []
    };
  }
}

/**
 * Gets team members due for performance review
 * @param {Number} months - Months threshold for review (default: 6)
 * @return {Array} Team members due for review
 */
function getTeamMembersDueForReview(months) {
  try {
    const teamService = getTeamService();
    return teamService.getTeamMembersDueForReview(months);
  } catch (e) {
    logError('getTeamMembersDueForReview', e.toString(), {months: months});
    return [];
  }
}

/**
 * Exports team roster to a spreadsheet
 * @return {Object} Result with URL of the exported spreadsheet
 */
function exportTeamRoster() {
  try {
    const teamService = getTeamService();
    const url = teamService.exportTeamRoster();
    return {
      success: true,
      url: url,
      message: 'Team roster exported successfully'
    };
  } catch (e) {
    logError('exportTeamRoster', e.toString());
    return {
      success: false,
      message: 'Error exporting team roster: ' + e.toString()
    };
  }
}

/**
 * Updates the last one-on-one date for a team member
 * @param {String} email - Email of the team member
 * @param {Date} date - Date of the one-on-one (default: now)
 * @return {Boolean} Success status
 */
function updateLastOneOnOne(email, date) {
  try {
    const teamService = getTeamService();
    return teamService.updateLastOneOnOne(email, date || new Date());
  } catch (e) {
    logError('updateLastOneOnOne', e.toString(), {email: email, date: date});
    return false;
  }
}

/**
 * Schedules a one-on-one session for a team member
 * @param {String} email - Email of the team member
 * @param {Date} date - Scheduled date
 * @return {Boolean} Success status
 */
function scheduleOneOnOne(email, date) {
  try {
    const teamService = getTeamService();
    return teamService.scheduleOneOnOne(email, date);
  } catch (e) {
    logError('scheduleOneOnOne', e.toString(), {email: email, date: date});
    return false;
  }
}

/**
 * Sends a status update notification to a team member
 * @param {String} email - Email of the team member
 * @param {String} status - New status
 * @param {String} notes - Notes about the change
 * @return {Boolean} Success status
 */
function sendStatusUpdateNotification(email, status, notes) {
  try {
    const teamService = getTeamService();
    return teamService.sendStatusUpdateNotification(email, status, notes);
  } catch (e) {
    logError('sendStatusUpdateNotification', e.toString(), {
      email: email,
      status: status,
      notes: notes
    });
    return false;
  }
}

/**
 * Deletes a team member
 * @param {String} email - Email of the team member to delete
 * @return {Object} Result with success status
 */
function deleteTeamMember(email) {
  try {
    const teamService = getTeamService();
    const success = teamService.deleteTeamMember(email);
    
    return {
      success: success,
      message: success ? 'Team member deleted successfully' : 'Team member not found'
    };
  } catch (e) {
    logError('deleteTeamMember', e.toString(), {email: email});
    return {
      success: false,
      message: 'Error deleting team member: ' + e.toString()
    };
  }
}

/**
 * Opens the export team roster dialog
 */
function openExportTeamRoster() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Team/export-team-roster')
      .evaluate()
      .setWidth(600)
      .setHeight(400)
      .setTitle('📤 Export Team Roster');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📤 Export Team Roster');
  } catch (e) {
    logError('openExportTeamRoster', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the team composition view
 */
function viewTeamComposition() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Team/team-composition')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📊 Team Composition');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📊 Team Composition');
  } catch (e) {
    logError('viewTeamComposition', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the team reviews dialog
 */
function viewTeamReviews() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/Team/team-reviews')
      .evaluate()
      .setWidth(1000)
      .setHeight(700)
      .setTitle('📝 Team Reviews');
    
    SpreadsheetApp.getUi().showModalDialog(html, '📝 Team Reviews');
  } catch (e) {
    logError('viewTeamReviews', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}




/**
 * TeamService.gs - Team Management Service
 * Created: 2025-03-22 23:10:56
 * For team management and access across all modules
 */

var TeamService = (function() {
  // Private variables and constants
  const TEAM_SHEET_NAME = 'TeamMembers';
  const TEAM_ROLES_SHEET_NAME = 'TeamRoles';
  const TEAM_HISTORY_SHEET_NAME = 'TeamMemberHistory';
  
  /**
   * Gets or creates the team members sheet
   * @return {Sheet} Google Sheet for team members
   */
  function getTeamSheet_() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(TEAM_SHEET_NAME);
    
    if (!sheet) {
      // Create new sheet with modern structure
      sheet = ss.insertSheet(TEAM_SHEET_NAME);
      
      // Add headers
      const headers = [
        'id', 'email', 'firstName', 'lastName', 'role', 'status', 'startDate', 
        'phoneNumber', 'manager', 'department', 'location', 'timeZone', 
        'scheduledHours', 'notes', 'createdDate', 'lastUpdated'
      ];
      
      sheet.appendRow(headers);
      sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold').setBackground('#E8EAED');
      sheet.setFrozenRows(1);
    }
    
    return sheet;
  }
  
  /**
   * Gets or creates the team roles sheet
   * @return {Sheet} Google Sheet for team roles
   */
  function getTeamRolesSheet_() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(TEAM_ROLES_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(TEAM_ROLES_SHEET_NAME);
      sheet.appendRow(['id', 'name', 'description', 'permissions', 'createdDate', 'lastUpdated']);
      sheet.getRange(1, 1, 1, 6).setFontWeight('bold').setBackground('#E8EAED');
    }
    
    return sheet;
  }
  
  /**
   * Gets or creates the team history sheet
   * @return {Sheet} Google Sheet for team member history
   */
  function getTeamHistorySheet_() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(TEAM_HISTORY_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(TEAM_HISTORY_SHEET_NAME);
      sheet.appendRow([
        'id', 'teamMemberId', 'changeDate', 'changeType', 'fieldChanged', 
        'oldValue', 'newValue', 'changedBy', 'notes'
      ]);
      sheet.getRange(1, 1, 1, 9).setFontWeight('bold').setBackground('#E8EAED');
    }
    
    return sheet;
  }
  
  /**
   * Records a change in team member history
   * @param {Object} changeData - Data about the change
   */
  function recordTeamMemberChange_(changeData) {
    try {
      const sheet = getTeamHistorySheet_();
      
      // Generate unique ID for this history record
      const id = Utilities.getUuid();
      
      // Add the change record
      sheet.appendRow([
        id,
        changeData.teamMemberId,
        new Date(),
        changeData.changeType,
        changeData.fieldChanged,
        changeData.oldValue,
        changeData.newValue,
        Session.getActiveUser().getEmail(),
        changeData.notes || ''
      ]);
    } catch (e) {
      Logger.log('Error recording team member change: ' + e.toString());
    }
  }
  
  /**
   * Creates a unique ID for new team members
   * @return {String} Unique ID
   */
  function createUniqueId_() {
    return Utilities.getUuid();
  }
  
  // Return public methods
  return {
    /**
     * Initializes the team management system
     * @return {Object} Result with success flag
     */
    initializeSheets: function() {
      try {
        getTeamSheet_();
        getTeamRolesSheet_();
        getTeamHistorySheet_();
        
        return {
          success: true,
          message: 'Team management system initialized successfully'
        };
      } catch (e) {
        Logger.log('Error initializing team management system: ' + e.toString());
        return {
          success: false,
          message: 'Error initializing team management system: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets team members with optional filtering
     * @param {Object} options - Filter options
     * @return {Array} Team members matching filters
     */
    getTeamMembers: function(options = {}) {
      try {
        const sheet = getTeamSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        const teamMembers = [];
        
        // Process each row (except header)
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          const member = {};
          
          // Create object from row data
          headers.forEach((header, index) => {
            member[header] = row[index];
          });
          
          // Apply filters
          
          // Filter by role
          if (options.role && member.role !== options.role) {
            continue;
          }
          
          // Filter by status (default to active only)
          if (options.includeInactive !== true && member.status !== 'active') {
            continue;
          }
          
          // Filter by department
          if (options.department && member.department !== options.department) {
            continue;
          }
          
          // Filter by manager
          if (options.manager && member.manager !== options.manager) {
            continue;
          }
          
          // Filter by location
          if (options.location && member.location !== options.location) {
            continue;
          }
          
          // Filter by ID
          if (options.id && member.id !== options.id) {
            continue;
          }
          
          // Filter by email
          if (options.email && member.email !== options.email) {
            continue;
          }
          
          // Add name property for compatibility
          member.name = member.firstName + ' ' + member.lastName;
          
          // Add formatted start date
          if (member.startDate) {
            try {
              member.formattedStartDate = Utilities.formatDate(
                new Date(member.startDate), 
                Session.getScriptTimeZone(), 
                'MMM d, yyyy'
              );
            } catch (e) {
              member.formattedStartDate = '';
            }
          }
          
          teamMembers.push(member);
        }
        
        // Sort by last name, then first name
        teamMembers.sort((a, b) => {
          if (a.lastName === b.lastName) {
            return a.firstName.localeCompare(b.firstName);
          }
          return a.lastName.localeCompare(b.lastName);
        });
        
        return teamMembers;
      } catch (e) {
        logTeamError('getTeamMembers', e.toString(), { options: JSON.stringify(options) });
        return [];
      }
    },
    
    /**
     * Gets a specific team member by ID
     * @param {String} id - Team member ID
     * @return {Object} Team member or null if not found
     */
    getTeamMemberById: function(id) {
      try {
        if (!id) return null;
        
        const teamMembers = this.getTeamMembers({ id: id });
        return teamMembers.length > 0 ? teamMembers[0] : null;
      } catch (e) {
        logTeamError('getTeamMemberById', e.toString(), { id: id });
        return null;
      }
    },
    
    /**
     * Gets a specific team member by email
     * @param {String} email - Team member email
     * @return {Object} Team member or null if not found
     */
    getTeamMemberByEmail: function(email) {
      try {
        if (!email) return null;
        
        const teamMembers = this.getTeamMembers({ email: email });
        return teamMembers.length > 0 ? teamMembers[0] : null;
      } catch (e) {
        logTeamError('getTeamMemberByEmail', e.toString(), { email: email });
        return null;
      }
    },
    
    /**
     * Adds a new team member
     * @param {Object} teamMemberData - Team member data
     * @return {Object} Result with success flag and team member ID
     */
    addTeamMember: function(teamMemberData) {
      try {
        const sheet = getTeamSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        
        // Validate required fields
        if (!teamMemberData.email || !teamMemberData.firstName || !teamMemberData.lastName) {
          return {
            success: false,
            message: 'Email, first name, and last name are required'
          };
        }
        
        // Check if email already exists
        for (let i = 1; i < data.length; i++) {
          if (data[i][1] === teamMemberData.email) { // Email is the second column (index 1)
            return {
              success: false,
              message: 'A team member with this email already exists'
            };
          }
        }
        
        // Generate a unique ID for the new member
        teamMemberData.id = createUniqueId_();
        
        // Set creation date and default status
        teamMemberData.createdDate = new Date();
        teamMemberData.lastUpdated = new Date();
        teamMemberData.status = teamMemberData.status || 'active';
        
        // Create row array for sheet
        const rowData = [];
        headers.forEach(header => {
          rowData.push(teamMemberData[header] !== undefined ? teamMemberData[header] : '');
        });
        
        // Add to sheet
        sheet.appendRow(rowData);
        
        // Record the addition in history
        recordTeamMemberChange_({
          teamMemberId: teamMemberData.id,
          changeType: 'add',
          fieldChanged: 'all',
          oldValue: '',
          newValue: 'New team member created',
          notes: 'Initial creation'
        });
        
        return {
          success: true,
          message: 'Team member added successfully',
          teamMemberId: teamMemberData.id
        };
      } catch (e) {
        logTeamError('addTeamMember', e.toString(), { teamMemberData: JSON.stringify(teamMemberData) });
        return {
          success: false,
          message: 'Error adding team member: ' + e.toString()
        };
      }
    },
    
    /**
     * Updates an existing team member
     * @param {String} id - Team member ID
     * @param {Object} teamMemberData - Updated team member data
     * @return {Object} Result with success flag
     */
    updateTeamMember: function(id, teamMemberData) {
      try {
        const sheet = getTeamSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        
        if (!id) {
          return {
            success: false,
            message: 'Team member ID is required'
          };
        }
        
        // Find the row for this team member
        let rowIndex = -1;
        let oldData = null;
        
        for (let i = 1; i < data.length; i++) {
          if (data[i][0] === id) { // ID is the first column (index 0)
            rowIndex = i + 1; // +1 because sheet rows are 1-indexed
            
            // Build object of old data for history tracking
            oldData = {};
            headers.forEach((header, index) => {
              oldData[header] = data[i][index];
            });
            
            break;
          }
        }
        
        if (rowIndex === -1 || !oldData) {
          return {
            success: false,
            message: 'Team member not found'
          };
        }
        
        // Preserve ID and creation date
        teamMemberData.id = id;
        teamMemberData.createdDate = oldData.createdDate;
        teamMemberData.lastUpdated = new Date();
        
        // Create row array for sheet
        const rowData = [];
        headers.forEach(header => {
          rowData.push(teamMemberData[header] !== undefined ? teamMemberData[header] : oldData[header]);
        });
        
        // Update sheet
        sheet.getRange(rowIndex, 1, 1, headers.length).setValues([rowData]);
        
        // Record changes for history
        for (const field in teamMemberData) {
          // Skip technical fields and unchanged fields
          if (['id', 'createdDate', 'lastUpdated'].includes(field)) continue;
          if (teamMemberData[field] === oldData[field]) continue;
          
          recordTeamMemberChange_({
            teamMemberId: id,
            changeType: 'update',
            fieldChanged: field,
            oldValue: oldData[field],
            newValue: teamMemberData[field]
          });
        }
        
        return {
          success: true,
          message: 'Team member updated successfully'
        };
      } catch (e) {
        logTeamError('updateTeamMember', e.toString(), { 
          id: id, 
          teamMemberData: JSON.stringify(teamMemberData) 
        });
        return {
          success: false,
          message: 'Error updating team member: ' + e.toString()
        };
      }
    },
    
    /**
     * Updates the status of a team member
     * @param {String} id - Team member ID
     * @param {String} status - New status (active or inactive)
     * @param {String} notes - Optional notes explaining the status change
     * @return {Object} Result with success flag
     */
    updateTeamMemberStatus: function(id, status, notes) {
      try {
        if (!id) {
          return {
            success: false,
            message: 'Team member ID is required'
          };
        }
        
        if (!['active', 'inactive'].includes(status)) {
          return {
            success: false,
            message: 'Status must be either "active" or "inactive"'
          };
        }
        
        // Get current team member data
        const member = this.getTeamMemberById(id);
        if (!member) {
          return {
            success: false,
            message: 'Team member not found'
          };
        }
        
        // Record old status for history
        const oldStatus = member.status;
        
        // Update the status
        const result = this.updateTeamMember(id, { status: status });
        
        if (result.success) {
          // Add notes for status change
          recordTeamMemberChange_({
            teamMemberId: id,
            changeType: 'status',
            fieldChanged: 'status',
            oldValue: oldStatus,
            newValue: status,
            notes: notes || `Status changed from ${oldStatus} to ${status}`
          });
        }
        
        return result;
      } catch (e) {
        logTeamError('updateTeamMemberStatus', e.toString(), { id: id, status: status });
        return {
          success: false,
          message: 'Error updating team member status: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets team roles
     * @return {Array} Available team roles
     */
    getTeamRoles: function() {
      try {
        const sheet = getTeamRolesSheet_();
        const data = sheet.getDataRange().getValues();
        
        if (data.length <= 1) {
          return []; // Only header row exists
        }
        
        const headers = data[0];
        const roles = [];
        
        // Convert data to objects
        for (let i = 1; i < data.length; i++) {
          const role = {};
          
          for (let j = 0; j < headers.length; j++) {
            role[headers[j]] = data[i][j];
          }
          
          // Parse permissions if it's a string
          if (role.permissions && typeof role.permissions === 'string') {
            try {
              role.permissions = JSON.parse(role.permissions);
            } catch (e) {
              // If parsing fails, keep as string
            }
          }
          
          roles.push(role);
        }
        
        return roles;
      } catch (e) {
        logTeamError('getTeamRoles', e.toString());
        return [];
      }
    },
    
    /**
     * Gets team member history
     * @param {String} teamMemberId - Team member ID
     * @return {Array} History records for the team member
     */
    getTeamMemberHistory: function(teamMemberId) {
      try {
        if (!teamMemberId) return [];
        
        const sheet = getTeamHistorySheet_();
        const data = sheet.getDataRange().getValues();
        
        if (data.length <= 1) {
          return []; // Only header row exists
        }
        
        const headers = data[0];
        const history = [];
        
        // Convert data to objects
        for (let i = 1; i < data.length; i++) {
          if (data[i][1] !== teamMemberId) continue; // Skip if not for this team member
          
          const record = {};
          
          for (let j = 0; j < headers.length; j++) {
            record[headers[j]] = data[i][j];
          }
          
          history.push(record);
        }
        
        // Sort by date (newest first)
        history.sort((a, b) => new Date(b.changeDate) - new Date(a.changeDate));
        
        return history;
      } catch (e) {
        logTeamError('getTeamMemberHistory', e.toString(), { teamMemberId: teamMemberId });
        return [];
      }
    },
    
    /**
     * Gets team statistics
     * @return {Object} Team statistics
     */
    getTeamStatistics: function() {
      try {
        const allMembers = this.getTeamMembers({ includeInactive: true });
        
        if (allMembers.length === 0) {
          return {
            totalMembers: 0,
            activeMembers: 0,
            inactiveMembers: 0,
            byRole: {},
            byDepartment: {},
            byLocation: {}
          };
        }
        
        const activeMembers = allMembers.filter(m => m.status === 'active');
        const inactiveMembers = allMembers.filter(m => m.status === 'inactive');
        
        // Count by role
        const byRole = {};
        allMembers.forEach(member => {
          const role = member.role || 'Unassigned';
          byRole[role] = byRole[role] || { total: 0, active: 0, inactive: 0 };
          byRole[role].total++;
          
          if (member.status === 'active') {
            byRole[role].active++;
          } else {
            byRole[role].inactive++;
          }
        });
        
        // Count by department
        const byDepartment = {};
        allMembers.forEach(member => {
          const dept = member.department || 'Unassigned';
          byDepartment[dept] = byDepartment[dept] || { total: 0, active: 0, inactive: 0 };
          byDepartment[dept].total++;
          
          if (member.status === 'active') {
            byDepartment[dept].active++;
          } else {
            byDepartment[dept].inactive++;
          }
        });
        
        // Count by location
        const byLocation = {};
        allMembers.forEach(member => {
          const loc = member.location || 'Unassigned';
          byLocation[loc] = byLocation[loc] || { total: 0, active: 0, inactive: 0 };
          byLocation[loc].total++;
          
          if (member.status === 'active') {
            byLocation[loc].active++;
          } else {
            byLocation[loc].inactive++;
          }
        });
        
        return {
          totalMembers: allMembers.length,
          activeMembers: activeMembers.length,
          inactiveMembers: inactiveMembers.length,
          byRole: byRole,
          byDepartment: byDepartment,
          byLocation: byLocation
        };
      } catch (e) {
        logTeamError('getTeamStatistics', e.toString());
        return {
          totalMembers: 0,
          activeMembers: 0,
          inactiveMembers: 0,
          byRole: {},
          byDepartment: {},
          byLocation: {}
        };
      }
    },
    
    /**
     * Exports team data to a spreadsheet
     * @param {Object} options - Export options
     * @return {Object} Result with export URL
     */
    exportTeamData: function(options = {}) {
      try {
        const exportName = options.exportName || 'Team Export';
        
        // Get team members
        const teamMembers = this.getTeamMembers(options);
        
        if (teamMembers.length === 0) {
          return {
            success: false,
            message: 'No team members found matching the specified criteria'
          };
        }
        
        // Create a spreadsheet for the export
        const ss = SpreadsheetApp.create(exportName);
        const sheet = ss.getActiveSheet();
        sheet.setName('Team Members');
        
        // Define columns for export
        const columns = [
          'ID', 'Email', 'First Name', 'Last Name', 'Role', 'Status',
          'Start Date', 'Phone Number', 'Manager', 'Department', 
          'Location', 'Time Zone', 'Scheduled Hours', 'Notes'
        ];
        
        // Add headers
        sheet.appendRow(columns);
        sheet.getRange(1, 1, 1, columns.length).setFontWeight('bold').setBackground('#E8EAED');
        
        // Add data
        const rows = teamMembers.map(member => [
          member.id,
          member.email,
          member.firstName,
          member.lastName,
          member.role,
          member.status,
          member.startDate,
          member.phoneNumber,
          member.manager,
          member.department,
          member.location,
          member.timeZone,
          member.scheduledHours,
          member.notes
        ]);
        
        if (rows.length > 0) {
          sheet.getRange(2, 1, rows.length, columns.length).setValues(rows);
        }
        
        // Format date column
        if (rows.length > 0) {
          sheet.getRange(2, 7, rows.length, 1).setNumberFormat('yyyy-mm-dd'); // Start Date
        }
        
        // Auto-resize columns
        for (let i = 1; i <= columns.length; i++) {
          sheet.autoResizeColumn(i);
        }
        
        return {
          success: true,
          message: 'Successfully exported ' + teamMembers.length + ' team members',
          url: ss.getUrl()
        };
      } catch (e) {
        logTeamError('exportTeamData', e.toString(), { options: JSON.stringify(options) });
        return {
          success: false,
          message: 'Error exporting team data: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets available team departments
     * @return {Array} List of unique departments
     */
    getAvailableDepartments: function() {
      try {
        const members = this.getTeamMembers({ includeInactive: true });
        const departments = new Set();
        
        members.forEach(member => {
          if (member.department) {
            departments.add(member.department);
          }
        });
        
        return Array.from(departments).sort();
      } catch (e) {
        logTeamError('getAvailableDepartments', e.toString());
        return [];
      }
    },
    
    /**
     * Gets available team locations
     * @return {Array} List of unique locations
     */
    getAvailableLocations: function() {
      try {
        const members = this.getTeamMembers({ includeInactive: true });
        const locations = new Set();
        
        members.forEach(member => {
          if (member.location) {
            locations.add(member.location);
          }
        });
        
        return Array.from(locations).sort();
      } catch (e) {
        logTeamError('getAvailableLocations', e.toString());
        return [];
      }
    },
    
    /**
     * Gets team managers
     * @param {Boolean} activeOnly - Whether to include only active managers
     * @return {Array} List of team managers
     */
    getTeamManagers: function(activeOnly = true) {
      try {
        // Get all members
        const options = activeOnly ? {} : { includeInactive: true };
        const members = this.getTeamMembers(options);
        
        // Extract unique managers
        const managerEmails = new Set();
        const managers = [];
        
        members.forEach(member => {
          // Skip if no manager specified
          if (!member.manager) return;
          
          // Check if already added
          if (!managerEmails.has(member.manager)) {
            managerEmails.add(member.manager);
            
            // Try to find the manager's details
            const managerDetails = members.find(m => m.email === member.manager);
            
            if (managerDetails) {
              managers.push(managerDetails);
            } else {
              // Manager not found in our team list, create minimal entry
              managers.push({
                email: member.manager,
                name: member.manager.split('@')[0],
                isExternalManager: true
              });
            }
          }
        });
        
        return managers;
      } catch (e) {
        logTeamError('getTeamManagers', e.toString(), { activeOnly: activeOnly });
        return [];
      }
    },
    
    /**
     * Imports team data from a CSV string
     * @param {String} csvString - CSV data as string
     * @return {Object} Import results with counts and errors
     */
    importTeamDataFromCsv: function(csvString) {
      try {
        if (!csvString) {
          return {
            success: false,
            message: 'No CSV data provided'
          };
        }
        
        // Parse CSV
        const rows = Utilities.parseCsv(csvString);
        
        if (rows.length < 2) {
          return {
            success: false,
            message: 'CSV must include a header row and at least one data row'
          };
        }
        
        // Extract header row
        const headers = rows[0];
        
        // Check required columns
        const requiredColumns = ['email', 'firstName', 'lastName'];
        const missingColumns = [];
        
        requiredColumns.forEach(column => {
          if (!headers.map(h => h.toLowerCase()).includes(column.toLowerCase())) {
            missingColumns.push(column);
          }
        });
        
        if (missingColumns.length > 0) {
          return {
            success: false,
            message: 'Missing required columns: ' + missingColumns.join(', ')
          };
        }
        
        // Process each row
        const results = {
          success: true,
          total: rows.length - 1, // Minus header row
          added: 0,
          updated: 0,
          skipped: 0,
          errors: []
        };
        
        // Get existing team members for update/add determination
        const existingMembers = this.getTeamMembers({ includeInactive: true });
        const existingEmails = existingMembers.reduce((map, member) => {
          map[member.email.toLowerCase()] = member.id;
          return map;
        }, {});
        
        // Process each data row
        for (let i = 1; i < rows.length; i++) {
          try {
            const rowData = {};
            
            // Build object from row
            headers.forEach((header, index) => {
              rowData[header] = rows[i][index];
            });
            
            // Skip rows with empty required fields
            if (!rowData.email || !rowData.firstName || !rowData.lastName) {
              results.skipped++;
              results.errors.push(`Row ${i + 1}: Missing required fields`);
              continue;
            }
            
            // Check if this is an update or add
            const email = rowData.email.toLowerCase();
            const existingId = existingEmails[email];
            
            if (existingId) {
              // Update existing member
              const updateResult = this.updateTeamMember(existingId, rowData);
              
              if (updateResult.success) {
                results.updated++;
              } else {
                results.errors.push(`Row ${i + 1}: Update failed - ${updateResult.message}`);
                results.skipped++;
              }
            } else {
              // Add new member
              const addResult = this.addTeamMember(rowData);
              
              if (addResult.success) {
                results.added++;
              } else {
                results.errors.push(`Row ${i + 1}: Add failed - ${addResult.message}`);
                results.skipped++;
              }
            }
          } catch (rowError) {
            results.errors.push(`Row ${i + 1}: ${rowError.toString()}`);
            results.skipped++;
          }
        }
        
        // Create summary message
        results.message = `Import completed: ${results.added} added, ${results.updated} updated, ${results.skipped} skipped`;
        
        return results;
      } catch (e) {
        logTeamError('importTeamDataFromCsv', e.toString());
        return {
          success: false,
          message: 'Error importing team data: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets direct reports for a manager
     * @param {String} managerEmail - Manager's email
     * @return {Array} Direct reports
     */
    getDirectReports: function(managerEmail) {
      try {
        if (!managerEmail) return [];
        
        return this.getTeamMembers({
          manager: managerEmail
        });
      } catch (e) {
        logTeamError('getDirectReports', e.toString(), { managerEmail: managerEmail });
        return [];
      }
    }
  };
})();

/**
 * Gets team members using the standardized approach
 * @param {Object} options - Optional filters for team members
 * @return {Array} Team members
 */
function getTeamMembers(options = {}) {
  try {
    // Get team members from the TeamMemberService
    return getTeamMemberService().getTeamMembers(options);
  } catch (e) {
    Logger.log('Error getting team members: ' + e.toString());
    return [];
  }
}

/**
 * Logs team service errors
 * @param {String} source - Source function
 * @param {String} error - Error message
 * @param {Object} context - Additional context
 */
function logTeamError(source, error, context = {}) {
  try {
    Logger.log(`Team Error [${source}]: ${error}`);
    
    // Log to error tracking sheet if it exists
    if (typeof logSystemError === 'function') {
      logSystemError('TeamService', source, error, JSON.stringify(context));
    }
  } catch (e) {
    // If even error logging fails, just use Logger as fallback
    Logger.log(`Failed to log team error: ${e.toString()}`);
    Logger.log(`Original team error [${source}]: ${error}`);
  }
}

/**
 * Get the TeamService instance
 * @return {Object} TeamService instance
 */
function getTeamMemberService() {
  return TeamService;
}

/**
 * Initialize the team management system
 * @return {Object} Result with success flag
 */
function initializeTeamSystem() {
  return TeamService.initializeSheets();
}

/**
 * UI navigation functions for Team Management
 */

/**
 * Opens the team member list view
 */
function openTeamMemberList() {
  try {
    const html = HtmlService.createTemplateFromFile('HTML/Team/team-member-list')
      .evaluate()
      .setTitle('Team Members')
      .setWidth(1200)
      .setHeight(800);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Team Members');
  } catch (e) {
    logTeamError('openTeamMemberList', e.toString());
    SpreadsheetApp.getUi().alert('Error opening team member list: ' + e.toString());
  }
}

/**
 * Opens the team member form
 * @param {String} id - Optional team member ID for editing
 */
function openTeamMemberForm(id) {
  try {
    const template = HtmlService.createTemplateFromFile('HTML/Team/team-member-form');
    
    // Pass the ID to the template if provided
    if (id) template.teamMemberId = id;
    
    const html = template.evaluate()
      .setTitle('Team Member')
      .setWidth(800)
      .setHeight(700);
    
    SpreadsheetApp.getUi().showModalDialog(html, id ? 'Edit Team Member' : 'Add Team Member');
  } catch (e) {
    logTeamError('openTeamMemberForm', e.toString(), { id: id });
    SpreadsheetApp.getUi().alert('Error opening team member form: ' + e.toString());
  }
}

/**
 * Opens the team dashboard
 */
function openTeamDashboard() {
  try {
    const html = HtmlService.createTemplateFromFile('HTML/Team/team-dashboard')
      .evaluate()
      .setTitle('Team Dashboard')
      .setWidth(1200)
      .setHeight(800);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Team Dashboard');
  } catch (e) {
    logTeamError('openTeamDashboard', e.toString());
    SpreadsheetApp.getUi().alert('Error opening team dashboard: ' + e.toString());
  }
}

/**
 * Opens team member import form
 */
function openTeamImport() {
  try {
    const html = HtmlService.createTemplateFromFile('HTML/Team/team-import')
      .evaluate()
      .setTitle('Import Team Members')
      .setWidth(800)
      .setHeight(600);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Import Team Members');
  } catch (e) {
    logTeamError('openTeamImport', e.toString());
    SpreadsheetApp.getUi().alert('Error opening team import form: ' + e.toString());
  }
}

/**
 * Opens team member history view
 * @param {String} id - Team member ID
 */
function openTeamMemberHistory(id) {
  try {
    if (!id) {
      SpreadsheetApp.getUi().alert('Error: Team member ID is required to view history');
      return;
    }
    
    const template = HtmlService.createTemplateFromFile('HTML/Team/team-member-history');
    template.teamMemberId = id;
    
    const html = template.evaluate()
      .setTitle('Team Member History')
      .setWidth(900)
      .setHeight(700);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Team Member History');
  } catch (e) {
    logTeamError('openTeamMemberHistory', e.toString(), { id: id });
    SpreadsheetApp.getUi().alert('Error opening team member history: ' + e.toString());
  }
}

/**
 * ActionItemService.gs - Services for managing action items
 */

var ActionItemService = (function() {
  // Private variables and methods
  var ACTION_ITEMS_SHEET_NAME = 'ActionItems';
  
  /**
   * Gets the action items sheet, creates if it doesn't exist
   * @return {Sheet} - Google Sheet for action items
   */
  function getActionItemsSheet_() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(ACTION_ITEMS_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(ACTION_ITEMS_SHEET_NAME);
      
      // Create the headers
      var headers = [
        'ID', 'Description', 'Owner', 'Due Date', 'Status',
        'Source Type', 'Source ID', 'Created By', 'Created Date',
        'Completed Date', 'Notes', 'Last Updated'
      ];
      
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
      
      // Format date columns
      var dateColumns = [4, 9, 10, 12]; // Due Date, Created Date, Completed Date, Last Updated
      dateColumns.forEach(function(col) {
        sheet.getRange(2, col, 999, 1).setNumberFormat('yyyy-mm-dd');
      });
      
      // Add data validation for Status
      var rule = SpreadsheetApp.newDataValidation()
        .requireValueInList(['Open', 'In Progress', 'Completed', 'Cancelled', 'Blocked'])
        .setAllowInvalid(false)
        .build();
      
      sheet.getRange(2, 5, 999, 1).setDataValidation(rule);
    }
    
    return sheet;
  }
  
  return {
    /**
     * Adds a new action item
     * @param {Object} actionItemData - Action item data
     * @return {String} - ID of the created action item
     */
    addActionItem: function(actionItemData) {
      // Input validation
      if (!actionItemData.description || !actionItemData.owner) {
        throw new Error('Description and owner are required for action items');
      }
      
      var sheet = getActionItemsSheet_();
      var actionId = Utilities.getUuid();
      var currentUser = Session.getActiveUser().getEmail();
      var now = new Date();
      
      var rowData = [
        actionId,
        actionItemData.description,
        actionItemData.owner,
        actionItemData.dueDate ? new Date(actionItemData.dueDate) : null,
        actionItemData.status || 'Open',
        actionItemData.sourceType || '',
        actionItemData.sourceId || '',
        currentUser,
        now,
        null, // Completed date
        actionItemData.notes || '',
        now
      ];
      
      var lastRow = Math.max(sheet.getLastRow(), 1);
      sheet.getRange(lastRow + 1, 1, 1, rowData.length).setValues([rowData]);
      
      return actionId;
    },
    
    /**
     * Gets all action items or filtered by criteria
     * @param {Object} filters - Optional filter criteria
     * @return {Array} - Array of action item objects
     */
    getActionItems: function(filters) {
      var sheet = getActionItemsSheet_();
      var data = sheet.getDataRange().getValues();
      var actionItems = [];
      
      // Skip header row
      for (var i = 1; i < data.length; i++) {
        var row = data[i];
        var item = {
          id: row[0],
          description: row[1],
          owner: row[2],
          dueDate: row[3],
          status: row[4],
          sourceType: row[5],
          sourceId: row[6],
          createdBy: row[7],
          createdDate: row[8],
          completedDate: row[9],
          notes: row[10],
          lastUpdated: row[11]
        };
        
        // Apply filters if provided
        if (filters) {
          if (filters.id && item.id !== filters.id) continue;
          if (filters.owner && item.owner !== filters.owner) continue;
          if (filters.status && item.status !== filters.status) continue;
          if (filters.sourceType && item.sourceType !== filters.sourceType) continue;
          if (filters.sourceId && item.sourceId !== filters.sourceId) continue;
          if (filters.createdBy && item.createdBy !== filters.createdBy) continue;
          if (filters.dueBefore && item.dueDate > filters.dueBefore) continue;
          if (filters.dueAfter && item.dueDate < filters.dueAfter) continue;
        }
        
        actionItems.push(item);
      }
      
      return actionItems;
    },
    
    /**
     * Gets a specific action item by ID
     * @param {String} actionItemId - ID of the action item to retrieve
     * @return {Object} - Action item object or null if not found
     */
    getActionItem: function(actionItemId) {
      var items = this.getActionItems({id: actionItemId});
      return items.length > 0 ? items[0] : null;
    },
    
    /**
     * Updates an existing action item
     * @param {String} actionItemId - ID of the action item to update
     * @param {Object} actionItemData - Updated action item data
     * @return {Boolean} - True if successful
     */
    updateActionItem: function(actionItemId, actionItemData) {
      var sheet = getActionItemsSheet_();
      var data = sheet.getDataRange().getValues();
      var rowIndex = -1;
      
      // Find the action item by ID
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === actionItemId) {
          rowIndex = i + 1; // +1 because i is 0-based and row indices are 1-based
          break;
        }
      }
      
      if (rowIndex === -1) {
        throw new Error('Action item not found');
      }
      
      // Update only the fields that are provided
      var row = data[rowIndex-1];
      if (actionItemData.description !== undefined) row[1] = actionItemData.description;
      if (actionItemData.owner !== undefined) row[2] = actionItemData.owner;
      if (actionItemData.dueDate !== undefined) row[3] = actionItemData.dueDate ? new Date(actionItemData.dueDate) : null;
      if (actionItemData.status !== undefined) {
        row[4] = actionItemData.status;
        // If marked as completed, set the completed date
        if (actionItemData.status === 'Completed' && !row[9]) {
          row[9] = new Date();
        } else if (actionItemData.status !== 'Completed') {
          row[9] = null; // Clear completed date if not completed
        }
      }
      if (actionItemData.notes !== undefined) row[10] = actionItemData.notes;
      row[11] = new Date(); // Last updated
      
      sheet.getRange(rowIndex, 1, 1, row.length).setValues([row]);
      
      return true;
    },
    
    /**
     * Marks an action item as completed
     * @param {String} actionItemId - ID of the action item
     * @return {Boolean} - True if successful
     */
    completeActionItem: function(actionItemId) {
      return this.updateActionItem(actionItemId, {
        status: 'Completed'
      });
    },
    
    /**
     * Deletes an action item
     * @param {String} actionItemId - ID of the action item to delete
     * @return {Boolean} - True if successful
     */
    deleteActionItem: function(actionItemId) {
      var sheet = getActionItemsSheet_();
      var data = sheet.getDataRange().getValues();
      
      // Find the action item by ID
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === actionItemId) {
          sheet.deleteRow(i + 1); // +1 because i is 0-based and row indices are 1-based
          return true;
        }
      }
      
      return false; // Action item not found
    },
    
    /**
     * Removes action items by source
     * @param {String} sourceId - Source ID
     * @param {String} sourceType - Source type
     * @return {Number} - Number of action items removed
     */
    removeBySource: function(sourceId, sourceType) {
      var items = this.getActionItems({
        sourceId: sourceId,
        sourceType: sourceType
      });
      
      var count = 0;
      items.forEach(function(item) {
        if (this.deleteActionItem(item.id)) {
          count++;
        }
      }, this);
      
      return count;
    },
    
    /**
     * Gets upcoming or overdue action items
     * @param {String} ownerEmail - Optional owner email filter
     * @param {Number} days - Days threshold (negative for overdue)
     * @return {Array} - Array of action items
     */
    getActionItemsDue: function(ownerEmail, days) {
      var today = new Date();
      var targetDate = new Date();
      targetDate.setDate(today.getDate() + (days || 0));
      
      var filters = {
        status: 'Open'
      };
      
      if (ownerEmail) {
        filters.owner = ownerEmail;
      }
      
      var items = this.getActionItems(filters);
      
      return items.filter(function(item) {
        if (!item.dueDate) return false;
        
        if (days >= 0) {
          // Upcoming: due date between now and target date
          return item.dueDate >= today && item.dueDate <= targetDate;
        } else {
          // Overdue: due date before today
          return item.dueDate < today;
        }
      });
    },
    
    /**
     * Sends reminders for upcoming action items
     * @return {Number} - Number of reminders sent
     */
    sendActionItemReminders: function() {
      var configService = getConfigService();
      var reminderDays = configService.getSetting('action_item_reminder_days').split(',').map(Number);
      var sentCount = 0;
      
      // For each reminder threshold, get items and send reminders
      reminderDays.forEach(function(days) {
        var items = this.getActionItemsDue(null, days);
        
        // Group by owner to send consolidated emails
        var ownerItems = {};
        items.forEach(function(item) {
          if (!ownerItems[item.owner]) {
            ownerItems[item.owner] = [];
          }
          ownerItems[item.owner].push(item);
        });
        
        // Send reminders to each owner
        for (var owner in ownerItems) {
          if (ownerItems.hasOwnProperty(owner)) {
            var subject = 'Action Items Reminder: ' + ownerItems[owner].length + ' item(s) due in ' + days + ' day(s)';
            
            var body = 'Dear team member,\n\n';
            body += 'This is a friendly reminder that you have the following action item(s) coming due:\n\n';
            
            ownerItems[owner].forEach(function(item, index) {
              body += (index+1) + '. ' + item.description + ' (Due: ' + 
                    Utilities.formatDate(item.dueDate, Session.getScriptTimeZone(), 'MMMM dd, yyyy') + ')\n';
              if (item.notes) {
                body += '   Notes: ' + item.notes + '\n';
              }
              body += '\n';
            });
            
            body += 'Please update the status of these items in the Team Lead Dashboard.\n\n';
            body += 'Thank you,\nCrisis Team Management';
            
            try {
              GmailApp.sendEmail(owner, subject, body);
              sentCount++;
            } catch (e) {
              Logger.log('Failed to send email to ' + owner + ': ' + e.toString());
            }
          }
        }
      }, this);
      
      return sentCount;
    }
  };
})();

/**
 * Get the ActionItemService instance
 * @return {Object} - ActionItemService instance
 */
function getActionItemService() {
  return ActionItemService;
}

/**
 * UtilityService.gs - Utility functions and helpers
 */

var UtilityService = (function() {
  return {
    /**
     * Formats a date to a readable string
     * @param {Date} date - Date to format
     * @param {String} format - Optional format string
     * @return {String} - Formatted date string
     */
    formatDate: function(date, format) {
      if (!date) return '';
      
      var dateObj = new Date(date);
      return Utilities.formatDate(dateObj, Session.getScriptTimeZone(), 
                                 format || 'MMM dd, yyyy');
    },
    
    /**
     * Gets the relative time string (e.g., "2 days ago")
     * @param {Date} date - Date to compare
     * @return {String} - Relative time string
     */
    getRelativeTimeString: function(date) {
      if (!date) return 'Never';
      
      var now = new Date();
      var diffMs = now - new Date(date);
      var diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      var diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      var diffMinutes = Math.floor(diffMs / (1000 * 60));
      
      if (diffDays > 365) {
        return 'Over a year ago';
      } else if (diffDays > 30) {
        var months = Math.floor(diffDays / 30);
        return months + ' month' + (months === 1 ? '' : 's') + ' ago';
      } else if (diffDays > 0) {
        return diffDays + ' day' + (diffDays === 1 ? '' : 's') + ' ago';
      } else if (diffHours > 0) {
        return diffHours + ' hour' + (diffHours === 1 ? '' : 's') + ' ago';
      } else if (diffMinutes > 0) {
        return diffMinutes + ' minute' + (diffMinutes === 1 ? '' : 's') + ' ago';
      } else {
        return 'Just now';
      }
    },
    
    /**
     * Generates a color based on a value and thresholds
     * @param {Number} value - Value to compare
     * @param {Number} warningThreshold - Warning threshold
     * @param {Number} dangerThreshold - Danger threshold
     * @return {String} - CSS color class
     */
    getColorForValue: function(value, warningThreshold, dangerThreshold) {
      if (value <= dangerThreshold) {
        return 'danger';
      } else if (value <= warningThreshold) {
        return 'warning';
      } else {
        return 'success';
      }
    },
    
    /**
     * Checks if a string is a valid email address
     * @param {String} email - Email address to validate
     * @return {Boolean} - True if valid
     */
    isValidEmail: function(email) {
      var emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
      return emailRegex.test(email);
    },
    
    /**
     * Generates HTML for a status badge
     * @param {String} status - Status text
     * @return {String} - HTML for status badge
     */
    getStatusBadgeHtml: function(status) {
      var badgeClass = '';
      
      switch (status.toLowerCase()) {
        case 'active':
        case 'open':
        case 'completed':
        case 'approved':
          badgeClass = 'badge-success';
          break;
        case 'in progress':
        case 'pending':
        case 'training':
          badgeClass = 'badge-primary';
          break;
        case 'blocked':
        case 'on hold':
          badgeClass = 'badge-warning';
          break;
        case 'cancelled':
        case 'closed':
        case 'rejected':
          badgeClass = 'badge-danger';
          break;
        default:
          badgeClass = 'badge-secondary';
      }
      
      return '<span class="badge ' + badgeClass + '">' + status + '</span>';
    },
    
    /**
     * Converts a string to title case (first letter of each word capitalized)
     * @param {String} str - Input string
     * @return {String} - Title case string
     */
    toTitleCase: function(str) {
      if (!str) return '';
      return str.replace(/\w\S*/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    },
    
    /**
     * Creates a downloadable CSV file from data
     * @param {Array} data - 2D array of data
     * @param {Array} headers - Array of column headers
     * @return {String} - Base64 encoded CSV content
     */
    createCsvFile: function(data, headers) {
      var csv = headers.join(',') + '\n';
      
      data.forEach(function(row) {
        var processedRow = row.map(function(cell) {
          // Handle null or undefined
          if (cell === null || cell === undefined) {
            return '';
          }
          
          // Convert to string and handle commas by wrapping in quotes
          var cellStr = String(cell);
          if (cellStr.indexOf(',') !== -1 || cellStr.indexOf('"') !== -1 || cellStr.indexOf('\n') !== -1) {
            return '"' + cellStr.replace(/"/g, '""') + '"';
          }
          return cellStr;
        });
        
        csv += processedRow.join(',') + '\n';
      });
      
      return Utilities.base64Encode(csv);
    },
    
    /**
     * Gets schedule range for the week
     * @param {Date} date - Reference date
     * @return {Object} - Start and end dates
     */
    getWeekRange: function(date) {
      var refDate = new Date(date);
      var day = refDate.getDay();
      var diff = refDate.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
      
      var weekStart = new Date(refDate.setDate(diff));
      weekStart.setHours(0, 0, 0, 0);
      
      var weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      weekEnd.setHours(23, 59, 59, 999);
      
      return {
        start: weekStart,
        end: weekEnd
      };
    },
    
    /**
     * Creates a trigger to run a function at a specific date/time
     * @param {String} functionName - Function to trigger
     * @param {Date} triggerDate - When to trigger the function
     * @return {String} - ID of the created trigger
     */
    createTimeTrigger: function(functionName, triggerDate) {
      // Delete any existing triggers for this function to avoid duplicates
      var existingTriggers = ScriptApp.getProjectTriggers();
      
      for (var i = 0; i < existingTriggers.length; i++) {
        if (existingTriggers[i].getHandlerFunction() === functionName) {
          ScriptApp.deleteTrigger(existingTriggers[i]);
        }
      }
      
      // Create new trigger
      var trigger = ScriptApp.newTrigger(functionName)
        .timeBased()
        .at(triggerDate)
        .create();
      
      return trigger.getUniqueId();
    },
    
    /**
     * Gets time blocks for scheduling
     * @return {Array} - Array of time block objects
     */
    getTimeBlocks: function() {
      var configService = getConfigService();
      var startHour = parseInt(configService.getSetting('schedule_hours_start')) || 0;
      var endHour = parseInt(configService.getSetting('schedule_hours_end')) || 24;
      var blocks = [];
      
      for (var hour = startHour; hour < endHour; hour++) {
        blocks.push({
          start: hour + ':00',
          end: hour + ':30',
          display: this.formatTimeBlock(hour, 0) + ' - ' + this.formatTimeBlock(hour, 30)
        });
        
        blocks.push({
          start: hour + ':30',
          end: (hour + 1) + ':00',
          display: this.formatTimeBlock(hour, 30) + ' - ' + this.formatTimeBlock(hour + 1, 0)
        });
      }
      
      return blocks;
    },
    
    /**
     * Formats a time block
     * @param {Number} hour - Hour (0-23)
     * @param {Number} minute - Minute (0-59)
     * @return {String} - Formatted time string
     */
    formatTimeBlock: function(hour, minute) {
      var h = hour % 12;
      if (h === 0) h = 12;
      var ampm = hour < 12 ? 'AM' : 'PM';
      
      return h + ':' + (minute < 10 ? '0' : '') + minute + ' ' + ampm;
    }
  };
})();

/**
 * Get the UtilityService instance
 * @return {Object} - UtilityService instance
 */
function getUtilityService() {
  return UtilityService;
}

/**
 * DashboardService.gs - Services for the dashboard
 */

var DashboardService = (function() {
  return {
    /**
     * Gets summary data for the dashboard
     * @return {Object} - Dashboard summary data
     */
    getDashboardSummary: function() {
      var summary = {
        team: {
          total: 0,
          active: 0,
          training: 0,
          other: 0
        },
        oneOnOne: {
          total: 0,
          completed: 0,
          upcoming: 0,
          overdue: 0
        },
        actionItems: {
          total: 0,
          open: 0,
          completed: 0,
          overdue: 0
        }
      };
      
      try {
        // Team stats
        if (typeof getTeamMembers === 'function') {
          var teamMembers = getTeamMembers();
          summary.team.total = teamMembers.length;
          
          teamMembers.forEach(function(member) {
            if (member.status === 'Active') {
              summary.team.active++;
            } else if (member.status === 'Training') {
              summary.team.training++;
            } else {
              summary.team.other++;
            }
          });
        }
        
        // One-on-One stats
        if (typeof getOneOnOneSessions === 'function') {
          var oneOnOnes = getOneOnOneSessions();
          summary.oneOnOne.total = oneOnOnes.length;
          
          oneOnOnes.forEach(function(session) {
            if (session.complete) {
              summary.oneOnOne.completed++;
            }
          });
          
          // Calculate upcoming
          var now = new Date();
          var upcomingCount = 0;
          var overdueCount = 0;
          
          oneOnOnes.forEach(function(session) {
            if (!session.complete) {
              var sessionDate = new Date(session.date);
              if (sessionDate < now) {
                overdueCount++;
              } else {
                upcomingCount++;
              }
            }
          });
          
          summary.oneOnOne.upcoming = upcomingCount;
          summary.oneOnOne.overdue = overdueCount;
        }
        
        // Action Items stats
        // Try different possible function names
        var actionItems = [];
        if (typeof getActionItems === 'function') {
          actionItems = getActionItems();
        }
        
        summary.actionItems.total = actionItems.length;
        var now = new Date();
        
        actionItems.forEach(function(item) {
          if (item.status === 'Completed') {
            summary.actionItems.completed++;
          } else {
            summary.actionItems.open++;
            
            // Check if overdue
            if (item.dueDate && new Date(item.dueDate) < now) {
              summary.actionItems.overdue++;
            }
          }
        });
      } catch (e) {
        Logger.log("Error in getDashboardSummary: " + e.toString());
        // Continue with default values already set
      }
      
      return summary;
    },
    
    /**
     * Gets data for one-on-one chart
     * @return {Object} - Chart data object
     */
    getOneOnOneChartData: function() {
      try {
        var monthlyData = {};
        var now = new Date();
        var sixMonthsAgo = new Date();
        sixMonthsAgo.setMonth(now.getMonth() - 6);
        
        // Generate monthly labels for the last 6 months
        var labels = [];
        var completedData = [];
        var incompleteData = [];
        
        for (var i = 0; i < 6; i++) {
          var date = new Date();
          date.setMonth(now.getMonth() - 5 + i);
          var monthYear = Utilities.formatDate(date, Session.getScriptTimeZone(), 'MMM yyyy');
          labels.push(monthYear);
          
          // Initialize with zeros
          monthlyData[monthYear] = {
            completed: 0,
            incomplete: 0
          };
        }
        
        // Try to get sessions from your existing functions
        if (typeof getOneOnOneSessions === 'function') {
          var sessions = getOneOnOneSessions();
          
          sessions.forEach(function(session) {
            var date = new Date(session.date);
            if (date >= sixMonthsAgo) {
              var monthYear = Utilities.formatDate(date, Session.getScriptTimeZone(), 'MMM yyyy');
              
              if (monthlyData[monthYear]) {
                if (session.complete) {
                  monthlyData[monthYear].completed++;
                } else {
                  monthlyData[monthYear].incomplete++;
                }
              }
            }
          });
        }
        
        // Create the data arrays in the correct order
        labels.forEach(function(monthYear) {
          completedData.push(monthlyData[monthYear].completed);
          incompleteData.push(monthlyData[monthYear].incomplete);
        });
        
        return {
          labels: labels,
          datasets: [
            {
              label: 'Completed',
              data: completedData
            },
            {
              label: 'Incomplete',
              data: incompleteData
            }
          ]
        };
      } catch (e) {
        Logger.log("Error in getOneOnOneChartData: " + e.toString());
        
        // Return placeholder data on error
        return {
          labels: ['Jan 2025', 'Feb 2025', 'Mar 2025', 'Apr 2025', 'May 2025', 'Jun 2025'],
          datasets: [
            {
              label: 'Completed',
              data: [4, 5, 3, 6, 4, 5]
            },
            {
              label: 'Incomplete',
              data: [1, 0, 2, 1, 3, 0]
            }
          ]
        };
      }
    },
    
    /**
     * Gets data for team composition chart
     * @return {Object} - Chart data object
     */
    getTeamCompositionChartData: function() {
      try {
        var roleData = {};
        var statusData = {};
        
        // Try to get team members
        if (typeof getTeamMembers === 'function') {
          var members = getTeamMembers();
          
          members.forEach(function(member) {
            // Role data
            var role = member.role || 'Other';
            roleData[role] = (roleData[role] || 0) + 1;
            
            // Status data
            var status = member.status || 'Unknown';
            statusData[status] = (statusData[status] || 0) + 1;
          });
        }
        
        return {
          role: {
            labels: Object.keys(roleData),
            data: Object.values(roleData)
          },
          status: {
            labels: Object.keys(statusData),
            data: Object.values(statusData)
          }
        };
      } catch (e) {
        Logger.log("Error in getTeamCompositionChartData: " + e.toString());
        
        // Return placeholder data on error
        return {
          role: {
            labels: ['Counselor', 'Lead', 'Manager', 'Specialist'],
            data: [8, 2, 1, 3]
          },
          status: {
            labels: ['Active', 'Training', 'PTO', 'Other'],
            data: [10, 2, 1, 1]
          }
        };
      }
    },
    
    /**
     * Gets data for quality review chart
     * @return {Object} - Chart data object
     */
    getQualityReviewChartData: function() {
      try {
        // This would integrate with a QAService if available
        
        // For now, return a placeholder
        return {
          labels: ['Calls', 'Emails', 'Chat'],
          datasets: [
            {
              label: 'Mean Score',
              data: [85, 92, 78]
            }
          ],
          criteria: {
            'Call Opening': 88,
            'Risk Assessment': 76,
            'Communication Skills': 92,
            'Support Effectiveness': 84,
            'Call Closure': 90
          }
        };
      } catch (e) {
        Logger.log("Error in getQualityReviewChartData: " + e.toString());
        return {
          labels: ['Calls', 'Emails', 'Chat'],
          datasets: [
            {
              label: 'Mean Score',
              data: [85, 92, 78]
            }
          ],
          criteria: {}
        };
      }
    },
    
    /**
     * Gets data for metrics chart
     * @return {Object} - Chart data object
     */
    getMetricsChartData: function() {
      try {
        // This would integrate with a MetricsService if available
        
        // For now, return a placeholder
        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
        
        return {
          labels: months,
          datasets: [
            {
              label: 'Call Volume',
              data: [120, 132, 101, 134, 90, 110]
            },
            {
              label: 'Avg Handle Time',
              data: [15, 13, 14, 12, 13, 11]
            }
          ]
        };
      } catch (e) {
        Logger.log("Error in getMetricsChartData: " + e.toString());
        return {
          labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
          datasets: [
            {
              label: 'Call Volume',
              data: [120, 132, 101, 134, 90, 110]
            },
            {
              label: 'Avg Handle Time',
              data: [15, 13, 14, 12, 13, 11]
            }
          ]
        };
      }
    },
    
    /**
     * Gets performance metrics data for the dashboard
     * @param {string} [period='week'] - Time period (week, month, quarter)
     * @return {Object} - Performance metrics data
     */
    getPerformanceMetrics: function(period) {
      try {
        // Replace with real metrics if available
        return {
          answerRate: "93%",
          talkTime: "14.2",
          onQueue: "65%",
          interacting: "81%",
          period: period || 'week'
        };
      } catch (e) {
        Logger.log("Error in getPerformanceMetrics: " + e.toString());
        return {
          answerRate: "93%",
          talkTime: "14.2",
          onQueue: "65%",
          interacting: "81%",
          period: period || 'week'
        };
      }
    },
    
    /**
     * Gets upcoming one-on-one sessions
     * @param {number} [limit=5] - Maximum number of sessions to return
     * @return {Array} - Array of upcoming sessions
     */
    getUpcomingSessions: function(limit) {
      try {
        var upcomingSessions = [];
        limit = limit || 5;
        
        // Try to get sessions if the function exists
        if (typeof getOneOnOneSessions === 'function') {
          var allSessions = getOneOnOneSessions();
          var now = new Date();
          
          // Filter for upcoming sessions
          upcomingSessions = allSessions.filter(function(session) {
            var sessionDate = new Date(session.date);
            return sessionDate > now && !session.complete;
          });
          
          // Sort by date (earliest first)
          upcomingSessions.sort(function(a, b) {
            return new Date(a.date) - new Date(b.date);
          });
          
          // Limit to specified number
          upcomingSessions = upcomingSessions.slice(0, limit);
          
          // Format for display
          upcomingSessions = upcomingSessions.map(function(session) {
            // Get team member name if we have the function
            var memberName = session.teamMember || '';
            var memberRole = '';
            
            if (typeof getTeamMemberNameFromEmail === 'function' && session.teamMember) {
              memberName = getTeamMemberNameFromEmail(session.teamMember);
            }
            
            // Need to determine the last session somehow
            var lastSession = 'None';
            
            return {
              id: session.id || '',
              memberName: memberName,
              memberRole: memberRole,
              dateTime: formatDate ? formatDate(session.date, 'datetime') : new Date(session.date).toLocaleString(),
              status: 'Scheduled',
              lastSession: lastSession
            };
          });
        }
        
        return upcomingSessions;
      } catch (e) {
        Logger.log("Error in getUpcomingSessions: " + e.toString());
        return [];
      }
    }
  };
})();

/**
 * Get the DashboardService instance
 * @return {Object} - DashboardService instance
 */
function getDashboardService() {
  return DashboardService;
}

/**
 * Gets performance metrics data for the dashboard
 * @param {string} period - Time period (week, month, quarter)
 * @return {Object} - Performance metrics data
 */
function getPerformanceMetrics(period) {
  return getDashboardService().getPerformanceMetrics(period);
}

/**
 * Gets team member cards for the dashboard
 * @return {Array} - Array of team member cards
 */
function getTeamMemberCards() {
  try {
    var teamMembers = [];
    
    // Get team members if the function exists
    if (typeof getTeamMembers === 'function') {
      var allMembers = getTeamMembers();
      
      teamMembers = allMembers.map(function(member) {
        // For each member, determine if they need a session
        var needsSession = true;
        var lastOneOnOne = 'Never';
        
        // Try to find their last one-on-one if the function exists
        if (typeof getOneOnOneSessions === 'function') {
          var sessions = getOneOnOneSessions({
            teamMember: member.email
          });
          
          if (sessions && sessions.length > 0) {
            // Sort by date descending
            sessions.sort(function(a, b) {
              return new Date(b.date) - new Date(a.date);
            });
            
            var lastSession = sessions[0];
            
            if (lastSession) {
              lastOneOnOne = formatDate ? formatDate(lastSession.date, 'short') : new Date(lastSession.date).toLocaleDateString();
              
              // Determine if they need a session (more than 14 days ago)
              var daysSinceLastSession = (new Date() - new Date(lastSession.date)) / (1000 * 60 * 60 * 24);
              needsSession = daysSinceLastSession > 14;
            }
          }
        }
        
        return {
          name: (member.firstName || '') + ' ' + (member.lastName || ''),
          email: member.email,
          role: member.role || 'Team Member',
          status: member.status || 'Active',
          lastOneOnOne: lastOneOnOne,
          needsSession: needsSession
        };
      });
    }
    
    return teamMembers;
  } catch (e) {
    Logger.log("Error in getTeamMemberCards: " + e.toString());
    return [];
  }
}

/**
 * Gets action items for the dashboard
 * @return {Object} - Action items categorized by status
 */
function getDashboardActionItems() {
  try {
    var overdueItems = [];
    var upcomingItems = [];
    var recentItems = [];
    var now = new Date();
    
    // Get action items if the function exists
    if (typeof getActionItems === 'function') {
      var allItems = getActionItems();
      
      allItems.forEach(function(item) {
        if (item.status === 'Completed' && item.completedDate) {
          // Check if completed recently (within 7 days)
          var completedDate = new Date(item.completedDate);
          if ((now - completedDate) / (1000 * 60 * 60 * 24) <= 7) {
            recentItems.push(item);
          }
        } else if (item.dueDate) {
          var dueDate = new Date(item.dueDate);
          if (dueDate < now) {
            overdueItems.push(item);
          } else if ((dueDate - now) / (1000 * 60 * 60 * 24) <= 7) {
            upcomingItems.push(item);
          }
        }
      });
    }
    
    // Format the items for display
    var formatItems = function(items) {
      return items.map(function(item) {
        // Calculate relative due time
        var relativeDue = 'No date';
        if (item.dueDate) {
          var dueDate = new Date(item.dueDate);
          var diffDays = Math.round((dueDate - now) / (1000 * 60 * 60 * 24));
          
          if (diffDays < 0) {
            relativeDue = Math.abs(diffDays) + (Math.abs(diffDays) === 1 ? ' day ago' : ' days ago');
          } else if (diffDays === 0) {
            relativeDue = 'Today';
          } else if (diffDays === 1) {
            relativeDue = 'Tomorrow';
          } else {
            relativeDue = 'In ' + diffDays + ' days';
          }
        }
        
        return {
          id: item.id || '',
          description: item.description || 'Untitled item',
          owner: item.owner || 'Unassigned',
          dueDate: item.dueDate ? (formatDate ? formatDate(item.dueDate, 'short') : new Date(item.dueDate).toLocaleDateString()) : 'No date',
          relativeDue: relativeDue,
          status: item.status || 'Open',
          source: item.source || 'Manual entry',
          completedDate: item.completedDate ? (formatDate ? formatDate(item.completedDate, 'short') : new Date(item.completedDate).toLocaleDateString()) : null
        };
      });
    };
    
    return {
      overdue: formatItems(overdueItems),
      upcoming: formatItems(upcomingItems),
      recent: formatItems(recentItems)
    };
  } catch (e) {
    Logger.log("Error in getDashboardActionItems: " + e.toString());
    return {
      overdue: [],
      upcoming: [],
      recent: []
    };
  }
}

/**
 * Gets notifications for the dashboard
 * @return {Array} - Array of notification objects
 */
function getNotifications() {
  try {
    var notifications = [];
    var now = new Date();
    
    // Example logic for generating notifications
    // Replace with real logic that integrates with your services
    
    // Check for overdue one-on-ones
    if (typeof getOneOnOneSessions === 'function') {
      var sessions = getOneOnOneSessions();
      var overdueCount = 0;
      
      sessions.forEach(function(session) {
        if (!session.complete && new Date(session.date) < now) {
          overdueCount++;
        }
      });
      
      if (overdueCount > 0) {
        notifications.push({
          title: 'Overdue One-on-Ones',
          message: 'You have ' + overdueCount + ' overdue one-on-one sessions.',
          time: formatDate ? formatDate(now, 'datetime') : now.toLocaleString(),
          type: 'warning'
        });
      }
    }
    
    // Check for action items
    if (typeof getActionItems === 'function') {
      var items = getActionItems();
      var overdueCount = 0;
      var dueSoonCount = 0;
      
      items.forEach(function(item) {
        if (item.status !== 'Completed' && item.dueDate) {
          var dueDate = new Date(item.dueDate);
          var diffDays = Math.round((dueDate - now) / (1000 * 60 * 60 * 24));
          
          if (diffDays < 0) {
            overdueCount++;
          } else if (diffDays <= 2) {
            dueSoonCount++;
          }
        }
      });
      
      if (overdueCount > 0) {
        notifications.push({
          title: 'Overdue Action Items',
          message: 'You have ' + overdueCount + ' overdue action items.',
          time: formatDate ? formatDate(now, 'datetime') : now.toLocaleString(),
          type: 'danger'
        });
      }
      
      if (dueSoonCount > 0) {
        notifications.push({
          title: 'Action Items Due Soon',
          message: 'You have ' + dueSoonCount + ' action items due in the next 2 days.',
          time: formatDate ? formatDate(now, 'datetime') : now.toLocaleString(),
          type: 'warning'
        });
      }
    }
    
    return notifications;
  } catch (e) {
    Logger.log("Error in getNotifications: " + e.toString());
    return [];
  }
}

/**
 * Gets user info for display
 * @return {Object} - User information
 */
function getCurrentUserInfo() {
  try {
    var email = Session.getActiveUser().getEmail();
    var name = email.split('@')[0]; // Default to username part of email
    return {
      email: email,
      name: name,
      lastLogin: new Date().toLocaleString()
    };
  } catch (e) {
    Logger.log("Error in getCurrentUserInfo: " + e.toString());
    return {
      email: Session.getActiveUser().getEmail(),
      name: Session.getActiveUser().getEmail(),
      lastLogin: new Date().toLocaleString()
    };
  }
}

/**
 * Mark all notifications as read
 * @return {boolean} - Success status
 */
function markAllNotificationsAsRead() {
  // Placeholder function
  return true;
}

/**
 * Gets dashboard data by date
 * @param {string} dateString - Date in ISO format
 * @return {Object} - Dashboard data filtered by date
 */
function getDashboardDataByDate(dateString) {
  try {
    var dashboardService = getDashboardService();
    
    return {
      summary: dashboardService.getDashboardSummary(),
      oneOnOneChartData: dashboardService.getOneOnOneChartData(),
      teamCompositionData: dashboardService.getTeamCompositionChartData(),
      qaChartData: dashboardService.getQualityReviewChartData(),
      metricsChartData: dashboardService.getMetricsChartData(),
      performanceMetrics: dashboardService.getPerformanceMetrics('week'),
      upcomingSessions: dashboardService.getUpcomingSessions(10)
    };
  } catch (e) {
    Logger.log("Error in getDashboardDataByDate: " + e.toString());
    return getDashboardData(); // Fall back to regular dashboard data
  }
}


/**
 * EmailService.gs - Advanced email service with modern visual UI
 */

var EmailService = (function() {
  // FontAwesome CSS for icons (CDN version for email compatibility)
  var FONT_AWESOME_CSS = '<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">';
  
  /**
   * Modern email container template for all emails
   * @param {Object} data - Email content data
   * @return {String} - Complete HTML email
   */
  function createEmailContainer(data) {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>${data.subject || 'Team Dashboard Notification'}</title>
        ${FONT_AWESOME_CSS}
        <style>
          @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap');
          
          :root {
            --primary: #4e73df;
            --primary-dark: #2e59d9;
            --primary-light: #6f8be8;
            --secondary: #858796;
            --success: #1cc88a;
            --info: #36b9cc;
            --warning: #f6c23e;
            --danger: #e74a3b;
            --light: #f8f9fc;
            --dark: #5a5c69;
            --gray-100: #f8f9fc;
            --gray-200: #eaecf4;
            --gray-300: #dddfeb;
            --gray-400: #d1d3e2;
            --gray-500: #b7b9cc;
            --gray-600: #858796;
            --gray-700: #6e707e;
            --gray-800: #5a5c69;
            --gray-900: #3a3b45;
          }
          
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }
          
          body {
            font-family: 'Inter', 'Segoe UI', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--gray-800);
            background-color: #f0f2f8;
            margin: 0;
            padding: 0;
          }
          
          .email-container {
            max-width: 680px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
          }
          
          .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            padding: 30px 40px;
            color: white;
            position: relative;
            overflow: hidden;
          }
          
          .header::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 80%;
            height: 100%;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            transform: skewX(-45deg) translateX(50%);
          }
          
          .icon-circle {
            position: absolute;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 2;
          }
          
          .header-title {
            font-family: 'Poppins', sans-serif;
            margin: 0 0 5px 0;
            font-size: 24px;
            font-weight: 600;
          }
          
          .header-subtitle {
            font-size: 15px;
            font-weight: 400;
            opacity: 0.85;
          }
          
          .metadata {
            background-color: rgba(0, 0, 0, 0.05);
            display: inline-block;
            padding: 5px 12px;
            border-radius: 30px;
            font-size: 12px;
            margin-top: 10px;
          }
          
          .content {
            padding: 40px;
          }
          
          .greeting {
            font-family: 'Poppins', sans-serif;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 20px;
            color: var(--gray-900);
          }
          
          .message {
            margin-bottom: 30px;
            color: var(--gray-700);
          }
          
          .section {
            background-color: var(--gray-100);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 4px solid var(--primary);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.03);
          }
          
          .section.status { border-color: var(--info); }
          .section.performance { border-color: var(--primary); }
          .section.development { border-color: var(--warning); }
          .section.support { border-color: var(--success); }
          
          .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
          }
          
          .section-icon {
            width: 32px;
            height: 32px;
            background-color: var(--primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            margin-right: 12px;
            flex-shrink: 0;
          }
          
          .section.status .section-icon { background-color: var(--info); }
          .section.performance .section-icon { background-color: var(--primary); }
          .section.development .section-icon { background-color: var(--warning); }
          .section.support .section-icon { background-color: var(--success); }
          
          .section-title {
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: var(--gray-800);
            margin: 0;
          }
          
          .section-content {
            color: var(--gray-700);
            font-size: 14px;
            line-height: 1.8;
          }
          
          .section-content p:last-child {
            margin-bottom: 0;
          }
          
          /* Action items design */
          .action-items {
            margin-bottom: 25px;
          }
          
          .action-items-header {
            background-color: var(--primary);
            color: white;
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            display: flex;
            align-items: center;
          }
          
          .action-items-header i {
            margin-right: 10px;
          }
          
          .action-items-list {
            background-color: var(--gray-100);
            border-radius: 0 0 10px 10px;
            padding: 15px 20px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.03);
          }
          
          .action-item {
            background-color: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.03);
            transition: transform 0.2s ease;
          }
          
          .action-item:last-child {
            margin-bottom: 0;
          }
          
          .action-item:hover {
            transform: translateY(-2px);
          }
          
          .action-item-number {
            background-color: var(--primary);
            color: white;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            margin-right: 12px;
            flex-shrink: 0;
          }
          
          .action-item-content {
            flex: 1;
            font-size: 14px;
          }
          
          .action-item-meta {
            display: flex;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
          }
          
          .due-date {
            display: inline-flex;
            align-items: center;
            background-color: var(--gray-100);
            color: var(--gray-700);
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 10px;
            margin-top: 5px;
          }
          
          .due-date i {
            margin-right: 5px;
            color: var(--primary);
          }
          
          .priority {
            display: inline-flex;
            align-items: center;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 4px;
            margin-top: 5px;
          }
          
          .priority.high {
            background-color: #feeced;
            color: var(--danger);
          }
          
          .priority.medium {
            background-color: #fff5e6;
            color: var(--warning);
          }
          
          .priority.low {
            background-color: #e6f7f0;
            color: var(--success);
          }
          
          .priority i {
            margin-right: 5px;
          }
          
          /* Follow-up box */
          .follow-up-box {
            display: flex;
            align-items: center;
            background-color: #e8f2ff;
            border-radius: 10px;
            padding: 20px;
            margin: 25px 0;
          }
          
          .follow-up-icon {
            background-color: #4285f4;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
          }
          
          .follow-up-content {
            flex: 1;
          }
          
          .follow-up-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 3px;
          }
          
          .follow-up-date {
            font-size: 14px;
            color: var(--gray-700);
          }
          
          /* Stats design */
          .stats-row {
            display: flex;
            flex-wrap: wrap;
            margin: 0 -10px 20px -10px;
          }
          
          .stat-card {
            flex: 1;
            min-width: calc(50% - 20px);
            margin: 0 10px 20px 10px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
          }
          
          .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
          }
          
          .stat-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 14px;
            color: var(--gray-600);
          }
          
          .stat-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
          }
          
          .stat-icon.primary { background-color: var(--primary); }
          .stat-icon.success { background-color: var(--success); }
          .stat-icon.info { background-color: var(--info); }
          .stat-icon.warning { background-color: var(--warning); }
          .stat-icon.danger { background-color: var(--danger); }
          
          .stat-value {
            font-family: 'Poppins', sans-serif;
            font-size: 28px;
            font-weight: 600;
            color: var(--gray-800);
          }
          
          .stat-desc {
            font-size: 13px;
            color: var(--gray-600);
          }
          
          /* Progress bar */
          .progress-container {
            width: 100%;
            background-color: var(--gray-200);
            border-radius: 10px;
            height: 8px;
            margin: 10px 0;
            overflow: hidden;
          }
          
          .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            border-radius: 10px;
          }
          
          .progress-bar.success {
            background: linear-gradient(90deg, var(--success) 0%, #20e3a2 100%);
          }
          
          .progress-bar.warning {
            background: linear-gradient(90deg, var(--warning) 0%, #ffd66e 100%);
          }
          
          .progress-bar.danger {
            background: linear-gradient(90deg, var(--danger) 0%, #ff6b5b 100%);
          }
          
          /* Team members list */
          .team-members {
            margin-bottom: 20px;
          }
          
          .team-member {
            display: flex;
            align-items: center;
            background-color: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.03);
          }
          
          .team-member:last-child {
            margin-bottom: 0;
          }
          
          .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 15px;
            font-size: 14px;
          }
          
          .member-info {
            flex: 1;
          }
          
          .member-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 3px;
          }
          
          .member-email {
            font-size: 12px;
            color: var(--gray-600);
          }
          
          /* Button styles */
          .button-container {
            margin: 25px 0;
            text-align: center;
          }
          
          .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: var(--primary);
            color: white !important;
            text-decoration: none;
            border-radius: 6px;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            cursor: pointer;
          }
          
          .button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 115, 223, 0.2);
          }
          
          .button i {
            margin-right: 8px;
          }
          
          /* Footer sections */
          .signature {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--gray-200);
          }
          
          .signature-name {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 15px;
            color: var(--gray-800);
          }
          
          .signature-title {
            color: var(--gray-600);
            font-size: 13px;
            margin-top: 3px;
          }
          
          .footer {
            background-color: var(--gray-100);
            padding: 20px 40px;
            text-align: center;
            font-size: 12px;
            color: var(--gray-600);
            border-top: 1px solid var(--gray-200);
          }
          
          /* Animation effects */
          @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }
          
          @keyframes slideUp {
            from { 
              opacity: 0;
              transform: translateY(15px);
            }
            to { 
              opacity: 1;
              transform: translateY(0);
            }
          }
          
          .animate-fade {
            animation: fadeIn 0.5s ease-in-out;
          }
          
          .animate-slide-up {
            animation: slideUp 0.5s ease-out;
          }
          
          /* Responsive styles */
          @media only screen and (max-width: 640px) {
            .header, .content {
              padding: 25px;
            }
            
            .footer {
              padding: 15px 25px;
            }
            
            .stat-card {
              min-width: 100%;
            }
            
            .action-item {
              flex-direction: column;
            }
            
            .action-item-number {
              margin-bottom: 10px;
            }
            
            .stats-row {
              flex-direction: column;
            }
            
            .greeting {
              font-size: 16px;
            }
            
            .header-title {
              font-size: 20px;
            }
            
            .icon-circle {
              width: 50px;
              height: 50px;
              font-size: 20px;
            }
          }
        </style>
      </head>
      <body>
        <div class="email-container">
          <div class="header">
            <h1 class="header-title">${data.title}</h1>
            <div class="header-subtitle">${data.subtitle}</div>
            ${data.metadata ? `<div class="metadata">${data.metadata}</div>` : ''}
            <div class="icon-circle">
              <i class="${data.icon}"></i>
            </div>
          </div>
          
          <div class="content">
            ${data.content}
            
            ${data.signature}
          </div>
          
          <div class="footer">
            ${data.footer || 'This email was sent from the Team Dashboard system. Current time: ' + getCurrentDateTime()}
          </div>
        </div>
      </body>
      </html>
    `;
  }
  
  /**
   * Create a plain text version of a one-on-one follow-up email
   * @param {Object} sessionData - Session data
   * @param {String} recipientName - Recipient name
   * @param {Object} currentUser - Current user info
   * @param {String} sessionDate - Formatted session date
   * @return {String} - Plain text email content
   */
  function createPlainTextVersion(sessionData, recipientName, currentUser, sessionDate) {
    let plainText = `Hello ${recipientName},

Thank you for our one-on-one meeting on ${sessionDate}. Here's a summary of what we discussed:

`;
    
    if (sessionData.statusNotes) {
      plainText += `== STATUS UPDATE ==
${sessionData.statusNotes}

`;
    }
    
    if (sessionData.performanceNotes) {
      plainText += `== PERFORMANCE DISCUSSION ==
${sessionData.performanceNotes}

`;
    }
    
    if (sessionData.developmentNotes) {
      plainText += `== DEVELOPMENT AREAS ==
${sessionData.developmentNotes}

`;
    }
    
    if (sessionData.supportNotes) {
      plainText += `== SUPPORT NEEDED ==
${sessionData.supportNotes}

`;
    }
    
    // Add action items
    if (sessionData.actionItems && sessionData.actionItems.length > 0) {
      plainText += `== ACTION ITEMS ==
`;
      sessionData.actionItems.forEach(function(item, index) {
        var itemText = typeof item === 'object' ? (item.description || '') : item;
        var dueDate = '';
        var priority = '';
        
        if (typeof item === 'object') {
          if (item.dueDate) {
            dueDate = ` (Due: ${formatDateSafely(item.dueDate, 'MMMM dd, yyyy')})`;
          }
          
          if (item.priority) {
            priority = ` [${item.priority.toUpperCase()} Priority]`;
          }
        }
        
        plainText += `${index + 1}. ${itemText}${dueDate}${priority}
`;
      });
      plainText += `
`;
    }
    
    if (sessionData.followUpDate) {
      plainText += `NEXT ONE-ON-ONE: Scheduled for ${formatDateSafely(sessionData.followUpDate, 'MMMM dd, yyyy')}

`;
    }
    
    plainText += `If you have any questions or need further clarification on anything we discussed, please don't hesitate to reach out.

Best regards,
${currentUser.name}
${currentUser.role}`;
    
    return plainText;
  }
  
  /**
   * Get current user's info in a safe way
   * @return {Object} - User info with safe defaults
   */
  function getSafeUserInfo() {
    try {
      var configService = getConfigService();
      var email = Session.getActiveUser().getEmail();
      var userInfo = configService.getUserInfoByEmail(email) || {};
      
      return {
        email: email || '',
        name: userInfo.name || email || 'Team Lead',
        role: userInfo.role || 'Manager'
      };
    } catch(e) {
      Logger.log('Error getting user info: ' + e.toString());
      return {
        email: '',
        name: 'Team Lead',
        role: 'Manager'
      };
    }
  }
  
  /**
   * Format a date safely
   * @param {Date|String} date - Date to format
   * @param {String} format - Format to use
   * @return {String} - Formatted date or empty string
   */
  function formatDateSafely(date, format) {
    try {
      if (!date) return '';
      return Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), format || 'MMMM dd, yyyy');
    } catch(e) {
      Logger.log('Error formatting date: ' + e.toString());
      return '';
    }
  }
  
  /**
   * Current formatted date time in the requested format
   * @return {String} - Current formatted date time
   */
  function getCurrentDateTime() {
    try {
      return Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
    } catch(e) {
      return new Date().toISOString().replace('T', ' ').split('.')[0];
    }
  }
  
  /**
   * Extract name from email in a safe way
   * @param {String} email - Email address
   * @return {String} - Name or first part of email
   */
  function getNameFromEmail(email) {
    if (!email) return 'Team Member';
    
    try {
      // Try to find user in team members
      var teamService = getTeamService();
      var member = teamService.getTeamMemberByEmail(email);
      
      if (member && (member.firstName || member.lastName)) {
        return (member.firstName || '') + ' ' + (member.lastName || '');
      }
      
      // Fall back to email username with capitalization
      var username = email.split('@')[0];
      return username.charAt(0).toUpperCase() + username.slice(1);
    } catch(e) {
      // Safe fallback
      return email.split('@')[0] || 'Team Member';
    }
  }
  
  /**
   * Get initials from a name
   * @param {String} name - Full name
   * @return {String} - Initials (1-2 characters)
   */
  function getInitials(name) {
    if (!name) return '?';
    
    var parts = name.split(' ');
    if (parts.length === 1) {
      return name.charAt(0).toUpperCase();
    }
    
    return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();
  }
  
  /**
   * Generate priority badge HTML
   * @param {String} priority - Priority level (high, medium, low)
   * @return {String} - HTML for priority badge
   */
  function getPriorityBadge(priority) {
    var icon, text;
    
    switch(priority?.toLowerCase()) {
      case 'high':
        icon = 'fas fa-arrow-up';
        text = 'High Priority';
        break;
      case 'medium':
        icon = 'fas fa-minus';
        text = 'Medium Priority';
        break;
      case 'low':
        icon = 'fas fa-arrow-down';
        text = 'Low Priority';
        break;
      default:
        return '';
    }
    
    return `<span class="priority ${priority.toLowerCase()}"><i class="${icon}"></i>${text}</span>`;
  }
  
  /**
   * Sends a one-on-one follow-up email with beautiful styling
   * @param {Object} sessionData - Session data
   * @return {Boolean} - True if successful
   */
  function sendOneOnOneFollowUp(sessionData) {
  if (!sessionData || !sessionData.teamMember) {
    throw new Error('Invalid session data');
  }
  
  // Get recipient info
  var recipientEmail = sessionData.teamMember;
  var recipientName = getNameFromEmail(recipientEmail);
  
  // Get current user info
  var currentUser = getSafeUserInfo();
  
  // Create email subject
  var subject = 'One-on-One Session Summary';
  
  // Format dates for display
  var sessionDate = formatDateSafely(sessionData.date);
  
  // Start building HTML content
  var htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>One-on-One Summary</title>
      <style>
        body {
          font-family: 'Segoe UI', Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          background-color: #f9f9f9;
          margin: 0;
          padding: 0;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background: #ffffff;
          border-radius: 8px;
          overflow: hidden;
          box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        .header {
          background: linear-gradient(135deg, #4e73df 0%, #2e59d9 100%);
          padding: 30px;
          text-align: center;
          color: white;
        }
        .header h1 {
          margin: 0 0 5px 0;
          font-size: 24px;
          font-weight: 600;
        }
        .header p {
          margin: 0;
          font-size: 15px;
          opacity: 0.9;
        }
        .content {
          padding: 30px;
        }
        .greeting {
          font-size: 18px;
          font-weight: 500;
          margin-bottom: 20px;
        }
        .section {
          margin-bottom: 25px;
          padding: 20px;
          background-color: #f8f9fc;
          border-radius: 8px;
          border-left: 4px solid #4e73df;
        }
        .section-header {
          display: flex;
          align-items: center;
          margin-bottom: 15px;
        }
        .section-icon {
          width: 36px;
          height: 36px;
          background-color: #4e73df;
          border-radius: 8px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          margin-right: 15px;
          font-size: 18px;
        }
        .section-title {
          font-size: 18px;
          font-weight: 600;
          margin: 0;
          color: #333;
        }
        .action-items {
          margin-top: 30px;
        }
        .action-items-header {
          background-color: #4e73df;
          color: white;
          padding: 15px 20px;
          border-radius: 8px 8px 0 0;
          font-weight: 600;
          font-size: 16px;
        }
        .action-items-list {
          background-color: #f8f9fc;
          padding: 15px 20px;
          border-radius: 0 0 8px 8px;
        }
        .action-item {
          display: flex;
          padding: 12px 15px;
          background: white;
          border-radius: 6px;
          margin-bottom: 10px;
        }
        .action-item-number {
          background-color: #4e73df;
          color: white;
          width: 24px;
          height: 24px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: 600;
          margin-right: 12px;
          flex-shrink: 0;
        }
        .action-item-content {
          flex: 1;
        }
        .action-item-meta {
          margin-top: 5px;
          display: flex;
          flex-wrap: wrap;
          font-size: 12px;
          color: #858796;
        }
        .due-date {
          margin-right: 10px;
          background-color: #e8f2ff;
          padding: 3px 8px;
          border-radius: 12px;
        }
        .priority {
          padding: 3px 8px;
          border-radius: 12px;
          font-weight: 500;
        }
        .priority.high {
          background-color: #feeced;
          color: #e74a3b;
        }
        .priority.medium {
          background-color: #fff5e6;
          color: #f6c23e;
        }
        .priority.low {
          background-color: #e6f7f0;
          color: #1cc88a;
        }
        .follow-up-box {
          display: flex;
          align-items: center;
          background-color: #e8f2ff;
          border-radius: 8px;
          padding: 20px;
          margin: 30px 0;
        }
        .follow-up-icon {
          background-color: #4285f4;
          color: white;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 15px;
          font-size: 20px;
        }
        .follow-up-content {
          flex: 1;
        }
        .follow-up-title {
          font-weight: 600;
          margin-bottom: 5px;
        }
        .button-container {
          margin-top: 30px;
          text-align: center;
        }
        .button {
          display: inline-block;
          background-color: #4e73df;
          color: white;
          padding: 12px 25px;
          text-decoration: none;
          border-radius: 6px;
          font-weight: 600;
          text-align: center;
        }
        .signature {
          margin-top: 40px;
          padding-top: 20px;
          border-top: 1px solid #eaecf4;
        }
        .signature-name {
          font-weight: 600;
          font-size: 15px;
          color: #5a5c69;
        }
        .signature-title {
          color: #858796;
          font-size: 13px;
          margin-top: 3px;
        }
        .footer {
          text-align: center;
          padding: 20px;
          color: #858796;
          font-size: 12px;
          background-color: #f8f9fc;
          border-top: 1px solid #eaecf4;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>One-on-One Session Summary</h1>
          <p>Meeting Notes & Action Items</p>
          <div style="margin-top: 10px; font-size: 12px; background: rgba(0,0,0,0.1); display: inline-block; padding: 5px 12px; border-radius: 30px;">
            ${sessionDate}
          </div>
        </div>
        
        <div class="content">
          <div class="greeting">Hello ${recipientName},</div>
          
          <div style="margin-bottom: 30px;">
            Thank you for our one-on-one meeting. I've summarized our discussion below for your reference.
          </div>
  `;
  
  // Add status notes section
  if (sessionData.statusNotes) {
    htmlContent += `
      <div class="section">
        <div class="section-header">
          <div class="section-icon">📊</div>
          <h3 class="section-title">Status Update</h3>
        </div>
        <div>${sessionData.statusNotes.replace(/\n/g, '<br>')}</div>
      </div>
    `;
  }
  
  // Add performance notes section
  if (sessionData.performanceNotes) {
    htmlContent += `
      <div class="section">
        <div class="section-header">
          <div class="section-icon">⭐</div>
          <h3 class="section-title">Performance Discussion</h3>
        </div>
        <div>${sessionData.performanceNotes.replace(/\n/g, '<br>')}</div>
      </div>
    `;
  }
  
  // Add development notes section
  if (sessionData.developmentNotes) {
    htmlContent += `
      <div class="section">
        <div class="section-header">
          <div class="section-icon">🎓</div>
          <h3 class="section-title">Development Areas</h3>
        </div>
        <div>${sessionData.developmentNotes.replace(/\n/g, '<br>')}</div>
      </div>
    `;
  }
  
  // Add support notes section
  if (sessionData.supportNotes) {
    htmlContent += `
      <div class="section">
        <div class="section-header">
          <div class="section-icon">🤝</div>
          <h3 class="section-title">Support Needed</h3>
        </div>
        <div>${sessionData.supportNotes.replace(/\n/g, '<br>')}</div>
      </div>
    `;
  }
  
  // Add action items section
  if (sessionData.actionItems && sessionData.actionItems.length > 0) {
    let actionItemsHtml = '';
    
    sessionData.actionItems.forEach(function(item, index) {
      let itemText = typeof item === 'object' ? (item.description || '') : item;
      let dueDate = '';
      let priority = '';
      
      if (typeof item === 'object') {
        if (item.dueDate) {
          dueDate = formatDateSafely(item.dueDate);
        }
        
        if (item.priority) {
          const priorityClass = item.priority.toLowerCase();
          priority = `<span class="priority ${priorityClass}">${item.priority} Priority</span>`;
        }
      }
      
      actionItemsHtml += `
        <div class="action-item">
          <div class="action-item-number">${index + 1}</div>
          <div class="action-item-content">
            ${itemText}
            <div class="action-item-meta">
              ${dueDate ? `<span class="due-date">📅 ${dueDate}</span>` : ''}
              ${priority}
            </div>
          </div>
        </div>
      `;
    });
    
    htmlContent += `
      <div class="action-items">
        <div class="action-items-header">
          <i class="fas fa-tasks"></i> Action Items
        </div>
        <div class="action-items-list">
          ${actionItemsHtml}
        </div>
      </div>
    `;
  }
  
  // Add follow-up session info
  if (sessionData.followUpDate) {
    const followUpDateFormatted = formatDateSafely(sessionData.followUpDate);
    
    htmlContent += `
      <div class="follow-up-box">
        <div class="follow-up-icon">📅</div>
        <div class="follow-up-content">
          <div class="follow-up-title">Next One-on-One Session</div>
          <div class="follow-up-date">Scheduled for ${followUpDateFormatted}</div>
        </div>
      </div>
    `;
  }
  
  // Add button to access dashboard
  htmlContent += `
    <div class="button-container">
      <a href="#" class="button">
        View Complete History
      </a>
    </div>
  `;
  
  // Add signature and footer
  htmlContent += `
          <div class="signature">
            <div class="signature-name">Best regards,</div>
            <div class="signature-name">${currentUser.name}</div>
            <div class="signature-title">${currentUser.role}</div>
          </div>
        </div>
        
        <div class="footer">
          This email was sent from the Team Dashboard on ${getCurrentDateTime()}
        </div>
      </div>
    </body>
    </html>
  `;
  
  // Create plain text version
  var plainTextBody = `One-on-One Session Summary
Meeting Notes & Action Items
${sessionDate}

Hello ${recipientName},

Thank you for our one-on-one meeting. I've summarized our discussion below for your reference.

${sessionData.statusNotes ? `STATUS UPDATE:
${sessionData.statusNotes}

` : ''}${sessionData.performanceNotes ? `PERFORMANCE DISCUSSION:
${sessionData.performanceNotes}

` : ''}${sessionData.developmentNotes ? `DEVELOPMENT AREAS:
${sessionData.developmentNotes}

` : ''}${sessionData.supportNotes ? `SUPPORT NEEDED:
${sessionData.supportNotes}

` : ''}`;

  // Add action items to plain text
  if (sessionData.actionItems && sessionData.actionItems.length > 0) {
    plainTextBody += `ACTION ITEMS:\n`;
    
    sessionData.actionItems.forEach(function(item, index) {
      let itemText = typeof item === 'object' ? (item.description || '') : item;
      let dueDate = '';
      let priority = '';
      
      if (typeof item === 'object') {
        if (item.dueDate) {
          dueDate = formatDateSafely(item.dueDate);
        }
        
        if (item.priority) {
          priority = `${item.priority} Priority`;
        }
      }
      
      plainTextBody += `${index + 1}. ${itemText}\n`;
      if (dueDate) plainTextBody += `   Due: ${dueDate}\n`;
      if (priority) plainTextBody += `   Priority: ${priority}\n`;
      plainTextBody += `\n`;
    });
  }

  // Add follow-up and signature to plain text
  if (sessionData.followUpDate) {
    const followUpDateFormatted = formatDateSafely(sessionData.followUpDate);
    plainTextBody += `NEXT ONE-ON-ONE SESSION:
Scheduled for ${followUpDateFormatted}\n\n`;
  }
  
  plainTextBody += `Best regards,
${currentUser.name}
${currentUser.role}

This email was sent from the Team Dashboard on ${getCurrentDateTime()}`;
  
  // Send the email
  try {
    GmailApp.sendEmail(recipientEmail, subject, plainTextBody, {
      htmlBody: htmlContent,
      name: currentUser.name
    });
    
    return true;
  } catch (e) {
    Logger.log('Failed to send email: ' + e.toString());
    return false;
  }
}
  
  /**
   * Sends a reminder for upcoming action items with enhanced styling
   * @param {Object} actionItem - Action item data
   * @return {Boolean} - True if successful
   */
  function sendActionItemReminder(actionItem) {
    if (!actionItem || !actionItem.owner) {
      throw new Error('Invalid action item data');
    }
    
    // Get recipient info safely
    var recipientEmail = actionItem.owner;
    var recipientName = getNameFromEmail(recipientEmail);
    
    // Get current user info
    var currentUser = getSafeUserInfo();
    
    // Create email subject
    var subject = 'Reminder: Action Item Due Soon';
    
    // Format due date
    var dueDateFormatted = formatDateSafely(actionItem.dueDate, 'MMMM dd, yyyy');
    var daysUntilDue = '';
    
    // Calculate days until due
    if (actionItem.dueDate) {
      try {
        var dueDate = new Date(actionItem.dueDate);
        var today = new Date();
        today.setHours(0, 0, 0, 0);
        var diffTime = dueDate - today;
        var diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 0) {
          daysUntilDue = 'Due today';
        } else if (diffDays === 1) {
          daysUntilDue = 'Due tomorrow';
        } else if (diffDays > 1) {
          daysUntilDue = `Due in ${diffDays} days`;
        } else {
          daysUntilDue = `Overdue by ${Math.abs(diffDays)} days`;
        }
      } catch (e) {
        // Silently fail, we'll just not show the days count
      }
    }
    
    // Create content
    var content = `
      <div class="greeting">Hello ${recipientName},</div>
      
      <div class="message">
        This is a friendly reminder that you have an action item that will be due soon.
      </div>
      
      <div class="section">
        <div class="section-header">
          <div class="section-icon">
            <i class="fas fa-tasks"></i>
          </div>
          <h3 class="section-title">Action Item Details</h3>
        </div>
        <div class="section-content">
          <p><strong>${actionItem.description}</strong></p>
          
          ${actionItem.notes ? `<p><strong>Notes:</strong> ${actionItem.notes.replace(/\n/g, '<br>')}</p>` : ''}
          
          <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
            ${dueDateFormatted ? `
              <div style="background: #e8f2ff; padding: 8px 15px; border-radius: 6px; display: flex; align-items: center;">
                <i class="far fa-calendar" style="color: #4285f4; margin-right: 8px;"></i>
                <div>
                  <div style="font-size: 12px; color: #4285f4;">Due Date</div>
                  <div style="font-weight: 600;">${dueDateFormatted}</div>
                </div>
              </div>
            ` : ''}
            
            ${daysUntilDue ? `
              <div style="background: ${daysUntilDue.includes('Overdue') ? '#feeced' : '#e6f7f0'}; padding: 8px 15px; border-radius: 6px; display: flex; align-items: center;">
                <i class="fas ${daysUntilDue.includes('Overdue') ? 'fa-exclamation-circle' : 'fa-clock'}" style="color: ${daysUntilDue.includes('Overdue') ? '#e74a3b' : '#1cc88a'}; margin-right: 8px;"></i>
                <div>
                  <div style="font-size: 12px; color: ${daysUntilDue.includes('Overdue') ? '#e74a3b' : '#1cc88a'};">Status</div>
                  <div style="font-weight: 600;">${daysUntilDue}</div>
                </div>
              </div>
            ` : ''}
            
            ${actionItem.priority ? `
              <div style="background: ${
                actionItem.priority.toLowerCase() === 'high' ? '#feeced' : 
                actionItem.priority.toLowerCase() === 'medium' ? '#fff5e6' : '#e6f7f0'
              }; padding: 8px 15px; border-radius: 6px; display: flex; align-items: center;">
                <i class="fas ${
                  actionItem.priority.toLowerCase() === 'high' ? 'fa-arrow-up' : 
                  actionItem.priority.toLowerCase() === 'medium' ? 'fa-minus' : 'fa-arrow-down'
                }" style="color: ${
                  actionItem.priority.toLowerCase() === 'high' ? '#e74a3b' : 
                  actionItem.priority.toLowerCase() === 'medium' ? '#f6c23e' : '#1cc88a'
                }; margin-right: 8px;"></i>
                <div>
                  <div style="font-size: 12px; color: ${
                    actionItem.priority.toLowerCase() === 'high' ? '#e74a3b' : 
                    actionItem.priority.toLowerCase() === 'medium' ? '#f6c23e' : '#1cc88a'
                  };">Priority</div>
                  <div style="font-weight: 600;">${actionItem.priority} Priority</div>
                </div>
              </div>
            ` : ''}
          </div>
        </div>
      </div>
      
      <div class="message">
        Please update the status of this item in the Team Dashboard when completed.
      </div>
      
      <div class="button-container">
        <a href="#" class="button">
          <i class="fas fa-check"></i> Mark as Complete
        </a>
      </div>
    `;
    
    // Create signature
    var signature = `
      <div class="signature">
        <div class="signature-name">Best regards,</div>
        <div class="signature-name">${currentUser.name}</div>
        <div class="signature-title">${currentUser.role}</div>
      </div>
    `;
    
    // Create data for email template
    var emailData = {
      title: 'Action Item Reminder',
      subtitle: 'Please complete this task',
      metadata: daysUntilDue || dueDateFormatted,
      icon: 'fas fa-bell',
      content: content,
      signature: signature,
      footer: `This email was sent from the Team Dashboard on ${getCurrentDateTime()}`
    };
    
    // Create HTML body
    var htmlBody = createEmailContainer(emailData);
    
    // Create plain text version
    var plainTextBody = `Hello ${recipientName},

This is a friendly reminder that you have an action item that will be due soon:

ACTION ITEM: ${actionItem.description}
${dueDateFormatted ? `DUE DATE: ${dueDateFormatted}` : ''}
${daysUntilDue ? `STATUS: ${daysUntilDue}` : ''}
${actionItem.priority ? `PRIORITY: ${actionItem.priority}` : ''}
${actionItem.notes ? `NOTES: ${actionItem.notes}` : ''}

Please update the status of this item in the Team Dashboard when completed.

Best regards,
${currentUser.name}
${currentUser.role}`;
    
    // Send the email
    try {
      GmailApp.sendEmail(recipientEmail, subject, plainTextBody, {
        htmlBody: htmlBody,
        name: currentUser.name
      });
      return true;
    } catch (e) {
      Logger.log('Failed to send email: ' + e.toString());
      return false;
    }
  }
  
  /**
   * Sends a weekly team status report with enhanced visuals
   * @param {Array} recipients - List of email addresses
   * @return {Boolean} - True if successful
   */
  function sendWeeklyTeamReport(recipients) {
    if (!recipients || recipients.length === 0) {
      throw new Error('No recipients specified');
    }
    
    // Get data for report
    var dashboardService = getDashboardService();
    var summary = dashboardService.getDashboardSummary();
    var teamService = getTeamService();
    var teamComposition = teamService.getTeamComposition();
    
    // Get current date
    var reportDate = formatDateSafely(new Date(), 'MMMM dd, yyyy');
    
    // Get sender info
    var currentUser = getSafeUserInfo();
    
    // Create email subject
    var subject = 'Weekly Team Status Report: ' + reportDate;
    
    // Create content
    var content = `
      <div class="greeting">Hello Team Leaders,</div>
      
      <div class="message">
        Here is the weekly team status report. This report provides an overview of our team's current status and performance metrics.
      </div>
      
      <!-- Team Summary Stats Cards -->
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-header">
            <div class="stat-title">TEAM MEMBERS</div>
            <div class="stat-icon primary">
              <i class="fas fa-users"></i>
            </div>
          </div>
          <div class="stat-value">${summary.team.total}</div>
          <div class="stat-desc">Total team members</div>
        </div>
        
        <div class="stat-card">
          <div class="stat-header">
            <div class="stat-title">ACTIVE MEMBERS</div>
            <div class="stat-icon success">
              <i class="fas fa-user-check"></i>
            </div>
          </div>
          <div class="stat-value">${summary.team.active}</div>
          <div class="stat-desc">${Math.round((summary.team.active / summary.team.total) * 100)}% of total team</div>
          <div class="progress-container">
            <div class="progress-bar success" style="width: ${Math.round((summary.team.active / summary.team.total) * 100)}%"></div>
          </div>
        </div>
      </div>
      
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-header">
            <div class="stat-title">IN TRAINING</div>
            <div class="stat-icon info">
              <i class="fas fa-graduation-cap"></i>
            </div>
          </div>
          <div class="stat-value">${summary.team.training}</div>
          <div class="stat-desc">${Math.round((summary.team.training / summary.team.total) * 100)}% of total team</div>
        </div>
        
        <div class="stat-card">
          <div class="stat-header">
            <div class="stat-title">AVERAGE PERFORMANCE</div>
            <div class="stat-icon warning">
              <i class="fas fa-chart-line"></i>
            </div>
          </div>
          <div class="stat-value">${teamComposition.averagePerformance ? teamComposition.averagePerformance.toFixed(1) : 'N/A'}</div>
          <div class="stat-desc">Out of 5.0</div>
        </div>
      </div>
      
      <!-- One-on-One Sessions Section -->
      <div class="section">
        <div class="section-header">
          <div class="section-icon">
            <i class="fas fa-comments"></i>
          </div>
          <h3 class="section-title">One-on-One Sessions</h3>
        </div>
        
        <div class="section-content">
          <div class="stats-row">
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">TOTAL SESSIONS</div>
              </div>
              <div class="stat-value">${summary.oneOnOne.total}</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">COMPLETED</div>
              </div>
              <div class="stat-value">${summary.oneOnOne.completed}</div>
              <div class="stat-desc">${Math.round((summary.oneOnOne.completed / summary.oneOnOne.total) * 100)}% of total sessions</div>
            </div>
          </div>
          
          <div class="stats-row">
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">UPCOMING</div>
              </div>
              <div class="stat-value">${summary.oneOnOne.upcoming}</div>
              <div class="stat-desc">In the next 7 days</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">OVERDUE</div>
              </div>
              <div class="stat-value">${summary.oneOnOne.overdue}</div>
              <div class="stat-desc">Requires attention</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Action Items Section -->
      <div class="section">
        <div class="section-header">
          <div class="section-icon">
            <i class="fas fa-tasks"></i>
          </div>
          <h3 class="section-title">Action Items</h3>
        </div>
        
        <div class="section-content">
          <div class="stats-row">
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">TOTAL ITEMS</div>
              </div>
              <div class="stat-value">${summary.actionItems.total}</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">COMPLETED</div>
              </div>
              <div class="stat-value">${summary.actionItems.completed}</div>
              <div class="stat-desc">${Math.round((summary.actionItems.completed / summary.actionItems.total) * 100)}% completion rate</div>
              <div class="progress-container">
                <div class="progress-bar success" style="width: ${Math.round((summary.actionItems.completed / summary.actionItems.total) * 100)}%"></div>
              </div>
            </div>
          </div>
          
          <div class="stats-row">
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">OPEN ITEMS</div>
              </div>
              <div class="stat-value">${summary.actionItems.open}</div>
              <div class="stat-desc">In progress</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-header">
                <div class="stat-title">OVERDUE</div>
              </div>
              <div class="stat-value">${summary.actionItems.overdue}</div>
              <div class="stat-desc">Requires immediate attention</div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    // Add team members needing one-on-one
    var needSessions = teamService.getTeamMembersNeedingOneOnOne(14);
    if (needSessions && needSessions.length > 0) {
      var teamMembersHtml = '';
      
      needSessions.forEach(function(member) {
        var initials = getInitials(member.firstName + ' ' + member.lastName);
        
        teamMembersHtml += `
          <div class="team-member">
            <div class="avatar">${initials}</div>
            <div class="member-info">
              <div class="member-name">${member.firstName} ${member.lastName}</div>
              <div class="member-email">${member.email}</div>
            </div>
          </div>
        `;
      });
      
      content += `
        <div class="section">
          <div class="section-header">
            <div class="section-icon">
              <i class="fas fa-user-clock"></i>
            </div>
            <h3 class="section-title">Team Members Needing One-on-One</h3>
          </div>
          <div class="section-content">
            <div class="team-members">
              ${teamMembersHtml}
            </div>
          </div>
        </div>
      `;
    }
    
    // Add button to access dashboard
    content += `
      <div class="button-container">
        <a href="${ScriptApp.getService().getUrl()}" class="button">
          <i class="fas fa-tachometer-alt"></i> Access Dashboard
        </a>
      </div>
    `;
    
    // Create signature
    var signature = `
      <div class="signature">
        <div class="signature-name">Best regards,</div>
        <div class="signature-name">Team Dashboard</div>
      </div>
    `;
    
    // Create data for email template
    var emailData = {
      title: 'Weekly Team Status Report',
      subtitle: reportDate,
      icon: 'fas fa-chart-pie',
      content: content,
      signature: signature,
      footer: `This report is automatically generated every week. Last updated: ${getCurrentDateTime()}`
    };
    
    // Create HTML body
    var htmlBody = createEmailContainer(emailData);
    
    // Create plain text version
    var plainTextBody = `WEEKLY TEAM STATUS REPORT: ${reportDate}

Hello Team Leaders,

Here is this week's team status report:

== TEAM SUMMARY ==
Total Team Members: ${summary.team.total}
Active Members: ${summary.team.active}
In Training: ${summary.team.training}
Other Status: ${summary.team.other}
${teamComposition.averagePerformance ? `Average Performance Score: ${teamComposition.averagePerformance.toFixed(1)}` : ''}

== ONE-ON-ONE SESSIONS ==
Total Sessions: ${summary.oneOnOne.total}
Completed: ${summary.oneOnOne.completed}
Upcoming (next 7 days): ${summary.oneOnOne.upcoming}
Overdue: ${summary.oneOnOne.overdue}

== ACTION ITEMS ==
Total Items: ${summary.actionItems.total}
Open Items: ${summary.actionItems.open}
Completed Items: ${summary.actionItems.completed}
Overdue Items: ${summary.actionItems.overdue}
`;

    // Add team members needing one-on-one
    if (needSessions && needSessions.length > 0) {
      plainTextBody += `\n== TEAM MEMBERS NEEDING ONE-ON-ONE ==\n`;
      needSessions.forEach(function(member, index) {
        plainTextBody += `${index + 1}. ${member.firstName} ${member.lastName} (${member.email})\n`;
      });
    }
    
    plainTextBody += `\nTo access the dashboard, visit: ${ScriptApp.getService().getUrl()}\n\nBest regards,\nTeam Dashboard`;
    
    // Send the email
    try {
      GmailApp.sendEmail(recipients.join(','), subject, plainTextBody, {
        htmlBody: htmlBody,
        name: 'Team Dashboard'
      });
      return true;
    } catch (e) {
      Logger.log('Failed to send email: ' + e.toString());
      return false;
    }
  }
  
  /**
   * Sends an export of data by email with enhanced styling
   * @param {String} recipient - Email address
   * @param {String} exportType - Type of export (e.g., 'one-on-one', 'team')
   * @param {Blob} attachmentBlob - Attachment data
   * @param {String} attachmentName - Attachment file name
   * @return {Boolean} - True if successful
   */
  function sendExportEmail(recipient, exportType, attachmentBlob, attachmentName) {
    if (!recipient || !attachmentBlob) {
      throw new Error('Invalid export parameters');
    }
    
    // Get recipient info
    var recipientName = getNameFromEmail(recipient);
    
    // Get current date formatted
    var exportDate = formatDateSafely(new Date(), 'MMMM dd, yyyy HH:mm');
    
    // Format export type for display
    var exportTypeFormatted = exportType.replace(/-/g, ' ').replace(/\b\w/g, function(l) {
      return l.toUpperCase();
    });
    
    // Create email subject
    var subject = 'Data Export: ' + exportTypeFormatted;
    
    // Create content
    var content = `
      <div class="greeting">Hello ${recipientName},</div>
      
      <div class="message">
        Your requested data export is now ready. The file is attached to this email.
      </div>
      
      <div class="section">
        <div class="section-header">
          <div class="section-icon">
            <i class="fas fa-file-export"></i>
          </div>
          <h3 class="section-title">Export Details</h3>
        </div>
        <div class="section-content">
          <table style="width: 100%; border-collapse: separate; border-spacing: 0; margin: 10px 0;">
            <tr>
              <td style="padding: 12px 15px; background-color: var(--gray-100); border-radius: 6px 0 0 6px; width: 150px; font-weight: 600;">Export Type:</td>
              <td style="padding: 12px 15px; background-color: white; border-radius: 0 6px 6px 0;">${exportTypeFormatted}</td>
            </tr>
            <tr style="height: 8px;"><td colspan="2"></td></tr>
            <tr>
              <td style="padding: 12px 15px; background-color: var(--gray-100); border-radius: 6px 0 0 6px; width: 150px; font-weight: 600;">Generated On:</td>
              <td style="padding: 12px 15px; background-color: white; border-radius: 0 6px 6px 0;">${exportDate}</td>
            </tr>
            <tr style="height: 8px;"><td colspan="2"></td></tr>
            <tr>
              <td style="padding: 12px 15px; background-color: var(--gray-100); border-radius: 6px 0 0 6px; width: 150px; font-weight: 600;">File Name:</td>
              <td style="padding: 12px 15px; background-color: white; border-radius: 0 6px 6px 0;">${attachmentName}</td>
            </tr>
            <tr style="height: 8px;"><td colspan="2"></td></tr>
            <tr>
              <td style="padding: 12px 15px; background-color: var(--gray-100); border-radius: 6px 0 0 6px; width: 150px; font-weight: 600;">Requested By:</td>
              <td style="padding: 12px 15px; background-color: white; border-radius: 0 6px 6px 0;">${recipient}</td>
            </tr>
          </table>
        </div>
      </div>
      
      <div class="message">
        If you have any questions about this data or need assistance with processing it, please contact the system administrator.
      </div>
    `;
    
    // Create signature
    var signature = `
      <div class="signature">
        <div class="signature-name">Best regards,</div>
        <div class="signature-name">Team Dashboard</div>
      </div>
    `;
    
    // Create data for email template
    var emailData = {
      title: 'Data Export Complete',
      subtitle: exportTypeFormatted,
      icon: 'fas fa-file-export',
      content: content,
      signature: signature,
      footer: `This email was sent from the Team Dashboard on ${getCurrentDateTime()}`
    };
    
    // Create HTML body
    var htmlBody = createEmailContainer(emailData);
    
    // Create plain text version
    var plainTextBody = `Hello ${recipientName},

Your requested data export is now ready. The file is attached to this email.

EXPORT DETAILS:
- Export Type: ${exportTypeFormatted}
- Generated On: ${exportDate}
- File Name: ${attachmentName}
- Requested By: ${recipient}

If you have any questions about this data or need assistance with processing it, please contact the system administrator.

Best regards,
Team Dashboard`;
    
    // Send the email with attachment
    try {
      GmailApp.sendEmail(recipient, subject, plainTextBody, {
        attachments: [attachmentBlob.setName(attachmentName)],
        htmlBody: htmlBody,
        name: 'Team Dashboard'
      });
      return true;
    } catch (e) {
      Logger.log('Failed to send export email: ' + e.toString());
      return false;
    }
  }
  
  /**
   * Tests the email service by sending a test email to the specified recipient
   * @param {String} recipient - Email address to send test to
   * @param {String} testType - Type of test email to send (default, one-on-one, action, report)
   * @return {Object} - Result object with success status and message
   */
  function testEmailService(recipient, testType = 'default') {
    if (!recipient) {
      return { success: false, message: 'Recipient email is required' };
    }
    
    try {
      let result;
      
      switch (testType.toLowerCase()) {
        case 'one-on-one':
          // Create mock session data
          const mockSessionData = {
            teamMember: recipient,
            date: new Date(),
            statusNotes: 'This is a test status update. Current projects are on track.',
            performanceNotes: 'This is a test performance note. Great work on recent tasks!',
                        developmentNotes: 'This is a test development note. We discussed growth opportunities.',
            supportNotes: 'This is a test support note. Resources needed: documentation access.',
            actionItems: [
              { description: 'Test action item 1', dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), priority: 'high' },
              { description: 'Test action item 2', dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), priority: 'medium' }
            ],
            followUpDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
          };
          
          result = sendOneOnOneFollowUp(mockSessionData);
          return { 
            success: result, 
            message: result ? 'Test one-on-one email sent successfully' : 'Failed to send test one-on-one email',
            testData: mockSessionData
          };
          
        case 'action':
          // Create mock action item
          const mockActionItem = {
            owner: recipient,
            description: 'Test action item that needs attention',
            dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000),
            priority: 'high',
            notes: 'This is a test reminder for an important action item.'
          };
          
          result = sendActionItemReminder(mockActionItem);
          return { 
            success: result, 
            message: result ? 'Test action reminder email sent successfully' : 'Failed to send test action reminder email',
            testData: mockActionItem
          };
          
        case 'report':
          result = sendWeeklyTeamReport([recipient]);
          return { 
            success: result, 
            message: result ? 'Test weekly report email sent successfully' : 'Failed to send test weekly report email'
          };
          
        default:
          // Create a simple test email
          const subject = 'Email Service Test';
          const content = `
            <div class="greeting">Hello,</div>
            <div class="message">
              This is a test email from the Team Dashboard Email Service.
              <br><br>
              Current system time: ${getCurrentDateTime()}
              <br>
              If you're receiving this email, the email service is functioning correctly.
            </div>
            
            <div class="section">
              <div class="section-header">
                <div class="section-icon">
                  <i class="fas fa-info-circle"></i>
                </div>
                <h3 class="section-title">Test Information</h3>
              </div>
              <div class="section-content">
                <p>This email was generated as part of an email service test.</p>
                <p>All email templates and functionality appear to be working correctly.</p>
                <p>No action is required.</p>
              </div>
            </div>
          `;
          
          const signature = `
            <div class="signature">
              <div class="signature-name">Best regards,</div>
              <div class="signature-name">Team Dashboard System</div>
            </div>
          `;
          
          const emailData = {
            title: 'Email Service Test',
            subtitle: 'System Check',
            icon: 'fas fa-check-circle',
            content: content,
            signature: signature,
            footer: `Test completed on ${getCurrentDateTime()}`
          };
          
          const htmlBody = createEmailContainer(emailData);
          const plainTextBody = `Hello,

This is a test email from the Team Dashboard Email Service.

Current system time: ${getCurrentDateTime()}

If you're receiving this email, the email service is functioning correctly.

TEST INFORMATION:
- This email was generated as part of an email service test.
- All email templates and functionality appear to be working correctly.
- No action is required.

Best regards,
Team Dashboard System`;
          
          try {
            GmailApp.sendEmail(recipient, subject, plainTextBody, {
              htmlBody: htmlBody,
              name: 'Team Dashboard'
            });
            return { success: true, message: 'Basic test email sent successfully' };
          } catch (e) {
            return { success: false, message: 'Failed to send basic test email: ' + e.toString() };
          }
      }
    } catch (e) {
      return { success: false, message: 'Test failed with error: ' + e.toString(), error: e };
    }
  }
  
  /**
   * Logs email service diagnostics info to the Logger
   * @return {Object} - Diagnostic information
   */
  function getEmailServiceDiagnostics() {
    const diagnostics = {
      timestamp: getCurrentDateTime(),
      scriptTimeZone: Session.getScriptTimeZone(),
      userInfo: getSafeUserInfo(),
      serviceUrl: ScriptApp.getService().getUrl(),
      quotaRemaining: MailApp.getRemainingDailyQuota(),
      environment: {
        serviceType: typeof GmailApp !== 'undefined' ? 'GmailApp' : 'MailApp'
      }
    };
    
    Logger.log('Email Service Diagnostics: ' + JSON.stringify(diagnostics));
    return diagnostics;
  }
  
  // Return the public API
  return {
    sendOneOnOneFollowUp: sendOneOnOneFollowUp,
    sendActionItemReminder: sendActionItemReminder,
    sendWeeklyTeamReport: sendWeeklyTeamReport,
    sendExportEmail: sendExportEmail,
    testEmailService: testEmailService,
    getDiagnostics: getEmailServiceDiagnostics
  };
})();

/**
 * Get the EmailService instance
 * @return {Object} - EmailService instance
 */
function getEmailService() {
  return EmailService;
}

/**
 * Helper function to run a simple email test from the script editor
 */
function runEmailServiceTest() {
  // Using the current logged-in user for test
  const testRecipientEmail = Session.getActiveUser().getEmail();
  const result = EmailService.testEmailService(testRecipientEmail);
  Logger.log(result);
  return result;
}

/**
 * Helper function to test one-on-one emails
 */
function testOneOnOneEmail() {
  const testRecipientEmail = Session.getActiveUser().getEmail();
  const result = EmailService.testEmailService(testRecipientEmail, 'one-on-one');
  Logger.log(result);
  return result;
}

/**
 * Helper function to test action item reminders
 */
function testActionItemEmail() {
  const testRecipientEmail = Session.getActiveUser().getEmail();
  const result = EmailService.testEmailService(testRecipientEmail, 'action');
  Logger.log(result);
  return result;
}

/**
 * Helper function to test weekly reports
 */
function testWeeklyReportEmail() {
  const testRecipientEmail = Session.getActiveUser().getEmail();
  const result = EmailService.testEmailService(testRecipientEmail, 'report');
  Logger.log(result);
  return result;
}

/**
 * Run diagnostics and log results
 */
function runEmailServiceDiagnostics() {
  return EmailService.getDiagnostics();
}
/**
 * Safely formats a date 
 * @param {Date|string} date - The date to format
 * @param {string} format - Optional format (default: 'MMMM dd, yyyy')
 * @return {string} - Formatted date string
 */
function formatDateSafely(date, format = 'MMMM dd, yyyy') {
  if (!date) return '';
  
  try {
    // Convert to Date object if it's a string
    if (typeof date === 'string') {
      date = new Date(date);
    }
    
    // Check if date is valid
    if (isNaN(date.getTime())) {
      return '';
    }
    
    // Use Utilities.formatDate for consistent formatting
    return Utilities.formatDate(date, Session.getScriptTimeZone(), format);
  } catch (e) {
    Logger.log('Error formatting date: ' + e.toString());
    return '';
  }
}


/**
 * WeeklyScheduleService.gs - Services for managing weekly schedules
 */

var WeeklyScheduleService = (function() {
  // Private variables and methods
  var SCHEDULE_SHEET_NAME = 'WeeklySchedule';
  
  /**
   * Gets the weekly schedule sheet, creates if it doesn't exist
   * @return {Sheet} - Google Sheet for weekly schedule
   */
  function getScheduleSheet_() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(SCHEDULE_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(SCHEDULE_SHEET_NAME);
      
      // Create the headers
      var headers = [
        'Week ID', 'Year', 'Week Number', 'Team Member', 
        'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday',
        'Total Hours', 'Status', 'Notes', 'Last Updated'
      ];
      
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
      
      // Format date columns
      sheet.getRange(2, 15, 999, 1).setNumberFormat('yyyy-mm-dd HH:mm:ss');
    }
    
    return sheet;
  }
  
  return {
    /**
     * Initializes a new weekly schedule for the team
     * @param {Number} year - Year
     * @param {Number} weekNum - Week number
     * @return {String} - Week ID
     */
    initializeWeek: function(year, weekNum) {
      var teamService = getTeamService();
      var utilityService = getUtilityService();
      var sheet = getScheduleSheet_();
      var weekId = 'W' + year + '-' + weekNum;
      var now = new Date();
      
      // Check if week already exists
      var data = sheet.getDataRange().getValues();
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === weekId) {
          // Week exists, don't create duplicate
          Logger.log('Week already initialized: ' + weekId);
          return weekId;
        }
      }
      
      // Get all active team members
      var teamMembers = teamService.getTeamMembers({status: 'Active'});
      
      // Create a row for each team member
      teamMembers.forEach(function(member) {
        var rowData = [
          weekId,
          year,
          weekNum,
          member.email,
          '', // Monday
          '', // Tuesday
          '', // Wednesday
          '', // Thursday
          '', // Friday
          '', // Saturday
          '', // Sunday
          0,  // Total Hours
          'Not Submitted', // Status
          '', // Notes
          now // Last Updated
        ];
        
        var lastRow = Math.max(sheet.getLastRow(), 1);
        sheet.getRange(lastRow + 1, 1, 1, rowData.length).setValues([rowData]);
      });
      
      return weekId;
    },
    
    /**
     * Updates schedule for a team member
     * @param {String} weekId - Week ID
     * @param {String} teamMember - Team member email
     * @param {Object} scheduleData - Schedule data
     * @return {Boolean} - True if successful
     */
    updateSchedule: function(weekId, teamMember, scheduleData) {
      var sheet = getScheduleSheet_();
      var data = sheet.getDataRange().getValues();
      var rowIndex = -1;
      
      // Find the team member's row for this week
      for (var i = 1; i < data.length; i++) {
                if (data[i][0] === weekId && data[i][3] === teamMember) {
          rowIndex = i + 1; // +1 because i is 0-based and row indices are 1-based
          break;
        }
      }
      
      if (rowIndex === -1) {
        throw new Error('Schedule entry not found for this team member and week');
      }
      
      // Update schedule
      var row = data[rowIndex-1];
      
      if (scheduleData.monday !== undefined) row[4] = scheduleData.monday;
      if (scheduleData.tuesday !== undefined) row[5] = scheduleData.tuesday;
      if (scheduleData.wednesday !== undefined) row[6] = scheduleData.wednesday;
      if (scheduleData.thursday !== undefined) row[7] = scheduleData.thursday;
      if (scheduleData.friday !== undefined) row[8] = scheduleData.friday;
      if (scheduleData.saturday !== undefined) row[9] = scheduleData.saturday;
      if (scheduleData.sunday !== undefined) row[10] = scheduleData.sunday;
      
      // Calculate total hours
      var totalHours = 0;
      for (var i = 4; i <= 10; i++) {
        if (row[i] && typeof row[i] === 'string' && row[i].trim() !== '') {
          totalHours += this.calculateHoursFromShift(row[i]);
        }
      }
      row[11] = totalHours;
      
      if (scheduleData.status !== undefined) row[12] = scheduleData.status;
      if (scheduleData.notes !== undefined) row[13] = scheduleData.notes;
      row[14] = new Date(); // Last updated
      
      sheet.getRange(rowIndex, 1, 1, row.length).setValues([row]);
      
      return true;
    },
    
    /**
     * Calculates hours from a shift entry
     * @param {String} shiftText - Shift text (e.g., "9:00-17:00")
     * @return {Number} - Hours for the shift
     */
    calculateHoursFromShift: function(shiftText) {
      if (!shiftText || typeof shiftText !== 'string') {
        return 0;
      }
      
      // Handle multiple shifts separated by commas
      if (shiftText.indexOf(',') !== -1) {
        var shifts = shiftText.split(',');
        var totalHours = 0;
        
        shifts.forEach(function(shift) {
          totalHours += this.calculateHoursFromShift(shift.trim());
        }, this);
        
        return totalHours;
      }
      
      // Handle single shift
      var parts = shiftText.split('-');
      if (parts.length !== 2) {
        return 0; // Invalid format
      }
      
      // Parse times
      var startParts = parts[0].trim().split(':');
      var endParts = parts[1].trim().split(':');
      
      if (startParts.length !== 2 || endParts.length !== 2) {
        return 0; // Invalid format
      }
      
      var startHour = parseInt(startParts[0]);
      var startMinute = parseInt(startParts[1]);
      var endHour = parseInt(endParts[0]);
      var endMinute = parseInt(endParts[1]);
      
      // Calculate duration in hours
      var duration = (endHour - startHour) + (endMinute - startMinute) / 60;
      return Math.max(0, duration); // Ensure non-negative
    },
    
    /**
     * Gets schedule for a week
     * @param {Number} year - Year
     * @param {Number} weekNum - Week number
     * @return {Array} - Array of schedule entries
     */
    getWeekSchedule: function(year, weekNum) {
      var weekId = 'W' + year + '-' + weekNum;
      var sheet = getScheduleSheet_();
      var data = sheet.getDataRange().getValues();
      var schedule = [];
      
      // Skip header row
      for (var i = 1; i < data.length; i++) {
        var row = data[i];
        if (row[0] === weekId) {
          schedule.push({
            weekId: row[0],
            year: row[1],
            weekNum: row[2],
            teamMember: row[3],
            monday: row[4],
            tuesday: row[5],
            wednesday: row[6],
            thursday: row[7],
            friday: row[8],
            saturday: row[9],
            sunday: row[10],
            totalHours: row[11],
            status: row[12],
            notes: row[13],
            lastUpdated: row[14]
          });
        }
      }
      
      return schedule;
    },
    
    /**
     * Gets schedule for a team member
     * @param {String} teamMember - Team member email
     * @param {Number} year - Year (optional)
     * @param {Number} weekNum - Week number (optional)
     * @return {Array} - Array of schedule entries
     */
    getTeamMemberSchedule: function(teamMember, year, weekNum) {
      var sheet = getScheduleSheet_();
      var data = sheet.getDataRange().getValues();
      var schedule = [];
      
      // Skip header row
      for (var i = 1; i < data.length; i++) {
        var row = data[i];
        
        // Filter by team member
        if (row[3] === teamMember) {
          // Apply additional filters if provided
          if ((year && row[1] !== year) || (weekNum && row[2] !== weekNum)) {
            continue;
          }
          
          schedule.push({
            weekId: row[0],
            year: row[1],
            weekNum: row[2],
            teamMember: row[3],
            monday: row[4],
            tuesday: row[5],
            wednesday: row[6],
            thursday: row[7],
            friday: row[8],
            saturday: row[9],
            sunday: row[10],
            totalHours: row[11],
            status: row[12],
            notes: row[13],
            lastUpdated: row[14]
          });
        }
      }
      
      return schedule;
    },
    
    /**
     * Gets schedule for the current week
     * @return {Array} - Array of schedule entries
     */
    getCurrentWeekSchedule: function() {
      var now = new Date();
      var year = now.getFullYear();
      var weekNum = this.getWeekNumber(now);
      
      return this.getWeekSchedule(year, weekNum);
    },
    
    /**
     * Gets week number from a date
     * @param {Date} date - Input date
     * @return {Number} - Week number
     */
    getWeekNumber: function(date) {
      var d = new Date(date);
      d.setHours(0, 0, 0, 0);
      d.setDate(d.getDate() + 4 - (d.getDay() || 7));
      var yearStart = new Date(d.getFullYear(), 0, 1);
      return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    },
    
    /**
     * Submits a weekly schedule
     * @param {String} weekId - Week ID
     * @param {String} teamMember - Team member email
     * @return {Boolean} - True if successful
     */
    submitSchedule: function(weekId, teamMember) {
      return this.updateSchedule(weekId, teamMember, {
        status: 'Submitted'
      });
    },
    
    /**
     * Approves a weekly schedule
     * @param {String} weekId - Week ID
     * @param {String} teamMember - Team member email
     * @return {Boolean} - True if successful
     */
    approveSchedule: function(weekId, teamMember) {
      return this.updateSchedule(weekId, teamMember, {
        status: 'Approved'
      });
    },
    
    /**
     * Rejects a weekly schedule
     * @param {String} weekId - Week ID
     * @param {String} teamMember - Team member email
     * @param {String} notes - Rejection notes
     * @return {Boolean} - True if successful
     */
    rejectSchedule: function(weekId, teamMember, notes) {
      return this.updateSchedule(weekId, teamMember, {
        status: 'Rejected',
        notes: notes
      });
    },
    
    /**
     * Exports schedule for a week
     * @param {Number} year - Year
     * @param {Number} weekNum - Week number
     * @return {Blob} - Blob containing CSV data
     */
    exportWeekSchedule: function(year, weekNum) {
      var schedule = this.getWeekSchedule(year, weekNum);
      
      if (schedule.length === 0) {
        throw new Error('No schedule data found for this week');
      }
      
      var headers = [
        'Team Member', 'Monday', 'Tuesday', 'Wednesday',
        'Thursday', 'Friday', 'Saturday', 'Sunday',
        'Total Hours', 'Status', 'Notes', 'Last Updated'
      ];
      
      var data = schedule.map(function(entry) {
        return [
          entry.teamMember,
          entry.monday,
          entry.tuesday,
          entry.wednesday,
          entry.thursday,
          entry.friday,
          entry.saturday,
          entry.sunday,
          entry.totalHours,
          entry.status,
          entry.notes,
          Utilities.formatDate(new Date(entry.lastUpdated), 
                             Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss')
        ];
      });
      
      // Generate CSV
      var csv = headers.join(',') + '\n';
      
      data.forEach(function(row) {
        var processedRow = row.map(function(cell) {
          if (cell === null || cell === undefined) {
            return '';
          }
          var cellStr = String(cell);
          if (cellStr.indexOf(',') !== -1 || cellStr.indexOf('"') !== -1 || cellStr.indexOf('\n') !== -1) {
            return '"' + cellStr.replace(/"/g, '""') + '"';
          }
          return cellStr;
        });
        
        csv += processedRow.join(',') + '\n';
      });
      
      return Utilities.newBlob(csv, 'text/csv', 
                            'Schedule_Week_' + weekNum + '_' + year + '.csv');
    },
    
    /**
     * Gets schedule summary statistics
     * @param {Number} year - Year
     * @param {Number} weekNum - Week number (optional)
     * @return {Object} - Schedule stats
     */
    getScheduleStats: function(year, weekNum) {
      var sheet = getScheduleSheet_();
      var data = sheet.getDataRange().getValues();
      var stats = {
        totalHours: 0,
        averageHours: 0,
        submittedCount: 0,
        approvedCount: 0,
        rejectedCount: 0,
        pendingCount: 0,
        byTeamMember: {}
      };
      
      var count = 0;
      
      // Skip header row
      for (var i = 1; i < data.length; i++) {
        var row = data[i];
        
        // Filter by year and week if provided
        if (row[1] === year && (!weekNum || row[2] === weekNum)) {
          var hours = row[11] || 0;
          stats.totalHours += hours;
          count++;
          
          // Count by status
          switch (row[12]) {
            case 'Submitted':
              stats.submittedCount++;
              break;
            case 'Approved':
              stats.approvedCount++;
              break;
            case 'Rejected':
              stats.rejectedCount++;
              break;
            default:
              stats.pendingCount++;
          }
          
          // Track by team member
          var email = row[3];
          if (!stats.byTeamMember[email]) {
            stats.byTeamMember[email] = {
              totalHours: 0,
              weekCount: 0,
              averageHours: 0
            };
          }
          
          stats.byTeamMember[email].totalHours += hours;
          stats.byTeamMember[email].weekCount++;
        }
      }
      
      // Calculate averages
      if (count > 0) {
        stats.averageHours = stats.totalHours / count;
      }
      
      Object.keys(stats.byTeamMember).forEach(function(email) {
        var member = stats.byTeamMember[email];
        if (member.weekCount > 0) {
          member.averageHours = member.totalHours / member.weekCount;
        }
      });
      
      return stats;
    }
  };
})();

/**
 * Get the WeeklyScheduleService instance
 * @return {Object} - WeeklyScheduleService instance
 */
function getWeeklyScheduleService() {
  return WeeklyScheduleService;
}

/**
 * MetricsService.gs - Advanced Metrics and Analytics Service
 * Created: 2025-03-22 21:57:56
 * For data-driven analytics dashboards with advanced visualizations
 */

var MetricsService = (function() {
  // Private variables and constants
  const METRICS_SHEET_NAME = 'MetricsData';
  const METRICS_HISTORY_SHEET_NAME = 'MetricsExportHistory';
  const METRICS_EMAIL_CONFIG_SHEET_NAME = 'MetricsEmailConfig';
  
  // Metric goals configuration - can be updated via settings
  const DEFAULT_METRIC_GOALS = {
    answerRate: {
      min: 95,
      unit: '%',
      description: '95% & Higher'
    },
    averageTalkTime: {
      min: 15,
      max: 20,
      unit: 'min',
      description: 'Between 15-20 min'
    },
    acwPercentage: {
      max: 5,
      unit: 'min',
      description: '5 min or less'
    },
    onQueuePercentage: {
      min: 65,
      unit: '%',
      description: '65% and higher'
    },
    interactingTime: {
      min: 4,
      max: 6,
      unit: 'hrs',
      description: '4-6 hrs; ≥ 50%'
    }
  };
  
  /**
   * Gets or creates the Metrics data sheet
   * @return {Sheet} Google Sheet for metrics data
   */
  function getMetricsSheet_() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(METRICS_SHEET_NAME);
    
    if (!sheet) {
      // Create new sheet with modern structure
      sheet = ss.insertSheet(METRICS_SHEET_NAME);
      
      // Add headers
      const headers = [
        'id', 'date', 'teamMemberEmail', 'teamMemberName', 'callsOffered', 
        'callsAccepted', 'answerRate', 'averageTalkTime', 'acwPercentage',
        'onQueuePercentage', 'offQueuePercentage', 'interactingTime',
        'interactingPercentage', 'notes', 'createdBy', 'createdDate', 'lastUpdated'
      ];
      
      sheet.appendRow(headers);
      sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold').setBackground('#E8EAED');
      sheet.setFrozenRows(1);
    }
    
    return sheet;
  }
  
  /**
   * Gets or creates the Metrics export history sheet
   * @return {Sheet} Google Sheet for metrics export history
   */
  function getMetricsHistorySheet_() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(METRICS_HISTORY_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(METRICS_HISTORY_SHEET_NAME);
      sheet.appendRow(['id', 'name', 'date', 'format', 'url', 'exportedBy', 'recordCount', 'dateRange']);
      sheet.getRange(1, 1, 1, 8).setFontWeight('bold').setBackground('#E8EAED');
    }
    
    return sheet;
  }
  
  /**
   * Gets or creates the Metrics email configuration sheet
   * @return {Sheet} Google Sheet for metrics email configurations
   */
  function getMetricsEmailConfigSheet_() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(METRICS_EMAIL_CONFIG_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(METRICS_EMAIL_CONFIG_SHEET_NAME);
      sheet.appendRow([
        'id', 'name', 'description', 'recipients', 'frequency', 'dayOfWeek', 
        'dayOfMonth', 'reportType', 'metrics', 'includeCharts', 'includeRawData',
        'dateRangeType', 'status', 'lastSent', 'createdBy', 'createdDate', 'lastUpdated'
      ]);
      sheet.getRange(1, 1, 1, 17).setFontWeight('bold').setBackground('#E8EAED');
    }
    
    return sheet;
  }
  
  /**
   * Records an export in the history sheet
   * @param {Object} exportData - Data about the export
   */
  function recordExport_(exportData) {
    try {
      const sheet = getMetricsHistorySheet_();
      
      // Add the export record
      sheet.appendRow([
        Utilities.getUuid(),
        exportData.name,
        new Date(),
        exportData.format,
        exportData.url || '',
        Session.getActiveUser().getEmail(),
        exportData.recordCount || 0,
        exportData.dateRange || ''
      ]);
    } catch (e) {
      Logger.log('Error recording metrics export: ' + e.toString());
    }
  }
  
  /**
   * Calculates derived metrics from raw input data
   * @param {Object} rawData - Raw metrics input data
   * @return {Object} Complete metrics with calculated fields
   */
  function calculateDerivedMetrics_(rawData) {
    let result = Object.assign({}, rawData);
    
    // Calculate answer rate
    if (result.callsOffered > 0 && result.callsAccepted !== undefined) {
      result.answerRate = (result.callsAccepted / result.callsOffered) * 100;
    }
    
    // Calculate interacting percentage (if applicable)
    if (result.interactingTime !== undefined && rawData.shiftHours) {
      result.interactingPercentage = (result.interactingTime / rawData.shiftHours) * 100;
    }
    
    // Ensure offQueuePercentage is calculated properly
    if (result.onQueuePercentage !== undefined) {
      result.offQueuePercentage = 100 - result.onQueuePercentage;
    }
    
    return result;
  }
  
  /**
   * Creates email content for metrics report
   * @param {String} reportType - Type of report
   * @param {Object} data - Report data
   * @return {String} HTML email content
   */
  function createMetricsEmailContent_(reportType, data) {
    // Common header and footer
    const header = `
      <div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto;">
        <div style="background-color: #4285f4; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0;">Metrics Report</h1>
          <p style="margin: 10px 0 0;">Date Range: ${data.dateRange || 'All Time'}</p>
        </div>
        <div style="padding: 20px; background-color: #f8f9fc;">
    `;
    
    const footer = `
        </div>
        <div style="background-color: #f1f1f1; padding: 15px; text-align: center; font-size: 12px; color: #666;">
          <p>This is an automated message from the Metrics System.</p>
        </div>
      </div>
    `;
    
    let content = '';
    
    if (reportType === 'team_summary') {
      content = `
        <h2 style="color: #4285f4; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Team Performance Summary</h2>
        
        <div style="margin: 20px 0; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4285f4;">Key Metrics</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr style="background-color: #f8f9fc;">
              <th style="padding: 8px; text-align: left; border-bottom: 1px solid #e3e6f0;">Metric</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Average</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Goal</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Status</th>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">Answer Rate</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${data.summary.answerRate.toFixed(1)}%</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">≥ 95%</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0; color: ${data.summary.answerRate >= 95 ? '#1cc88a' : '#e74a3b'};">
                ${data.summary.answerRate >= 95 ? '✓ Meeting Goal' : '✗ Below Goal'}
              </td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">Average Talk Time</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${data.summary.averageTalkTime.toFixed(1)} min</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">15-20 min</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0; color: ${(data.summary.averageTalkTime >= 15 && data.summary.averageTalkTime <= 20) ? '#1cc88a' : '#e74a3b'};">
                ${(data.summary.averageTalkTime >= 15 && data.summary.averageTalkTime <= 20) ? '✓ Meeting Goal' : '✗ Outside Goal Range'}
              </td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">ACW Time</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${data.summary.acwPercentage.toFixed(1)} min</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">≤ 5 min</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0; color: ${data.summary.acwPercentage <= 5 ? '#1cc88a' : '#e74a3b'};">
                ${data.summary.acwPercentage <= 5 ? '✓ Meeting Goal' : '✗ Above Goal'}
              </td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">On Queue %</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${data.summary.onQueuePercentage.toFixed(1)}%</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">≥ 65%</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0; color: ${data.summary.onQueuePercentage >= 65 ? '#1cc88a' : '#e74a3b'};">
                ${data.summary.onQueuePercentage >= 65 ? '✓ Meeting Goal' : '✗ Below Goal'}
              </td>
            </tr>
            <tr>
              <td style="padding: 8px;">Interacting Time</td>
              <td style="padding: 8px; text-align: center;">${data.summary.interactingTime.toFixed(1)} hrs (${data.summary.interactingPercentage.toFixed(1)}%)</td>
              <td style="padding: 8px; text-align: center;">4-6 hrs; ≥ 50%</td>
              <td style="padding: 8px; text-align: center; color: ${(data.summary.interactingTime >= 4 && data.summary.interactingTime <= 6 && data.summary.interactingPercentage >= 50) ? '#1cc88a' : '#e74a3b'};">
                ${(data.summary.interactingTime >= 4 && data.summary.interactingTime <= 6 && data.summary.interactingPercentage >= 50) ? '✓ Meeting Goal' : '✗ Outside Goal Range'}
              </td>
            </tr>
          </table>
        </div>
        
        <div style="margin: 20px 0; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4285f4;">Team Members Below Goals</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr style="background-color: #f8f9fc;">
              <th style="padding: 8px; text-align: left; border-bottom: 1px solid #e3e6f0;">Team Member</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Metric</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Current</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Goal</th>
            </tr>
            ${data.belowGoal.map(item => `
              <tr>
                <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">${item.teamMemberName}</td>
                <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${item.metricName}</td>
                <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${item.currentValue} ${item.unit}</td>
                <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${item.goalDescription}</td>
              </tr>
            `).join('')}
          </table>
        </div>
      `;
    } else if (reportType === 'individual_performance') {
      content = `
        <h2 style="color: #4285f4; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Individual Performance Report: ${data.teamMemberName}</h2>
        
        <div style="margin: 20px 0; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4285f4;">Performance Metrics</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr style="background-color: #f8f9fc;">
              <th style="padding: 8px; text-align: left; border-bottom: 1px solid #e3e6f0;">Metric</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Average</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Goal</th>
              <th style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">Status</th>
            </tr>
            ${Object.entries(data.metrics).map(([key, value]) => {
              let goalDescription = '';
              let meetingGoal = false;
              
              if (key === 'answerRate') {
                goalDescription = '≥ 95%';
                meetingGoal = value >= 95;
              } else if (key === 'averageTalkTime') {
                goalDescription = '15-20 min';
                meetingGoal = value >= 15 && value <= 20;
              } else if (key === 'acwPercentage') {
                goalDescription = '≤ 5 min';
                meetingGoal = value <= 5;
              } else if (key === 'onQueuePercentage') {
                goalDescription = '≥ 65%';
                meetingGoal = value >= 65;
              } else if (key === 'interactingTime') {
                goalDescription = '4-6 hrs; ≥ 50%';
                meetingGoal = value >= 4 && value <= 6;
              }
              
              return `
                <tr>
                  <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">${key}</td>
                  <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${value.toFixed(1)}</td>
                  <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${goalDescription}</td>
                  <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0; color: ${meetingGoal ? '#1cc88a' : '#e74a3b'};">
                    ${meetingGoal ? '✓ Meeting Goal' : '✗ Not Meeting Goal'}
                  </td>
                </tr>
              `;
            }).join('')}
          </table>
        </div>
        
        <div style="margin: 20px 0; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4285f4;">Volume Metrics</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">Total Calls Offered:</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${data.volume.callsOffered}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #e3e6f0;">Total Calls Accepted:</td>
              <td style="padding: 8px; text-align: center; border-bottom: 1px solid #e3e6f0;">${data.volume.callsAccepted}</td>
            </tr>
            <tr>
              <td style="padding: 8px;">Total Interacting Time:</td>
              <td style="padding: 8px; text-align: center;">${data.volume.totalInteractingTime.toFixed(1)} hrs</td>
            </tr>
          </table>
        </div>
      `;
    } else {
      // Default generic report
      content = `
        <h2 style="color: #4285f4; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Metrics Report</h2>
        
        <div style="margin: 20px 0; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4285f4;">Report Summary</h3>
          <p>This is a generic metrics report. Please select a specific report type for more detailed information.</p>
        </div>
      `;
    }
    
    return header + content + footer;
  }
  
  /**
   * Creates a timestamp-based ID for saving records
   * @return {String} Unique ID
   */
  function createUniqueId_() {
    return Utilities.getUuid();
  }
  
  // Return public methods
  return {
    /**
     * Initializes the metrics system
     * @return {Object} Result with success flag
     */
    initializeSheets: function() {
      try {
        getMetricsSheet_();
        getMetricsHistorySheet_();
        getMetricsEmailConfigSheet_();
        
        return {
          success: true,
          message: 'Metrics system initialized successfully'
        };
      } catch (e) {
        Logger.log('Error initializing metrics system: ' + e.toString());
        return {
          success: false,
          message: 'Error initializing metrics system: ' + e.toString()
        };
      }
    },
    
    /**
     * Saves daily metrics data for a team member or entire team
     * @param {Object} metricsData - Metrics data to save
     * @return {Object} Result with success flag
     */
    saveMetricsData: function(metricsData) {
      try {
        const sheet = getMetricsSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        
        // Validate incoming data
        const validation = this.validateMetricsData(metricsData);
        if (!validation.isValid) {
          return {
            success: false,
            message: 'Validation errors: ' + validation.errors.join(', '),
            errors: validation.errors
          };
        }
        
        // Add additional fields if this is a new record
        if (!metricsData.id) {
          metricsData.id = createUniqueId_();
          metricsData.createdDate = new Date();
          metricsData.createdBy = Session.getActiveUser().getEmail();
        }
        
        // Calculate derived metrics
        metricsData = calculateDerivedMetrics_(metricsData);
        
        // Set last updated timestamp
        metricsData.lastUpdated = new Date();
        
        // Check if this record already exists
        let rowIndex = -1;
        if (metricsData.id) {
          for (let i = 1; i < data.length; i++) {
            if (data[i][0] === metricsData.id) {
              rowIndex = i + 1; // +1 because sheet rows are 1-indexed
              break;
            }
          }
        }
        
        // Create row array for sheet
        const rowData = [];
        headers.forEach(header => {
          rowData.push(metricsData[header] !== undefined ? metricsData[header] : '');
        });
        
        // Update or append record
        if (rowIndex > 0) {
          // Update existing record
          sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
        } else {
          // Append new record
          sheet.appendRow(rowData);
        }
        
        return {
          success: true,
          message: 'Metrics data saved successfully',
          metricsId: metricsData.id
        };
      } catch (e) {
        logMetricsError('saveMetricsData', e.toString(), { metricsData: JSON.stringify(metricsData) });
        return {
          success: false,
          message: 'Error saving metrics data: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets metrics data with flexible filtering options
     * @param {Object} options - Filter options including date range, team member, metrics types
     * @return {Array} Filtered metrics data
     */
    getMetricsData: function(options = {}) {
      try {
        const sheet = getMetricsSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        const metrics = [];
        
        // Default values if not provided
        const startDate = options.startDate || new Date(0); // Beginning of time
        const endDate = options.endDate || new Date(9999, 11, 31); // Far future
        
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          const metric = {};
          
          // Create object from row data
          headers.forEach((header, index) => {
            metric[header] = row[index];
          });
          
          // Filter by date
          const metricDate = new Date(metric.date);
          if (metricDate < startDate || metricDate > endDate) {
            continue;
          }
          
          // Filter by team member
          if (options.teamMemberEmail && metric.teamMemberEmail !== options.teamMemberEmail) {
            continue;
          }
          
          // Filter by ID
          if (options.id && metric.id !== options.id) {
            continue;
          }
          
          // Add to results
          metrics.push(metric);
        }
        
        return metrics;
      } catch (e) {
        logMetricsError('getMetricsData', e.toString(), { options: JSON.stringify(options) });
        return [];
      }
    },
    
    /**
     * Validates metrics data before saving
     * @param {Object} metricsData - The metrics data to validate
     * @return {Object} Validation result with errors if any
     */
    validateMetricsData: function(metricsData) {
      const errors = [];
      
      // Check required fields
      if (!metricsData.date) {
        errors.push("Date is required");
      }
      
      if (!metricsData.teamMemberEmail) {
        errors.push("Team member email is required");
      }
      
      // Validate numeric metrics
      const numericFields = [
        'callsOffered', 'callsAccepted', 'averageTalkTime', 
        'acwPercentage', 'onQueuePercentage', 'interactingTime'
      ];
      
      numericFields.forEach(field => {
        if (metricsData[field] !== undefined) {
          const value = metricsData[field];
          
          if (isNaN(value) || value < 0) {
            errors.push(`${field} must be a positive number`);
          }
        }
      });
      
      // Specific validations
      if (metricsData.onQueuePercentage !== undefined) {
        if (metricsData.onQueuePercentage < 0 || metricsData.onQueuePercentage > 100) {
          errors.push("On Queue Percentage must be between 0 and 100");
        }
      }
      
      return {
        isValid: errors.length === 0,
        errors: errors
      };
    },
    
    /**
     * Calculates derived metrics from raw input data
     * @param {Object} rawData - Raw metrics input data
     * @return {Object} Complete metrics with calculated fields
     */
    calculateDerivedMetrics: function(rawData) {
      return calculateDerivedMetrics_(rawData);
    },
    
    /**
     * Checks if metrics exist for a specific date and team member
     * @param {Date} date - The date to check
     * @param {String} teamMemberEmail - The team member's email
     * @return {Boolean} Whether metrics exist
     */
    metricsExistForDateAndMember: function(date, teamMemberEmail) {
      try {
        if (!date || !teamMemberEmail) return false;
        
        // Format date to yyyy-MM-dd for comparison
        const formattedDate = Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), 'yyyy-MM-dd');
        
        // Get metrics data
        const metrics = this.getMetricsData({
          teamMemberEmail: teamMemberEmail
        });
        
        // Check if any record matches this date
        for (const metric of metrics) {
          const metricDateFormatted = Utilities.formatDate(new Date(metric.date), Session.getScriptTimeZone(), 'yyyy-MM-dd');
          if (metricDateFormatted === formattedDate) {
            return true;
          }
        }
        
        return false;
      } catch (e) {
        logMetricsError('metricsExistForDateAndMember', e.toString(), { date, teamMemberEmail });
        return false;
      }
    },
    
    /**
     * Gets dashboard overview data
     * @param {Object} options - Filter options including date range
     * @return {Object} Dashboard overview data
     */
    getDashboardData: function(options = {}) {
      try {
        // Get filtered metrics data
        const metrics = this.getMetricsData(options);
        
        if (metrics.length === 0) {
          return {
            totalRecords: 0,
            teamPerformance: {},
            memberPerformance: [],
            trends: {},
            belowGoalMembers: []
          };
        }
        
        // Calculate team performance (averages)
        const teamPerformance = this.getTeamPerformanceSummary(options);
        
        // Get individual performance for all team members
        const memberPerformance = [];
        const teamMembers = {};
        
        // Group metrics by team member
        metrics.forEach(metric => {
          if (!teamMembers[metric.teamMemberEmail]) {
            teamMembers[metric.teamMemberEmail] = {
              email: metric.teamMemberEmail,
              name: metric.teamMemberName,
              metrics: []
            };
          }
          
          teamMembers[metric.teamMemberEmail].metrics.push(metric);
        });
        
        // Calculate performance for each team member
        Object.values(teamMembers).forEach(member => {
          const performance = this.getTeamMemberPerformance(member.email, {
            startDate: options.startDate,
            endDate: options.endDate,
            metrics: member.metrics // Pass pre-loaded metrics to avoid re-fetching
          });
          
          memberPerformance.push({
            email: member.email,
            name: member.name,
            performance: performance
          });
        });
        
        // Get trend data for key metrics
        const trendOptions = { 
          startDate: options.startDate, 
          endDate: options.endDate 
        };
        
        const answerRateTrend = this.getMetricsTrend('answerRate', 'weekly', trendOptions);
        const talkTimeTrend = this.getMetricsTrend('averageTalkTime', 'weekly', trendOptions);
        const onQueueTrend = this.getMetricsTrend('onQueuePercentage', 'weekly', trendOptions);
        
        // Get team members performing below goals
        const belowGoalMembers = this.identifyUnderperformingMembers(options);
        
        return {
          totalRecords: metrics.length,
          teamPerformance: teamPerformance,
          memberPerformance: memberPerformance,
          trends: {
            answerRate: answerRateTrend,
            averageTalkTime: talkTimeTrend,
            onQueuePercentage: onQueueTrend
          },
          belowGoalMembers: belowGoalMembers
        };
      } catch (e) {
        logMetricsError('getDashboardData', e.toString(), { options: JSON.stringify(options) });
        return {
          totalRecords: 0,
          teamPerformance: {},
          memberPerformance: [],
          trends: {},
          belowGoalMembers: []
        };
      }
    },
    
    /**
     * Gets team performance summary
     * @param {Object} options - Filter options
     * @return {Object} Team performance metrics
     */
    getTeamPerformanceSummary: function(options = {}) {
      try {
        // Get filtered metrics
        const metrics = this.getMetricsData(options);
        
        if (metrics.length === 0) {
          return {
            totalCalls: {
              offered: 0,
              accepted: 0
            },
            averages: {
              answerRate: 0,
              averageTalkTime: 0,
              acwPercentage: 0,
              onQueuePercentage: 0,
              offQueuePercentage: 0,
              interactingTime: 0,
              interactingPercentage: 0
            },
            goals: {
              answerRateGoalMet: false,
              talkTimeGoalMet: false,
              acwGoalMet: false,
              onQueueGoalMet: false,
              interactingTimeGoalMet: false
            }
          };
        }
        
        // Calculate totals and averages
        let totalCallsOffered = 0;
        let totalCallsAccepted = 0;
        let totalAnswerRate = 0;
        let totalAverageTalkTime = 0;
        let totalAcwPercentage = 0;
        let totalOnQueuePercentage = 0;
        let totalOffQueuePercentage = 0;
        let totalInteractingTime = 0;
        let totalInteractingPercentage = 0;
        
        metrics.forEach(metric => {
          totalCallsOffered += metric.callsOffered || 0;
          totalCallsAccepted += metric.callsAccepted || 0;
          totalAnswerRate += metric.answerRate || 0;
          totalAverageTalkTime += metric.averageTalkTime || 0;
          totalAcwPercentage += metric.acwPercentage || 0;
          totalOnQueuePercentage += metric.onQueuePercentage || 0;
          totalOffQueuePercentage += metric.offQueuePercentage || 0;
          totalInteractingTime += metric.interactingTime || 0;
          totalInteractingPercentage += metric.interactingPercentage || 0;
        });
        
        // Calculate averages
        const count = metrics.length;
        const answerRate = count > 0 ? totalAnswerRate / count : 0;
        const averageTalkTime = count > 0 ? totalAverageTalkTime / count : 0;
        const acwPercentage = count > 0 ? totalAcwPercentage / count : 0;
        const onQueuePercentage = count > 0 ? totalOnQueuePercentage / count : 0;
        const offQueuePercentage = count > 0 ? totalOffQueuePercentage / count : 0;
        const interactingTime = count > 0 ? totalInteractingTime / count : 0;
        const interactingPercentage = count > 0 ? totalInteractingPercentage / count : 0;
        
        // Check goals
        const goals = DEFAULT_METRIC_GOALS;
        const answerRateGoalMet = answerRate >= goals.answerRate.min;
        const talkTimeGoalMet = averageTalkTime >= goals.averageTalkTime.min && averageTalkTime <= goals.averageTalkTime.max;
        const acwGoalMet = acwPercentage <= goals.acwPercentage.max;
        const onQueueGoalMet = onQueuePercentage >= goals.onQueuePercentage.min;
        const interactingTimeGoalMet = interactingTime >= goals.interactingTime.min && 
                                      interactingTime <= goals.interactingTime.max && 
                                      interactingPercentage >= 50;
        
        return {
          totalCalls: {
            offered: totalCallsOffered,
            accepted: totalCallsAccepted
          },
          averages: {
            answerRate: answerRate,
            averageTalkTime: averageTalkTime,
            acwPercentage: acwPercentage,
            onQueuePercentage: onQueuePercentage,
            offQueuePercentage: offQueuePercentage,
            interactingTime: interactingTime,
            interactingPercentage: interactingPercentage
          },
          goals: {
            answerRateGoalMet: answerRateGoalMet,
            talkTimeGoalMet: talkTimeGoalMet,
            acwGoalMet: acwGoalMet,
            onQueueGoalMet: onQueueGoalMet,
            interactingTimeGoalMet: interactingTimeGoalMet
          }
        };
      } catch (e) {
        logMetricsError('getTeamPerformanceSummary', e.toString(), { options: JSON.stringify(options) });
        return {
          totalCalls: { offered: 0, accepted: 0 },
          averages: {},
          goals: {}
        };
      }
    },
    
    /**
     * Gets individual team member performance 
     * @param {String} teamMemberEmail - Team member email
     * @param {Object} options - Filter options
     * @return {Object} Individual performance metrics
     */
    getTeamMemberPerformance: function(teamMemberEmail, options = {}) {
      try {
        if (!teamMemberEmail) {
          return {
            metrics: {},
            goals: {},
            trends: {}
          };
        }
        
        // Get metrics for this team member
        let metrics;
        if (options.metrics && Array.isArray(options.metrics)) {
          // Use pre-loaded metrics if provided
          metrics = options.metrics;
        } else {
          // Otherwise load from data source
          metrics = this.getMetricsData({
            teamMemberEmail: teamMemberEmail,
            startDate: options.startDate,
            endDate: options.endDate
          });
        }
        
        if (metrics.length === 0) {
          return {
            metrics: {},
            goals: {},
            trends: {}
          };
        }
        
        // Calculate averages
        let totalCallsOffered = 0;
        let totalCallsAccepted = 0;
        let totalAnswerRate = 0;
        let totalAverageTalkTime = 0;
        let totalAcwPercentage = 0;
        let totalOnQueuePercentage = 0;
        let totalOffQueuePercentage = 0;
        let totalInteractingTime = 0;
        let totalInteractingPercentage = 0;
        
        metrics.forEach(metric => {
          totalCallsOffered += metric.callsOffered || 0;
          totalCallsAccepted += metric.callsAccepted || 0;
          totalAnswerRate += metric.answerRate || 0;
          totalAverageTalkTime += metric.averageTalkTime || 0;
          totalAcwPercentage += metric.acwPercentage || 0;
          totalOnQueuePercentage += metric.onQueuePercentage || 0;
          totalOffQueuePercentage += metric.offQueuePercentage || 0;
          totalInteractingTime += metric.interactingTime || 0;
          totalInteractingPercentage += metric.interactingPercentage || 0;
        });
        
        const count = metrics.length;
        const answerRate = count > 0 ? totalAnswerRate / count : 0;
        const averageTalkTime = count > 0 ? totalAverageTalkTime / count : 0;
        const acwPercentage = count > 0 ? totalAcwPercentage / count : 0;
        const onQueuePercentage = count > 0 ? totalOnQueuePercentage / count : 0;
        const offQueuePercentage = count > 0 ? totalOffQueuePercentage / count : 0;
        const interactingTime = count > 0 ? totalInteractingTime / count : 0;
        const interactingPercentage = count > 0 ? totalInteractingPercentage / count : 0;
        
        // Check goals
        const goals = DEFAULT_METRIC_GOALS;
        const answerRateGoalMet = answerRate >= goals.answerRate.min;
        const talkTimeGoalMet = averageTalkTime >= goals.averageTalkTime.min && averageTalkTime <= goals.averageTalkTime.max;
        const acwGoalMet = acwPercentage <= goals.acwPercentage.max;
        const onQueueGoalMet = onQueuePercentage >= goals.onQueuePercentage.min;
        const interactingTimeGoalMet = interactingTime >= goals.interactingTime.min && 
                                      interactingTime <= goals.interactingTime.max && 
                                      interactingPercentage >= 50;
        
        // Get trend data
        // Sort metrics by date
        metrics.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Create trend data (weekly or monthly depending on date range)
        const trendData = {};
        const isLongDateRange = options.startDate && options.endDate && 
                               ((options.endDate - options.startDate) / (1000 * 60 * 60 * 24) > 90);
        
        const interval = isLongDateRange ? 'monthly' : 'weekly';
        
        // Build trend data structure
        metrics.forEach(metric => {
          const date = new Date(metric.date);
          let key;
          
          if (interval === 'monthly') {
            key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          } else {
            // Weekly - use ISO week
            const weekNumber = Math.ceil((((date - new Date(date.getFullYear(), 0, 1)) / 86400000) + 1) / 7);
            key = `${date.getFullYear()}-W${String(weekNumber).padStart(2, '0')}`;
          }
          
          if (!trendData[key]) {
            trendData[key] = {
              period: key,
              label: interval === 'monthly' ? 
                     `${date.toLocaleString('default', { month: 'short' })} ${date.getFullYear()}` : 
                     `Week ${key.split('-W')[1]}`,
              metrics: {
                answerRate: [],
                averageTalkTime: [],
                acwPercentage: [],
                onQueuePercentage: [],
                interactingTime: []
              }
            };
          }
          
          trendData[key].metrics.answerRate.push(metric.answerRate || 0);
          trendData[key].metrics.averageTalkTime.push(metric.averageTalkTime || 0);
          trendData[key].metrics.acwPercentage.push(metric.acwPercentage || 0);
          trendData[key].metrics.onQueuePercentage.push(metric.onQueuePercentage || 0);
          trendData[key].metrics.interactingTime.push(metric.interactingTime || 0);
        });
        
        // Calculate averages for each period
        Object.values(trendData).forEach(period => {
          Object.keys(period.metrics).forEach(metricKey => {
            const values = period.metrics[metricKey];
            period.metrics[metricKey] = values.length > 0 ? 
              values.reduce((sum, val) => sum + val, 0) / values.length : 0;
          });
        });
        
        const sortedTrends = Object.values(trendData).sort((a, b) => a.period.localeCompare(b.period));
        
        return {
          metrics: {
            answerRate: answerRate,
            averageTalkTime: averageTalkTime,
            acwPercentage: acwPercentage,
            onQueuePercentage: onQueuePercentage,
            offQueuePercentage: offQueuePercentage,
            interactingTime: interactingTime,
            interactingPercentage: interactingPercentage,
            totalCallsOffered: totalCallsOffered,
            totalCallsAccepted: totalCallsAccepted
          },
          goals: {
            answerRateGoalMet: answerRateGoalMet,
            talkTimeGoalMet: talkTimeGoalMet,
            acwGoalMet: acwGoalMet,
            onQueueGoalMet: onQueueGoalMet,
            interactingTimeGoalMet: interactingTimeGoalMet
          },
          trends: sortedTrends
        };
      } catch (e) {
        logMetricsError('getTeamMemberPerformance', e.toString(), { 
          teamMemberEmail: teamMemberEmail, 
          options: JSON.stringify(options) 
        });
        return {
          metrics: {},
          goals: {},
          trends: {}
        };
      }
    },
    
    /**
     * Gets trend data for charts and graphs
     * @param {String} metricType - Type of metric to analyze
     * @param {String} interval - Time interval (daily, weekly, monthly)
     * @param {Object} options - Additional filter options
     * @return {Object} Trend data for charts
     */
    getMetricsTrend: function(metricType, interval, options = {}) {
      try {
        // Get metrics data
        const metrics = this.getMetricsData(options);
        
        if (metrics.length === 0 || !metricType) {
          return {
            labels: [],
            values: [],
            interval: interval
          };
        }
        
        // Sort metrics by date
        metrics.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Group by interval
        const groups = {};
        
        metrics.forEach(metric => {
          const date = new Date(metric.date);
          let key;
          
          if (interval === 'daily') {
            key = Utilities.formatDate(date, Session.getScriptTimeZone(), 'yyyy-MM-dd');
          } else if (interval === 'weekly') {
            // Use ISO week
            const weekNumber = Math.ceil((((date - new Date(date.getFullYear(), 0, 1)) / 86400000) + 1) / 7);
            key = `${date.getFullYear()}-W${String(weekNumber).padStart(2, '0')}`;
          } else if (interval === 'monthly') {
            key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          } else if (interval === 'quarterly') {
            const quarter = Math.floor(date.getMonth() / 3) + 1;
            key = `${date.getFullYear()}-Q${quarter}`;
          } else {
            // Default to monthly
            key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          }
          
          if (!groups[key]) {
            groups[key] = {
              key: key,
              values: [],
              label: this.formatIntervalLabel_(key, interval)
            };
          }
          
          // Add metric value if it exists
          if (metric[metricType] !== undefined) {
            groups[key].values.push(metric[metricType]);
          }
        });
        
        // Calculate averages for each interval
        const result = {
          labels: [],
          values: [],
          interval: interval
        };
        
        // Sort keys in chronological order
        const sortedKeys = Object.keys(groups).sort();
        
        sortedKeys.forEach(key => {
          const group = groups[key];
          const values = group.values;
          
          if (values.length > 0) {
            // Calculate average
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
            
            result.labels.push(group.label);
            result.values.push(avg);
          }
        });
        
        return result;
      } catch (e) {
        logMetricsError('getMetricsTrend', e.toString(), { 
          metricType: metricType, 
          interval: interval, 
          options: JSON.stringify(options) 
        });
        return {
          labels: [],
          values: [],
          interval: interval
        };
      }
    },
    
    /**
     * Format an interval key into a human-readable label
     * @param {String} key - The interval key
     * @param {String} interval - The interval type
     * @return {String} Formatted label
     */
    formatIntervalLabel_: function(key, interval) {
      try {
        if (interval === 'daily') {
          // Format: YYYY-MM-DD to "MMM DD"
          const parts = key.split('-');
          const date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
          return Utilities.formatDate(date, Session.getScriptTimeZone(), 'MMM dd');
        } else if (interval === 'weekly') {
          // Format: YYYY-WNN to "Week NN"
          return `Week ${key.split('-W')[1]}`;
        } else if (interval === 'monthly') {
          // Format: YYYY-MM to "MMM YYYY"
          const parts = key.split('-');
          const date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, 1);
          return Utilities.formatDate(date, Session.getScriptTimeZone(), 'MMM yyyy');
        } else if (interval === 'quarterly') {
          // Format: YYYY-QN to "QQQQ YYYY"
          const parts = key.split('-Q');
          return `Q${parts[1]} ${parts[0]}`;
        } else {
          return key;
        }
      } catch (e) {
        return key;
      }
    },
    
    /**
     * Identifies team members performing below goals
     * @param {Object} options - Filter options
     * @return {Array} List of team members below performance thresholds
     */
    identifyUnderperformingMembers: function(options = {}) {
      try {
        // Get metrics for the specified period
        const metrics = this.getMetricsData(options);
        
        if (metrics.length === 0) {
          return [];
        }
        
        // Group metrics by team member
        const teamMembers = {};
        
        metrics.forEach(metric => {
          if (!teamMembers[metric.teamMemberEmail]) {
            teamMembers[metric.teamMemberEmail] = {
              email: metric.teamMemberEmail,
              name: metric.teamMemberName,
              metrics: []
            };
          }
          
          teamMembers[metric.teamMemberEmail].metrics.push(metric);
        });
        
        // Check performance against goals for each team member
        const underperforming = [];
        const goals = DEFAULT_METRIC_GOALS;
        
        Object.values(teamMembers).forEach(member => {
          // Skip members with fewer than 3 data points (not enough data)
          if (member.metrics.length < 3) {
            return;
          }
          
          // Calculate averages for key metrics
          let totalAnswerRate = 0;
          let totalAverageTalkTime = 0;
          let totalAcwPercentage = 0;
          let totalOnQueuePercentage = 0;
          let totalInteractingTime = 0;
          let totalInteractingPercentage = 0;
          
          member.metrics.forEach(metric => {
            totalAnswerRate += metric.answerRate || 0;
            totalAverageTalkTime += metric.averageTalkTime || 0;
            totalAcwPercentage += metric.acwPercentage || 0;
            totalOnQueuePercentage += metric.onQueuePercentage || 0;
            totalInteractingTime += metric.interactingTime || 0;
            totalInteractingPercentage += metric.interactingPercentage || 0;
          });
          
          const count = member.metrics.length;
          const answerRate = totalAnswerRate / count;
          const averageTalkTime = totalAverageTalkTime / count;
          const acwPercentage = totalAcwPercentage / count;
          const onQueuePercentage = totalOnQueuePercentage / count;
          const interactingTime = totalInteractingTime / count;
          const interactingPercentage = totalInteractingPercentage / count;
          
          // Check against goals and add issues to the result
          if (answerRate < goals.answerRate.min) {
            underperforming.push({
              teamMemberEmail: member.email,
              teamMemberName: member.name,
              metric: 'answerRate',
              description: 'Answer Rate',
              value: answerRate,
              goal: `≥ ${goals.answerRate.min}%`,
              difference: goals.answerRate.min - answerRate
            });
          }
          
          if (averageTalkTime < goals.averageTalkTime.min || averageTalkTime > goals.averageTalkTime.max) {
            underperforming.push({
              teamMemberEmail: member.email,
              teamMemberName: member.name,
              metric: 'averageTalkTime',
              description: 'Average Talk Time',
              value: averageTalkTime,
              goal: `${goals.averageTalkTime.min}-${goals.averageTalkTime.max} min`,
              difference: averageTalkTime < goals.averageTalkTime.min ? 
                          goals.averageTalkTime.min - averageTalkTime : 
                          averageTalkTime - goals.averageTalkTime.max
            });
          }
          
          if (acwPercentage > goals.acwPercentage.max) {
            underperforming.push({
              teamMemberEmail: member.email,
              teamMemberName: member.name,
              metric: 'acwPercentage',
              description: 'ACW Time',
              value: acwPercentage,
              goal: `≤ ${goals.acwPercentage.max} min`,
              difference: acwPercentage - goals.acwPercentage.max
            });
          }
          
          if (onQueuePercentage < goals.onQueuePercentage.min) {
            underperforming.push({
              teamMemberEmail: member.email,
              teamMemberName: member.name,
              metric: 'onQueuePercentage',
              description: 'On Queue Percentage',
              value: onQueuePercentage,
              goal: `≥ ${goals.onQueuePercentage.min}%`,
              difference: goals.onQueuePercentage.min - onQueuePercentage
            });
          }
          
          if (interactingTime < goals.interactingTime.min || 
              interactingTime > goals.interactingTime.max || 
              interactingPercentage < 50) {
            underperforming.push({
              teamMemberEmail: member.email,
              teamMemberName: member.name,
              metric: 'interactingTime',
              description: 'Interacting Time',
              value: interactingTime,
              percentageValue: interactingPercentage,
              goal: `${goals.interactingTime.min}-${goals.interactingTime.max} hrs; ≥ 50%`,
              difference: interactingTime < goals.interactingTime.min ? 
                          goals.interactingTime.min - interactingTime : 
                          (interactingTime > goals.interactingTime.max ? 
                           interactingTime - goals.interactingTime.max : 
                           50 - interactingPercentage)
            });
          }
        });
        
        // Sort by team member name and then by metric
        underperforming.sort((a, b) => {
          if (a.teamMemberName === b.teamMemberName) {
            return a.description.localeCompare(b.description);
          }
          return a.teamMemberName.localeCompare(b.teamMemberName);
        });
        
        return underperforming;
      } catch (e) {
        logMetricsError('identifyUnderperformingMembers', e.toString(), { options: JSON.stringify(options) });
        return [];
      }
    },
    
    /**
     * Gets performance comparison between time periods
     * @param {String} metricType - Metric to compare
     * @param {Object} period1 - First period details
     * @param {Object} period2 - Second period details
     * @return {Object} Comparison results
     */
    getPerformanceComparison: function(metricType, period1, period2) {
      try {
        if (!metricType || !period1 || !period2) {
          return {
            period1: { label: '', value: 0 },
            period2: { label: '', value: 0 },
            difference: 0,
            percentChange: 0
          };
        }
        
        // Get metrics for each period
        const metrics1 = this.getMetricsData({
          startDate: period1.startDate,
          endDate: period1.endDate,
          teamMemberEmail: period1.teamMemberEmail
        });
        
        const metrics2 = this.getMetricsData({
          startDate: period2.startDate,
          endDate: period2.endDate,
          teamMemberEmail: period2.teamMemberEmail
        });
        
        // Calculate averages for the specified metric
        let sum1 = 0;
        let count1 = 0;
        metrics1.forEach(metric => {
          if (metric[metricType] !== undefined) {
            sum1 += metric[metricType];
            count1++;
          }
        });
        
        let sum2 = 0;
        let count2 = 0;
        metrics2.forEach(metric => {
          if (metric[metricType] !== undefined) {
            sum2 += metric[metricType];
            count2++;
          }
        });
        
        const value1 = count1 > 0 ? sum1 / count1 : 0;
        const value2 = count2 > 0 ? sum2 / count2 : 0;
        
        // Calculate differences
        const difference = value2 - value1;
        const percentChange = value1 !== 0 ? (difference / value1) * 100 : 0;
        
        return {
          period1: {
            label: period1.label || this.getDateRangeDescription_(period1.startDate, period1.endDate),
            value: value1,
            count: count1
          },
          period2: {
            label: period2.label || this.getDateRangeDescription_(period2.startDate, period2.endDate),
            value: value2,
            count: count2
          },
          difference: difference,
          percentChange: percentChange,
          improved: difference > 0 ? true : false // Note: For some metrics (like ACW), lower is better
        };
      } catch (e) {
        logMetricsError('getPerformanceComparison', e.toString(), {
          metricType: metricType,
          period1: JSON.stringify(period1),
          period2: JSON.stringify(period2)
        });
        return {
          period1: { label: '', value: 0 },
          period2: { label: '', value: 0 },
          difference: 0,
          percentChange: 0
        };
      }
    },
    
    /**
     * Gets metrics report data with flexible filtering
     * @param {String} reportType - Type of report to generate
     * @param {Object} options - Filter options
     * @return {Object} Report data
     */
    getMetricsReport: function(reportType, options = {}) {
      try {
        // Different report types need different data structures
        if (reportType === 'team_summary') {
          // Get team performance data
          const teamPerformance = this.getTeamPerformanceSummary(options);
          
          // Get underperforming team members
          const belowGoal = this.identifyUnderperformingMembers(options);
          
          return {
            reportType: 'team_summary',
            dateRange: this.getDateRangeDescription_(options.startDate, options.endDate),
            summary: {
              callsOffered: teamPerformance.totalCalls.offered,
              callsAccepted: teamPerformance.totalCalls.accepted,
              answerRate: teamPerformance.averages.answerRate,
              averageTalkTime: teamPerformance.averages.averageTalkTime,
              acwPercentage: teamPerformance.averages.acwPercentage,
              onQueuePercentage: teamPerformance.averages.onQueuePercentage,
              offQueuePercentage: teamPerformance.averages.offQueuePercentage,
              interactingTime: teamPerformance.averages.interactingTime,
              interactingPercentage: teamPerformance.averages.interactingPercentage
            },
            goals: teamPerformance.goals,
            belowGoal: belowGoal
          };
        } else if (reportType === 'individual_performance') {
          // Get individual team member metrics
          if (!options.teamMemberEmail) {
            return {
              success: false,
              message: 'Team member email is required for individual performance reports'
            };
          }
          
          // Get team member info
          let teamMemberName = '';
          try {
            const teamMembers = getTeamMembers();
            const member = teamMembers.find(m => m.email === options.teamMemberEmail);
            if (member) {
              teamMemberName = member.name || member.firstName + ' ' + member.lastName;
            }
          } catch (e) {
            // Silently handle team member lookup failure
            teamMemberName = options.teamMemberEmail.split('@')[0];
          }
          
          // Get performance metrics
          const performance = this.getTeamMemberPerformance(options.teamMemberEmail, options);
          
          // Get raw metrics data
          const metrics = this.getMetricsData({
            teamMemberEmail: options.teamMemberEmail,
            startDate: options.startDate,
            endDate: options.endDate
          });
          
          // Calculate volume totals
          let totalCallsOffered = 0;
          let totalCallsAccepted = 0;
          let totalInteractingTime = 0;
          
          metrics.forEach(metric => {
            totalCallsOffered += metric.callsOffered || 0;
            totalCallsAccepted += metric.callsAccepted || 0;
            totalInteractingTime += metric.interactingTime || 0;
          });
          
          return {
            reportType: 'individual_performance',
            dateRange: this.getDateRangeDescription_(options.startDate, options.endDate),
            teamMemberEmail: options.teamMemberEmail,
            teamMemberName: teamMemberName,
            metrics: performance.metrics,
            goals: performance.goals,
            trends: performance.trends,
            volume: {
              callsOffered: totalCallsOffered,
              callsAccepted: totalCallsAccepted,
              totalInteractingTime: totalInteractingTime
            },
            rawData: options.includeRawData ? metrics : []
          };
        } else if (reportType === 'trend_analysis') {
          // Get trend data for all key metrics
          const trendOptions = { 
            startDate: options.startDate, 
            endDate: options.endDate,
            teamMemberEmail: options.teamMemberEmail
          };
          
          const interval = options.interval || 'weekly';
          
          const answerRateTrend = this.getMetricsTrend('answerRate', interval, trendOptions);
          const talkTimeTrend = this.getMetricsTrend('averageTalkTime', interval, trendOptions);
          const acwTrend = this.getMetricsTrend('acwPercentage', interval, trendOptions);
          const onQueueTrend = this.getMetricsTrend('onQueuePercentage', interval, trendOptions);
          const interactingTimeTrend = this.getMetricsTrend('interactingTime', interval, trendOptions);
          
          return {
            reportType: 'trend_analysis',
            dateRange: this.getDateRangeDescription_(options.startDate, options.endDate),
            teamMemberEmail: options.teamMemberEmail,
            interval: interval,
            trends: {
              answerRate: answerRateTrend,
              averageTalkTime: talkTimeTrend,
              acwPercentage: acwTrend,
              onQueuePercentage: onQueueTrend,
              interactingTime: interactingTimeTrend
            }
          };
        } else {
          // Generic report with basic metrics
          const metrics = this.getMetricsData(options);
          
          return {
            reportType: 'generic',
            dateRange: this.getDateRangeDescription_(options.startDate, options.endDate),
            count: metrics.length,
            data: metrics
          };
        }
      } catch (e) {
        logMetricsError('getMetricsReport', e.toString(), {
          reportType: reportType,
          options: JSON.stringify(options)
        });
        return {
          success: false,
          message: 'Error generating metrics report: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets metrics goals and thresholds
     * @return {Object} Goals for different metrics
     */
    getMetricsGoals: function() {
      try {
        // Return the default goals or custom ones if configured
        return DEFAULT_METRIC_GOALS;
      } catch (e) {
        logMetricsError('getMetricsGoals', e.toString());
        return DEFAULT_METRIC_GOALS;
      }
    },
    
    /**
     * Calculates goal achievement percentages
     * @param {Object} metrics - Metrics data
     * @return {Object} Goal achievement percentages
     */
    calculateGoalAchievement: function(metrics) {
      try {
        const goals = this.getMetricsGoals();
        const result = {};
        
        // Answer Rate
        if (metrics.answerRate !== undefined) {
          const answerRate = metrics.answerRate;
          result.answerRate = {
            achieved: answerRate >= goals.answerRate.min,
            percentage: goals.answerRate.min > 0 ? 
              Math.min(100, (answerRate / goals.answerRate.min) * 100) : 0
          };
        }
        
        // Average Talk Time
        if (metrics.averageTalkTime !== undefined) {
          const talkTime = metrics.averageTalkTime;
          const inRange = talkTime >= goals.averageTalkTime.min && talkTime <= goals.averageTalkTime.max;
          let percentage;
          
          if (talkTime < goals.averageTalkTime.min) {
            percentage = (talkTime / goals.averageTalkTime.min) * 100;
          } else if (talkTime > goals.averageTalkTime.max) {
            percentage = 100 - ((talkTime - goals.averageTalkTime.max) / goals.averageTalkTime.max) * 100;
            percentage = Math.max(0, percentage); // Ensure not negative
          } else {
            percentage = 100;
          }
          
          result.averageTalkTime = {
            achieved: inRange,
            percentage: percentage
          };
        }
        
        // ACW Percentage
        if (metrics.acwPercentage !== undefined) {
          const acw = metrics.acwPercentage;
          result.acwPercentage = {
            achieved: acw <= goals.acwPercentage.max,
            percentage: acw <= goals.acwPercentage.max ? 
              100 : 100 - ((acw - goals.acwPercentage.max) / goals.acwPercentage.max) * 100
          };
          
          // Ensure percentage is not negative
          if (result.acwPercentage.percentage < 0) {
            result.acwPercentage.percentage = 0;
          }
        }
        
        // On Queue Percentage
        if (metrics.onQueuePercentage !== undefined) {
          const onQueue = metrics.onQueuePercentage;
          result.onQueuePercentage = {
            achieved: onQueue >= goals.onQueuePercentage.min,
            percentage: goals.onQueuePercentage.min > 0 ? 
              Math.min(100, (onQueue / goals.onQueuePercentage.min) * 100) : 0
          };
        }
        
        // Interacting Time
        if (metrics.interactingTime !== undefined && metrics.interactingPercentage !== undefined) {
          const time = metrics.interactingTime;
          const percentage = metrics.interactingPercentage;
          
          const inTimeRange = time >= goals.interactingTime.min && time <= goals.interactingTime.max;
          const meetingPercentage = percentage >= 50;
          
          // Calculate percentage for time range
          let timeRangePercentage;
          if (time < goals.interactingTime.min) {
            timeRangePercentage = (time / goals.interactingTime.min) * 100;
          } else if (time > goals.interactingTime.max) {
            timeRangePercentage = 100 - ((time - goals.interactingTime.max) / goals.interactingTime.max) * 100;
            timeRangePercentage = Math.max(0, timeRangePercentage);
          } else {
            timeRangePercentage = 100;
          }
          
          // Calculate percentage for the 50% requirement
          const percentageAchievement = percentage >= 50 ? 100 : (percentage / 50) * 100;
          
          // Combine both aspects (time range and percentage)
          const combinedPercentage = (timeRangePercentage + percentageAchievement) / 2;
          
          result.interactingTime = {
            achieved: inTimeRange && meetingPercentage,
            percentage: combinedPercentage
          };
        }
        
        return result;
      } catch (e) {
        logMetricsError('calculateGoalAchievement', e.toString(), { metrics: JSON.stringify(metrics) });
        return {};
      }
    },
    
    /**
     * Gets metrics summary statistics
     * @param {Array} metricsData - Array of metrics data
     * @return {Object} Summary statistics
     */
    getMetricsSummaryStats: function(metricsData) {
      try {
        if (!metricsData || !Array.isArray(metricsData) || metricsData.length === 0) {
          return {
            count: 0,
            averages: {},
            totals: {},
            min: {},
            max: {}
          };
        }
        
        // Define metrics to summarize
        const metricFields = [
          'callsOffered', 'callsAccepted', 'answerRate', 'averageTalkTime',
          'acwPercentage', 'onQueuePercentage', 'interactingTime', 'interactingPercentage'
        ];
        
        // Initialize objects
        const sums = {};
        const min = {};
        const max = {};
        const count = metricsData.length;
        
        metricFields.forEach(field => {
          sums[field] = 0;
          min[field] = Number.MAX_VALUE;
          max[field] = Number.MIN_VALUE;
        });
        
        // Calculate sums, min, and max
        metricsData.forEach(metric => {
          metricFields.forEach(field => {
            if (metric[field] !== undefined) {
              sums[field] += metric[field];
              min[field] = Math.min(min[field], metric[field]);
              max[field] = Math.max(max[field], metric[field]);
            }
          });
        });
        
        // Calculate averages
        const averages = {};
        metricFields.forEach(field => {
          averages[field] = count > 0 ? sums[field] / count : 0;
        });
        
        // Clean up min/max for fields with no data
        metricFields.forEach(field => {
          if (min[field] === Number.MAX_VALUE) min[field] = 0;
          if (max[field] === Number.MIN_VALUE) max[field] = 0;
        });
        
        return {
          count: count,
          averages: averages,
          totals: sums,
          min: min,
          max: max
        };
      } catch (e) {
        logMetricsError('getMetricsSummaryStats', e.toString());
        return {
          count: 0,
          averages: {},
          totals: {},
          min: {},
          max: {}
        };
      }
    },
    
    /**
     * Exports metrics data to spreadsheet
     * @param {Object} options - Export options
     * @return {Object} Result with export URL
     */
    exportMetricsData: function(options = {}) {
      try {
        const exportName = options.exportName || 'Metrics Export';
        const format = options.format || 'spreadsheet';
        
        // Get metrics data
        const metrics = this.getMetricsData(options);
        
        if (metrics.length === 0) {
          return {
            success: false,
            message: 'No data found matching the specified criteria'
          };
        }
        
        // Create a spreadsheet for the export
        const ss = SpreadsheetApp.create(exportName);
        const sheet = ss.getActiveSheet();
        sheet.setName('Metrics Data');
        
        // Define columns for export
        const columns = [
          'ID', 'Date', 'Team Member', 'Calls Offered', 'Calls Accepted',
          'Answer Rate (%)', 'Average Talk Time (min)', 'ACW Time (min)',
          'On Queue (%)', 'Off Queue (%)', 'Interacting Time (hrs)', 'Interacting (%)',
          'Notes', 'Created By', 'Created Date', 'Last Updated'
        ];
        
        // Add headers
        sheet.appendRow(columns);
        sheet.getRange(1, 1, 1, columns.length).setFontWeight('bold').setBackground('#E8EAED');
        
        // Add data
        const rows = metrics.map(metric => [
          metric.id,
          metric.date,
          metric.teamMemberName,
          metric.callsOffered,
          metric.callsAccepted,
          metric.answerRate,
          metric.averageTalkTime,
          metric.acwPercentage,
          metric.onQueuePercentage,
          metric.offQueuePercentage,
          metric.interactingTime,
          metric.interactingPercentage,
          metric.notes,
          metric.createdBy,
          metric.createdDate,
          metric.lastUpdated
        ]);
        
        if (rows.length > 0) {
          sheet.getRange(2, 1, rows.length, columns.length).setValues(rows);
        }
        
        // Format columns
        // Date columns
        const dateColumns = [2, 15, 16]; // Date, Created Date, Last Updated
        dateColumns.forEach(col => {
          sheet.getRange(2, col, rows.length, 1).setNumberFormat('yyyy-mm-dd');
        });
        
        // Percentage columns
        const percentageColumns = [6, 9, 10, 12]; // Answer Rate, On Queue, Off Queue, Interacting
        percentageColumns.forEach(col => {
          sheet.getRange(2, col, rows.length, 1).setNumberFormat('0.00%');
        });
        
        // Number columns with decimal places
        const numberColumns = [7, 8, 11]; // Average Talk Time, ACW Time, Interacting Time
        numberColumns.forEach(col => {
          sheet.getRange(2, col, rows.length, 1).setNumberFormat('0.00');
        });
        
        // Integer columns
        const integerColumns = [4, 5]; // Calls Offered, Calls Accepted
        integerColumns.forEach(col => {
          sheet.getRange(2, col, rows.length, 1).setNumberFormat('0');
        });
        
        // Auto-resize columns
        for (let i = 1; i <= columns.length; i++) {
          sheet.autoResizeColumn(i);
        }
        
        // Add summary sheet
        const summarySheet = ss.insertSheet('Summary');
        
        // Add summary statistics
        const stats = this.getMetricsSummaryStats(metrics);
        
        summarySheet.appendRow(['Metrics Export Summary']);
        summarySheet.appendRow(['Generated: ' + new Date().toLocaleString()]);
        summarySheet.appendRow(['Date Range: ' + this.getDateRangeDescription_(options.startDate, options.endDate)]);
        summarySheet.appendRow(['Total Records: ' + metrics.length]);
        
        // Add team member breakdown if multiple team members
        const teamMembers = {};
        metrics.forEach(metric => {
          if (!teamMembers[metric.teamMemberEmail]) {
            teamMembers[metric.teamMemberEmail] = {
              name: metric.teamMemberName,
              count: 0
            };
          }
          teamMembers[metric.teamMemberEmail].count++;
        });
        
        if (Object.keys(teamMembers).length > 1) {
          summarySheet.appendRow(['']);
          summarySheet.appendRow(['Records by Team Member']);
          
          Object.values(teamMembers).forEach(member => {
            summarySheet.appendRow([member.name, member.count]);
          });
        }
        
        // Add averages table
        summarySheet.appendRow(['']);
        summarySheet.appendRow(['Metric Averages']);
        summarySheet.appendRow(['Answer Rate:', stats.averages.answerRate]);
        summarySheet.appendRow(['Average Talk Time:', stats.averages.averageTalkTime]);
        summarySheet.appendRow(['ACW Time:', stats.averages.acwPercentage]);
        summarySheet.appendRow(['On Queue Percentage:', stats.averages.onQueuePercentage]);
        summarySheet.appendRow(['Interacting Time:', stats.averages.interactingTime]);
        
        // Format summary sheet
        summarySheet.getRange('A1').setFontSize(16).setFontWeight('bold');
        summarySheet.getRange('A6').setFontWeight('bold');
        summarySheet.getRange('A9').setFontWeight('bold');
        
        // Record the export
        const exportData = {
          name: exportName,
          format: format,
          url: ss.getUrl(),
          recordCount: metrics.length,
          dateRange: this.getDateRangeDescription_(options.startDate, options.endDate)
        };
        
        recordExport_(exportData);
        
        return {
          success: true,
          message: 'Successfully exported ' + metrics.length + ' records to spreadsheet',
          url: ss.getUrl(),
          exportData: exportData
        };
      } catch (e) {
        logMetricsError('exportMetricsData', e.toString(), { options: JSON.stringify(options) });
        return {
          success: false,
          message: 'Error exporting metrics data: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets export history
     * @return {Array} Previous exports
     */
    getMetricsExportHistory: function() {
      try {
        const sheet = getMetricsHistorySheet_();
        const data = sheet.getDataRange().getValues();
        
        if (data.length <= 1) {
          return []; // Only header row exists
        }
        
        const headers = data[0];
        const exports = [];
        
        // Convert data to objects
        for (let i = 1; i < data.length; i++) {
          const exportItem = {};
          
          for (let j = 0; j < headers.length; j++) {
            exportItem[headers[j]] = data[i][j];
          }
          
          exports.push(exportItem);
        }
        
        // Sort by date (newest first)
        exports.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        return exports;
      } catch (e) {
        logMetricsError('getMetricsExportHistory', e.toString());
        return [];
      }
    },
    
    /**
     * Creates a PDF report of metrics
     * @param {Object} options - Report options
     * @return {Object} Result with PDF URL
     */
    createMetricsPdfReport: function(options = {}) {
      try {
        // This function requires the advanced service to be enabled
        const hasAdvancedService = (typeof DriveApp !== 'undefined') && 
                                  (typeof Utilities.formatString === 'function');
        
        if (!hasAdvancedService) {
          return {
            success: false,
            message: 'PDF export requires the Drive advanced service to be enabled'
          };
        }
        
        // Get report data
        const reportType = options.reportType || 'team_summary';
        const reportData = this.getMetricsReport(reportType, options);
        
        if (!reportData || reportData.success === false) {
          return {
            success: false,
            message: 'Failed to generate report data: ' + (reportData.message || 'Unknown error')
          };
        }
        
        // Create HTML for PDF
        let htmlContent = '';
        
        if (reportType === 'team_summary') {
          htmlContent = this.createTeamSummaryReportHtml_(reportData);
        } else if (reportType === 'individual_performance') {
          htmlContent = this.createIndividualPerformanceReportHtml_(reportData);
        } else if (reportType === 'trend_analysis') {
          htmlContent = this.createTrendAnalysisReportHtml_(reportData);
        } else {
          htmlContent = this.createGenericReportHtml_(reportData);
        }
        
        // Create temporary HTML file
        const reportName = options.reportName || `Metrics_Report_${reportType}_${new Date().toISOString().slice(0, 10)}`;
        const htmlFile = DriveApp.createFile(reportName + '.html', htmlContent, MimeType.HTML);
        
        // Convert to PDF
        const blob = htmlFile.getAs(MimeType.PDF);
        const pdfFile = DriveApp.createFile(blob);
        pdfFile.setName(reportName + '.pdf');
        
        // Delete temporary HTML file
        DriveApp.removeFile(htmlFile);
        
        return {
          success: true,
          message: 'PDF report created successfully',
          name: reportName,
          url: pdfFile.getUrl(),
          fileId: pdfFile.getId()
        };
      } catch (e) {
        logMetricsError('createMetricsPdfReport', e.toString(), { options: JSON.stringify(options) });
        return {
          success: false,
          message: 'Error creating PDF report: ' + e.toString()
        };
      }
    },
    
    /**
     * Creates HTML for a team summary report
     * @param {Object} data - Report data
     * @return {String} HTML content
     */
    createTeamSummaryReportHtml_: function(data) {
      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
            h1 { color: #4285f4; border-bottom: 1px solid #e0e0e0; padding-bottom: 10px; }
            h2 { color: #4285f4; margin-top: 20px; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; }
            th { background-color: #f5f5f5; text-align: left; padding: 8px; border-bottom: 2px solid #ddd; }
            td { padding: 8px; border-bottom: 1px solid #ddd; }
            .summary-box { background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 20px; }
            .metric-row { display: flex; margin-bottom: 10px; }
            .metric-label { font-weight: bold; width: 200px; }
            .goal-met { color: green; }
            .goal-not-met { color: red; }
            footer { margin-top: 30px; text-align: center; font-size: 12px; color: #888; }
          </style>
        </head>
        <body>
          <h1>Team Performance Summary</h1>
          <p>Date Range: ${data.dateRange}</p>
          
          <div class="summary-box">
            <h2>Key Metrics</h2>
            <table>
              <tr>
                <th>Metric</th>
                <th>Value</th>
                <th>Goal</th>
                <th>Status</th>
              </tr>
              <tr>
                <td>Answer Rate</td>
                <td>${data.summary.answerRate.toFixed(1)}%</td>
                <td>≥ 95%</td>
                <td class="${data.goals.answerRateGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.answerRateGoalMet ? '✓ Meeting Goal' : '✗ Below Goal'}
                </td>
              </tr>
              <tr>
                <td>Average Talk Time</td>
                <td>${data.summary.averageTalkTime.toFixed(1)} min</td>
                <td>15-20 min</td>
                <td class="${data.goals.talkTimeGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.talkTimeGoalMet ? '✓ Meeting Goal' : '✗ Outside Goal Range'}
                </td>
              </tr>
              <tr>
                <td>ACW Time</td>
                <td>${data.summary.acwPercentage.toFixed(1)} min</td>
                <td>≤ 5 min</td>
                <td class="${data.goals.acwGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.acwGoalMet ? '✓ Meeting Goal' : '✗ Above Goal'}
                </td>
              </tr>
              <tr>
                <td>On Queue Percentage</td>
                <td>${data.summary.onQueuePercentage.toFixed(1)}%</td>
                <td>≥ 65%</td>
                <td class="${data.goals.onQueueGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.onQueueGoalMet ? '✓ Meeting Goal' : '✗ Below Goal'}
                </td>
              </tr>
              <tr>
                <td>Interacting Time</td>
                <td>${data.summary.interactingTime.toFixed(1)} hrs (${data.summary.interactingPercentage.toFixed(1)}%)</td>
                <td>4-6 hrs; ≥ 50%</td>
                <td class="${data.goals.interactingTimeGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.interactingTimeGoalMet ? '✓ Meeting Goal' : '✗ Outside Goal Range'}
                </td>
              </tr>
            </table>
          </div>
          
          <div class="summary-box">
            <h2>Volume Summary</h2>
            <div class="metric-row">
              <div class="metric-label">Total Calls Offered:</div>
              <div>${data.summary.callsOffered}</div>
            </div>
            <div class="metric-row">
              <div class="metric-label">Total Calls Accepted:</div>
              <div>${data.summary.callsAccepted}</div>
            </div>
            <div class="metric-row">
              <div class="metric-label">Overall Answer Rate:</div>
              <div>${data.summary.answerRate.toFixed(1)}%</div>
            </div>
          </div>
          
          ${data.belowGoal && data.belowGoal.length > 0 ? `
            <div class="summary-box">
              <h2>Team Members Below Goals</h2>
              <table>
                <tr>
                  <th>Team Member</th>
                  <th>Metric</th>
                  <th>Current Value</th>
                  <th>Goal</th>
                </tr>
                ${data.belowGoal.map(member => `
                  <tr>
                    <td>${member.teamMemberName}</td>
                    <td>${member.description}</td>
                    <td>${typeof member.value === 'number' ? member.value.toFixed(1) : member.value} ${member.percentageValue ? `(${member.percentageValue.toFixed(1)}%)` : ''}</td>
                    <td>${member.goal}</td>
                  </tr>
                `).join('')}
              </table>
            </div>
          ` : ''}
          
          <footer>
            Report generated: ${new Date().toLocaleString()}
          </footer>
        </body>
        </html>
      `;
      
      return html;
    },
    
    /**
     * Creates HTML for an individual performance report
     * @param {Object} data - Report data
     * @return {String} HTML content
     */
    createIndividualPerformanceReportHtml_: function(data) {
      // Implementation for individual performance report HTML generator
      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
            h1 { color: #4285f4; border-bottom: 1px solid #e0e0e0; padding-bottom: 10px; }
            h2 { color: #4285f4; margin-top: 20px; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; }
            th { background-color: #f5f5f5; text-align: left; padding: 8px; border-bottom: 2px solid #ddd; }
            td { padding: 8px; border-bottom: 1px solid #ddd; }
            .summary-box { background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 20px; }
            .metric-row { display: flex; margin-bottom: 10px; }
            .metric-label { font-weight: bold; width: 200px; }
            .goal-met { color: green; }
            .goal-not-met { color: red; }
            footer { margin-top: 30px; text-align: center; font-size: 12px; color: #888; }
          </style>
        </head>
        <body>
          <h1>Individual Performance Report</h1>
          <h2>${data.teamMemberName}</h2>
          <p>Date Range: ${data.dateRange}</p>
          
          <div class="summary-box">
            <h2>Performance Metrics</h2>
            <table>
              <tr>
                <th>Metric</th>
                <th>Value</th>
                <th>Goal</th>
                <th>Status</th>
              </tr>
              <tr>
                <td>Answer Rate</td>
                <td>${data.metrics.answerRate.toFixed(1)}%</td>
                <td>≥ 95%</td>
                <td class="${data.goals.answerRateGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.answerRateGoalMet ? '✓ Meeting Goal' : '✗ Below Goal'}
                </td>
              </tr>
              <tr>
                <td>Average Talk Time</td>
                <td>${data.metrics.averageTalkTime.toFixed(1)} min</td>
                <td>15-20 min</td>
                <td class="${data.goals.talkTimeGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.talkTimeGoalMet ? '✓ Meeting Goal' : '✗ Outside Goal Range'}
                </td>
              </tr>
              <tr>
                <td>ACW Time</td>
                <td>${data.metrics.acwPercentage.toFixed(1)} min</td>
                <td>≤ 5 min</td>
                <td class="${data.goals.acwGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.acwGoalMet ? '✓ Meeting Goal' : '✗ Above Goal'}
                </td>
              </tr>
              <tr>
                <td>On Queue Percentage</td>
                <td>${data.metrics.onQueuePercentage.toFixed(1)}%</td>
                <td>≥ 65%</td>
                <td class="${data.goals.onQueueGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.onQueueGoalMet ? '✓ Meeting Goal' : '✗ Below Goal'}
                </td>
              </tr>
              <tr>
                <td>Interacting Time</td>
                <td>${data.metrics.interactingTime.toFixed(1)} hrs (${data.metrics.interactingPercentage.toFixed(1)}%)</td>
                <td>4-6 hrs; ≥ 50%</td>
                <td class="${data.goals.interactingTimeGoalMet ? 'goal-met' : 'goal-not-met'}">
                  ${data.goals.interactingTimeGoalMet ? '✓ Meeting Goal' : '✗ Outside Goal Range'}
                </td>
              </tr>
            </table>
          </div>
          
          <div class="summary-box">
            <h2>Volume Summary</h2>
            <div class="metric-row">
              <div class="metric-label">Total Calls Offered:</div>
              <div>${data.volume.callsOffered}</div>
            </div>
            <div class="metric-row">
              <div class="metric-label">Total Calls Accepted:</div>
              <div>${data.volume.callsAccepted}</div>
            </div>
            <div class="metric-row">
              <div class="metric-label">Total Interacting Time:</div>
              <div>${data.volume.totalInteractingTime.toFixed(1)} hrs</div>
            </div>
          </div>
          
          <footer>
            Report generated: ${new Date().toLocaleString()}
          </footer>
        </body>
        </html>
      `;
      
      return html;
    },
    
    /**
     * Creates HTML for a trend analysis report
     * @param {Object} data - Report data
     * @return {String} HTML content
     */
    createTrendAnalysisReportHtml_: function(data) {
      // Implementation omitted for brevity - would generate HTML for trend report
      return `<!DOCTYPE html>
              <html>
                <head>
                  <title>Trend Analysis Report</title>
                </head>
                <body>
                  <h1>Trend Analysis Report</h1>
                  <p>Date Range: ${data.dateRange}</p>
                  <p>This is a placeholder for the trend analysis report.</p>
                </body>
              </html>`;
    },
    
    /**
     * Creates HTML for a generic report
     * @param {Object} data - Report data
     * @return {String} HTML content
     */
    createGenericReportHtml_: function(data) {
      // Implementation omitted for brevity - would generate HTML for generic report
      return `<!DOCTYPE html>
              <html>
                <head>
                  <title>Metrics Report</title>
                </head>
                <body>
                  <h1>Metrics Report</h1>
                  <p>Date Range: ${data.dateRange}</p>
                  <p>Records: ${data.count}</p>
                </body>
              </html>`;
    },
    
    /**
     * Saves email report configuration
     * @param {Object} config - Email configuration
     * @return {Object} Result with success flag
     */
    saveMetricsEmailConfig: function(config) {
      try {
        const sheet = getMetricsEmailConfigSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        
        // Validate configuration
        if (!config.name) {
          return {
            success: false,
            message: 'Configuration name is required'
          };
        }
        
        if (!config.recipients || config.recipients.length === 0) {
          return {
            success: false,
            message: 'At least one recipient is required'
          };
        }
        
        if (!config.frequency) {
          return {
            success: false,
            message: 'Report frequency is required'
          };
        }
        
        // Generate ID if this is a new configuration
        if (!config.id) {
          config.id = createUniqueId_();
          config.createdDate = new Date();
          config.createdBy = Session.getActiveUser().getEmail();
          config.status = config.status || 'active';
        }
        
        // Set last updated timestamp
        config.lastUpdated = new Date();
        
        // Convert arrays to strings for storage
        if (Array.isArray(config.recipients)) {
          config.recipients = config.recipients.join(',');
        }
        
        if (Array.isArray(config.metrics)) {
          config.metrics = config.metrics.join(',');
        }
        
        // Find the row if configuration already exists
        let rowIndex = -1;
        if (config.id) {
          for (let i = 1; i < data.length; i++) {
            if (data[i][0] === config.id) {
              rowIndex = i + 1; // +1 because sheet rows are 1-indexed
              break;
            }
          }
        }
        
        // Create row array for sheet
        const rowData = [];
        headers.forEach(header => {
          rowData.push(config[header] !== undefined ? config[header] : '');
        });
        
        // Update or append record
        if (rowIndex > 0) {
          // Update existing record
          sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
        } else {
          // Append new record
          sheet.appendRow(rowData);
        }
        
        return {
          success: true,
          message: 'Email configuration saved successfully',
          configId: config.id
        };
      } catch (e) {
        logMetricsError('saveMetricsEmailConfig', e.toString(), { config: JSON.stringify(config) });
        return {
          success: false,
          message: 'Error saving email configuration: ' + e.toString()
        };
      }
    },
    
    /**
     * Gets email report configurations
     * @return {Array} Email configurations
     */
    getMetricsEmailConfigs: function() {
      try {
        const sheet = getMetricsEmailConfigSheet_();
        const data = sheet.getDataRange().getValues();
        
        if (data.length <= 1) {
          return []; // Only header row exists
        }
        
        const headers = data[0];
        const configs = [];
        
        // Convert data to objects
        for (let i = 1; i < data.length; i++) {
          const config = {};
          
          for (let j = 0; j < headers.length; j++) {
            config[headers[j]] = data[i][j];
          }
          
          // Convert string lists back to arrays
          if (config.recipients && typeof config.recipients === 'string') {
            config.recipients = config.recipients.split(',');
          }
          
          if (config.metrics && typeof config.metrics === 'string') {
            config.metrics = config.metrics.split(',');
          }
          
          configs.push(config);
        }
        
        return configs;
      } catch (e) {
        logMetricsError('getMetricsEmailConfigs', e.toString());
        return [];
      }
    },
    
    /**
     * Sends a metrics report email
     * @param {String} configId - Configuration ID
     * @param {Object} options - Additional options
     * @return {Object} Result with success flag
     */
    sendMetricsReportEmail: function(configId, options = {}) {
      try {
        // Get the email configuration
        const configs = this.getMetricsEmailConfigs();
        const config = configs.find(c => c.id === configId);
        
        if (!config) {
          return {
            success: false,
            message: 'Email configuration not found'
          };
        }
        
        // Check if config is active
        if (config.status !== 'active') {
          return {
            success: false,
            message: 'Email configuration is not active'
          };
        }
        
        // Get report data based on configuration
        const reportOptions = {
          reportType: config.reportType || 'team_summary',
          dateRangeType: config.dateRangeType || 'week',
          teamMemberEmail: config.teamMemberEmail || '',
          includeCharts: config.includeCharts === true
        };
        
        // Set date range based on the configuration
        const dateRange = this.getMetricsDateRange(reportOptions.dateRangeType);
        reportOptions.startDate = dateRange.startDate;
        reportOptions.endDate = dateRange.endDate;
        
        // Generate report data
        const reportData = this.getMetricsReport(reportOptions.reportType, reportOptions);
        
        if (!reportData || reportData.success === false) {
          return {
            success: false,
            message: 'Failed to generate report data: ' + (reportData.message || 'Unknown error')
          };
        }
        
        // Create email subject
        const subject = `Metrics Report: ${config.name} - ${dateRange.description}`;
        
        // Create email body
        const body = createMetricsEmailContent_(reportOptions.reportType, reportData);
        
        // Send the email
        GmailApp.sendEmail(
          config.recipients.join(','), 
          subject, 
          "This email requires HTML to view properly.", 
          { 
            htmlBody: body, 
            name: "Metrics Reporting System",
            replyTo: Session.getActiveUser().getEmail()
          }
        );
        
        // Update last sent timestamp
        config.lastSent = new Date();
        this.saveMetricsEmailConfig(config);
        
        return {
          success: true,
          message: 'Email sent successfully to ' + config.recipients.join(', ')
        };
      } catch (e) {
        logMetricsError('sendMetricsReportEmail', e.toString(), { configId, options: JSON.stringify(options) });
        return {
          success: false,
          message: 'Error sending email: ' + e.toString()
        };
      }
    },
    
    /**
     * Deletes an email configuration
     * @param {String} configId - Configuration ID to delete
     * @return {Boolean} Success flag
     */
    deleteMetricsEmailConfig: function(configId) {
      try {
        const sheet = getMetricsEmailConfigSheet_();
        const data = sheet.getDataRange().getValues();
        
        // Find the configuration by ID
        for (let i = 1; i < data.length; i++) {
          if (data[i][0] === configId) {
            sheet.deleteRow(i + 1); // +1 because i is 0-based and row indices are 1-based
            return true;
          }
        }
        
        return false; // Configuration not found
      } catch (e) {
        logMetricsError('deleteMetricsEmailConfig', e.toString(), { configId });
        return false;
      }
    },
    
    /**
     * Gets date range for metrics filtering
     * @param {String} rangeType - Type of range (day, week, month, etc.)
     * @param {Date} customStart - Custom start date
     * @param {Date} customEnd - Custom end date
     * @return {Object} Date range with descriptive label
     */
    getMetricsDateRange: function(rangeType, customStart, customEnd) {
      try {
        const now = new Date();
        let startDate, endDate, description;
        
        if (rangeType === 'custom' && customStart && customEnd) {
          startDate = new Date(customStart);
          endDate = new Date(customEnd);
          description = `${Utilities.formatDate(startDate, Session.getScriptTimeZone(), 'MMM d, yyyy')} - ${Utilities.formatDate(endDate, Session.getScriptTimeZone(), 'MMM d, yyyy')}`;
        } else if (rangeType === 'today') {
          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
          description = 'Today';
        } else if (rangeType === 'yesterday') {
          const yesterday = new Date(now);
          yesterday.setDate(yesterday.getDate() - 1);
          startDate = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
          endDate = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);
          description = 'Yesterday';
        } else if (rangeType === 'week') {
          // Current week (Sunday to Saturday)
          const day = now.getDay(); // 0 = Sunday, 6 = Saturday
          startDate = new Date(now);
          startDate.setDate(now.getDate() - day);
          startDate.setHours(0, 0, 0, 0);
          
          endDate = new Date(startDate);
          endDate.setDate(startDate.getDate() + 6);
          endDate.setHours(23, 59, 59, 999);
          
          description = 'This Week';
        } else if (rangeType === 'last_week') {
          // Last week
          const day = now.getDay();
          startDate = new Date(now);
          startDate.setDate(now.getDate() - day - 7);
          startDate.setHours(0, 0, 0, 0);
          
          endDate = new Date(startDate);
          endDate.setDate(startDate.getDate() + 6);
          endDate.setHours(23, 59, 59, 999);
          
          description = 'Last Week';
        } else if (rangeType === 'month') {
          // Current month
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
          description = 'This Month';
        } else if (rangeType === 'last_month') {
          // Last month
          startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          endDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
          description = 'Last Month';
        } else if (rangeType === 'quarter') {
          // Current quarter
          const quarter = Math.floor(now.getMonth() / 3);
          startDate = new Date(now.getFullYear(), quarter * 3, 1);
          endDate = new Date(now.getFullYear(), (quarter + 1) * 3, 0, 23, 59, 59, 999);
          description = 'This Quarter';
        } else if (rangeType === 'last_quarter') {
          // Last quarter
          const quarter = Math.floor(now.getMonth() / 3) - 1;
          const year = quarter < 0 ? now.getFullYear() - 1 : now.getFullYear();
          const adjustedQuarter = quarter < 0 ? 3 : quarter;
          
          startDate = new Date(year, adjustedQuarter * 3, 1);
          endDate = new Date(year, (adjustedQuarter + 1) * 3, 0, 23, 59, 59, 999);
          description = 'Last Quarter';
        } else if (rangeType === 'year') {
          // Current year
          startDate = new Date(now.getFullYear(), 0, 1);
          endDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
          description = 'This Year';
        } else if (rangeType === 'last_year') {
          // Last year
          startDate = new Date(now.getFullYear() - 1, 0, 1);
          endDate = new Date(now.getFullYear() - 1, 11, 31, 23, 59, 59, 999);
          description = 'Last Year';
        } else if (rangeType === 'all_time') {
          // All time
          startDate = new Date(0); // Beginning of time (1970-01-01)
          endDate = new Date(now.getFullYear() + 1, 11, 31, 23, 59, 59, 999); // Far future
          description = 'All Time';
        } else {
          // Default to last 30 days
          startDate = new Date(now);
          startDate.setDate(now.getDate() - 30);
          startDate.setHours(0, 0, 0, 0);
          
          endDate = new Date(now);
          endDate.setHours(23, 59, 59, 999);
          
          description = 'Last 30 Days';
          rangeType = 'last_30_days';
        }
        
        return {
          startDate: startDate,
          endDate: endDate,
          description: description,
          rangeType: rangeType
        };
      } catch (e) {
        logMetricsError('getMetricsDateRange', e.toString());
        
        // Return a safe default (last 30 days)
        const now = new Date();
        const startDate = new Date(now);
        startDate.setDate(now.getDate() - 30);
        startDate.setHours(0, 0, 0, 0);
        
        return {
          startDate: startDate,
          endDate: now,
          description: 'Last 30 Days',
          rangeType: 'last_30_days'
        };
      }
    },
    
    /**
     * Gets a human-readable description of a date range
     * @param {Date} startDate - Start date
     * @param {Date} endDate - End date
     * @return {String} Human-readable description
     */
    getDateRangeDescription_: function(startDate, endDate) {
      try {
        if (!startDate || !endDate) {
          return 'All Time';
        }
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        return `${Utilities.formatDate(start, Session.getScriptTimeZone(), 'MMM d, yyyy')} - ${Utilities.formatDate(end, Session.getScriptTimeZone(), 'MMM d, yyyy')}`;
      } catch (e) {
        return 'Custom Date Range';
      }
    },
    
    /**
     * Gets available metric types
     * @return {Object} Metric types with descriptions and goals
     */
    getAvailableMetricTypes: function() {
      return {
        callsOffered: {
          name: 'Calls Offered',
          description: 'Total number of calls offered to the agent',
          category: 'volume',
          dataType: 'number'
        },
        callsAccepted: {
          name: 'Calls Accepted',
          description: 'Total number of calls accepted by the agent',
          category: 'volume',
          dataType: 'number'
        },
        answerRate: {
          name: 'Answer Rate',
          description: 'Percentage of offered calls that were accepted',
          category: 'performance',
          dataType: 'percentage',
          goal: DEFAULT_METRIC_GOALS.answerRate
        },
        averageTalkTime: {
          name: 'Average Talk Time',
          description: 'Average duration of calls in minutes',
          category: 'performance',
          dataType: 'time',
          goal: DEFAULT_METRIC_GOALS.averageTalkTime
        },
        acwPercentage: {
          name: 'ACW Time',
          description: 'After Call Work time in minutes',
          category: 'performance',
          dataType: 'time',
          goal: DEFAULT_METRIC_GOALS.acwPercentage
        },
        onQueuePercentage: {
          name: 'On Queue %',
          description: 'Percentage of time spent on queue',
          category: 'performance',
          dataType: 'percentage',
          goal: DEFAULT_METRIC_GOALS.onQueuePercentage
        },
        offQueuePercentage: {
          name: 'Off Queue %',
          description: 'Percentage of time spent off queue',
          category: 'performance',
          dataType: 'percentage'
        },
        interactingTime: {
          name: 'Interacting Time',
          description: 'Time spent interacting with contacts in hours',
          category: 'performance',
          dataType: 'time',
          goal: DEFAULT_METRIC_GOALS.interactingTime
        },
        interactingPercentage: {
          name: 'Interacting %',
          description: 'Percentage of shift spent interacting with contacts',
          category: 'performance',
          dataType: 'percentage'
        }
      };
    }
  };
})();

/**
 * Gets team members using the standard method, handles error cases gracefully
 * @param {Object} options - Optional filters for team members
 * @return {Array} Team members
 */
function getTeamMembers(options = {}) {
  try {
    // Get team members from your TeamMemberService
    return getTeamMemberService().getTeamMembers(options);
  } catch (e) {
    Logger.log('Error getting team members: ' + e.toString());
    return [];
  }
}

/**
 * Logs metrics system errors
 * @param {String} source - Source function
 * @param {String} error - Error message
 * @param {Object} context - Additional context
 */
function logMetricsError(source, error, context = {}) {
  try {
    Logger.log(`Metrics Error [${source}]: ${error}`);
    
    // Log to error tracking sheet if it exists
    if (typeof logSystemError === 'function') {
      logSystemError('MetricsService', source, error, JSON.stringify(context));
    }
  } catch (e) {
    // If even error logging fails, just use Logger as fallback
    Logger.log(`Failed to log metrics error: ${e.toString()}`);
    Logger.log(`Original metrics error [${source}]: ${error}`);
  }
}

/**
 * Get the MetricsService instance
 * @return {Object} MetricsService instance
 */
function getMetricsService() {
  return MetricsService;
}

/**
 * Initialize the metrics system
 * @return {Object} Result with success flag
 */
function initializeMetricsSystem() {
  return getMetricsService().initializeSheets();
}

/**
 * UI navigation functions for Metrics
 */

/**
 * Opens the metrics form
 * @param {Date} date - Optional date to load
 * @param {String} teamMemberEmail - Optional team member to load
 */
function openMetricsForm(date, teamMemberEmail) {
  try {
    const template = HtmlService.createTemplateFromFile('HTML/Metrics/metrics-form');
    
    // Pass parameters to the template
    if (date) template.date = date;
    if (teamMemberEmail) template.teamMemberEmail = teamMemberEmail;
    
    const html = template.evaluate()
      .setTitle('Metrics Form')
      .setWidth(1000)
      .setHeight(700);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Metrics Form');
  } catch (e) {
    logMetricsError('openMetricsForm', e.toString());
    SpreadsheetApp.getUi().alert('Error opening metrics form: ' + e.toString());
  }
}

/**
 * Opens the metrics reports view
 * @param {Object} defaultFilters - Optional default filters
 */
function openMetricsReports(defaultFilters) {
  try {
    const template = HtmlService.createTemplateFromFile('HTML/Metrics/metrics-reports');
    
    // Pass default filters to the template if provided
    if (defaultFilters) template.defaultFilters = defaultFilters;
    
    const html = template.evaluate()
      .setTitle('Metrics Reports')
      .setWidth(1200)
      .setHeight(800);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Metrics Reports');
  } catch (e) {
    logMetricsError('openMetricsReports', e.toString());
    SpreadsheetApp.getUi().alert('Error opening metrics reports: ' + e.toString());
  }
}

/**
 * Opens the metrics dashboard
 * @param {String} view - Optional default view (team or individual)
 * @param {String} teamMemberEmail - Optional team member for individual view
 */
function openMetricsDashboard(view, teamMemberEmail) {
  try {
    const template = HtmlService.createTemplateFromFile('HTML/Metrics/metrics-dashboard');
    
    // Pass parameters to the template
    if (view) template.view = view;
    if (teamMemberEmail) template.teamMemberEmail = teamMemberEmail;
    
    const html = template.evaluate()
      .setTitle('Metrics Dashboard')
      .setWidth(1200)
      .setHeight(800);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Metrics Dashboard');
  } catch (e) {
    logMetricsError('openMetricsDashboard', e.toString());
    SpreadsheetApp.getUi().alert('Error opening metrics dashboard: ' + e.toString());
  }
}

/**
 * Opens the metrics export page
 */
function openMetricsExport() {
  try {
    const html = HtmlService.createTemplateFromFile('HTML/Metrics/metrics-export')
      .evaluate()
      .setTitle('Metrics Export')
      .setWidth(1000)
      .setHeight(700);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Metrics Export');
  } catch (e) {
    logMetricsError('openMetricsExport', e.toString());
    SpreadsheetApp.getUi().alert('Error opening metrics export: ' + e.toString());
  }
}

/**
 * Opens the metrics email configuration page
 * @param {String} configId - Optional configuration ID to edit
 */
function openMetricsEmailConfig(configId) {
  try {
    const template = HtmlService.createTemplateFromFile('HTML/Metrics/metrics-email-config');
    
    // Pass config ID to the template if provided
    if (configId) template.configId = configId;
    
    const html = template.evaluate()
      .setTitle('Metrics Email Configuration')
      .setWidth(800)
      .setHeight(600);
    
    SpreadsheetApp.getUi().showModalDialog(html, 'Metrics Email Configuration');
  } catch (e) {
    logMetricsError('openMetricsEmailConfig', e.toString());
    SpreadsheetApp.getUi().alert('Error opening metrics email configuration: ' + e.toString());
  }
}

/**
 * GeneralNotesService.gs
 * Service for managing general notes
 */

var GeneralNotesService = (function() {
  // Constants
  const NOTES_SHEET_NAME = 'GeneralNotes';
  const NOTE_CACHE_KEY = 'currentGeneralNote';
  
  /**
   * Gets or creates the sheet for storing general notes
   * @return {Sheet} The sheet object
   */
  function getOrCreateNotesSheet_() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(NOTES_SHEET_NAME);
    
    if (!sheet) {
      // Create new sheet
      sheet = ss.insertSheet(NOTES_SHEET_NAME);
      
      // Add headers
      var headers = [
        'ID', 'Title', 'Category', 'Priority',
        'Content', 'Tags', 'CreatedDate', 'UpdatedDate',
        'CreatedBy', 'Draft', 'Pinned', 'Shared',
        'RelatedItems', 'Reminder'
      ];
      
      sheet.getRange(1, 1, 1, headers.length).setValues([headers])
           .setFontWeight('bold')
           .setBackground('#eef2ff');
      
      sheet.setFrozenRows(1);
      sheet.autoResizeColumns(1, headers.length);
    }
    
    return sheet;
  }
  
  /**
   * Generate a unique ID for notes
   * @return {String} Unique ID
   */
  function generateUniqueId_() {
    return 'note_' + Utilities.getUuid().substring(0, 8);
  }
  
  /**
   * Converts note data to row data for the sheet
   * @param {Object} note - The note data to convert
   * @return {Array} Row data for the sheet
   */
  function noteToRowData_(note) {
    // Convert tags to JSON string
    const tags = note.tags ? 
      (Array.isArray(note.tags) ? JSON.stringify(note.tags) : note.tags) : '';
    
    // Convert related items to JSON string
    const relatedItems = note.relatedItems ? 
      (Array.isArray(note.relatedItems) ? JSON.stringify(note.relatedItems) : note.relatedItems) : '';
    
    // Convert reminder to JSON string
    const reminder = note.reminder ? 
      (typeof note.reminder === 'object' ? JSON.stringify(note.reminder) : note.reminder) : '';
    
    // Add current user email as creator if not present
    const createdBy = note.createdBy || Session.getActiveUser().getEmail();
    
    // Return row data as array
    return [
      note.id || '',
      note.title || '',
      note.category || '',
      note.priority || 'medium',
      note.content || '',
      tags,
      note.createdDate || new Date().toISOString(),
      note.updatedDate || new Date().toISOString(),
      createdBy,
      note.draft ? 'TRUE' : 'FALSE',
      note.pinned ? 'TRUE' : 'FALSE',
      note.shared ? 'TRUE' : 'FALSE',
      relatedItems,
      reminder
    ];
  }
  
  /**
   * Converts a row from the sheet to a note object
   * @param {Array} row - The row data
   * @param {Array} headers - The header row data
   * @return {Object} Note object
   */
  function rowToNote_(row, headers) {
    var note = {};
    
    // Map each column to the corresponding property
    headers.forEach(function(header, index) {
      // Skip empty columns
      if (index >= row.length) return;
      
      const value = row[index];
      
      // Handle special properties
      if (header === 'Tags' || header === 'RelatedItems') {
        try {
          note[toCamelCase_(header)] = value ? JSON.parse(value) : [];
        } catch (e) {
          note[toCamelCase_(header)] = value ? [value] : [];
        }
      } else if (header === 'Reminder') {
        try {
          note.reminder = value ? JSON.parse(value) : null;
        } catch (e) {
          note.reminder = null;
        }
      } else if (header === 'Draft' || header === 'Pinned' || header === 'Shared') {
        note[toCamelCase_(header)] = value === 'TRUE';
      } else {
        note[toCamelCase_(header)] = value;
      }
    });
    
    return note;
  }
  
  /**
   * Converts a header name to camelCase
   * @param {String} header - The header name
   * @return {String} camelCase property name
   */
  function toCamelCase_(header) {
    return header.charAt(0).toLowerCase() + header.slice(1);
  }
  
  /**
   * Gets a date range for filtering based on the period
   * @param {String} period - The period (e.g., "today", "week", "month", "quarter", "year", "all")
   * @return {Object} Object containing start and end dates
   */
  function getDateRangeForPeriod_(period) {
    const endDate = new Date();
    let startDate = new Date();
    
    if (period === 'all') {
      startDate = new Date(0); // January 1, 1970
    } else if (period === 'today') {
      startDate.setHours(0, 0, 0, 0);
    } else if (period === 'week') {
      const day = startDate.getDay();
      startDate.setDate(startDate.getDate() - day); // Start of this week (Sunday)
      startDate.setHours(0, 0, 0, 0);
    } else if (period === 'month') {
      startDate.setDate(1); // Start of this month
      startDate.setHours(0, 0, 0, 0);
    } else if (period === 'quarter') {
      const quarter = Math.floor(startDate.getMonth() / 3);
      startDate.setMonth(quarter * 3); // Start of this quarter
      startDate.setDate(1);
      startDate.setHours(0, 0, 0, 0);
    } else if (period === 'year') {
      startDate.setMonth(0); // January
      startDate.setDate(1); // 1st
      startDate.setHours(0, 0, 0, 0);
    } else {
      // Try to parse as number of days
      const days = parseInt(period, 10);
      if (!isNaN(days)) {
        startDate.setDate(startDate.getDate() - days);
      } else {
        startDate.setDate(startDate.getDate() - 30); // Default to 30 days
      }
    }
    
    return { startDate, endDate };
  }
  
  /**
   * Get word count from HTML content
   * @param {String} html - HTML content
   * @return {Number} Word count
   */
  function getWordCount_(html) {
    if (!html) return 0;
    
    // Remove HTML tags and extract text
    const text = html.replace(/<[^>]*>/g, ' ')
                     .replace(/\s+/g, ' ')
                     .trim();
    
    // Count words
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Extract text content from HTML
   * @param {String} html - The HTML string
   * @return {String} Extracted text
   */
  function extractTextFromHtml_(html) {
    if (!html) return '';
    
    // Simple regex-based approach to remove HTML tags
    return html.replace(/<[^>]*>/g, ' ')
               .replace(/\s+/g, ' ')
               .trim();
  }
  
  /**
   * Count word frequencies in text
   * @param {String} text - The text to analyze
   * @return {Object} Word frequencies map
   */
  function countWordFrequencies_(text) {
    if (!text) return {};
    
    // Remove special characters and convert to lowercase
    const words = text.toLowerCase()
                       .replace(/[^\w\s]/g, ' ')
                       .split(/\s+/)
                       .filter(word => word.length > 3); // Only words with 4+ characters
    
    // Count frequencies
    const frequencies = {};
    words.forEach(word => {
      if (!commonWords_.includes(word)) {
        frequencies[word] = (frequencies[word] || 0) + 1;
      }
    });
    
    return frequencies;
  }
  
  /**
   * Common words to exclude from word cloud
   */
  const commonWords_ = [
    'this', 'that', 'these', 'those', 'with', 'from', 'have', 'will',
    'would', 'could', 'should', 'than', 'then', 'they', 'them', 'their',
    'there', 'here', 'where', 'when', 'what', 'which', 'while', 'some',
    'about', 'after', 'before', 'above', 'below', 'between', 'through'
  ];
  
  /**
   * Calculate metrics for notes
   * @param {Array} currentNotes - Array of current period notes
   * @param {Array} previousNotes - Array of previous period notes
   * @return {Object} Metrics object
   */
  function calculateMetrics_(currentNotes, previousNotes) {
    // Total notes
    const totalNotes = currentNotes.length;
    const previousTotalNotes = previousNotes.length;
    const notesTrend = previousTotalNotes > 0 ? 
      Math.round((totalNotes - previousTotalNotes) / previousTotalNotes * 100) : 0;
    
    // Active (non-draft) notes
    const activeNotes = currentNotes.filter(note => !note.draft).length;
    const previousActiveNotes = previousNotes.filter(note => !note.draft).length;
    const activeNotesTrend = previousActiveNotes > 0 ? 
      Math.round((activeNotes - previousActiveNotes) / previousActiveNotes * 100) : 0;
    
    // Average content length (word count)
    let totalWords = 0;
    currentNotes.forEach(note => {
      totalWords += getWordCount_(note.content);
    });
    const avgContentLength = totalNotes > 0 ? Math.round(totalWords / totalNotes) : 0;
    
    let previousTotalWords = 0;
    previousNotes.forEach(note => {
      previousTotalWords += getWordCount_(note.content);
    });
    const previousAvgContentLength = previousNotes.length > 0 ? 
      Math.round(previousTotalWords / previousNotes.length) : 0;
    const contentLengthTrend = previousAvgContentLength > 0 ? 
      Math.round((avgContentLength - previousAvgContentLength) / previousAvgContentLength * 100) : 0;
    
    // Total tags
    let allTags = [];
    currentNotes.forEach(note => {
      if (note.tags && note.tags.length) {
        allTags = allTags.concat(note.tags);
      }
    });
    const uniqueTags = [...new Set(allTags)];
    const totalTags = uniqueTags.length;
    
    let previousAllTags = [];
    previousNotes.forEach(note => {
      if (note.tags && note.tags.length) {
        previousAllTags = previousAllTags.concat(note.tags);
      }
    });
    const previousUniqueTags = [...new Set(previousAllTags)];
    const previousTotalTags = previousUniqueTags.length;
    const tagsTrend = previousTotalTags > 0 ? 
      Math.round((totalTags - previousTotalTags) / previousTotalTags * 100) : 0;
    
    return {
      totalNotes,
      notesTrend,
      activeNotes,
      activeNotesTrend,
      avgContentLength,
      contentLengthTrend,
      totalTags,
      tagsTrend
    };
  }
  
  /**
   * Generate activity data for chart
   * @param {Array} notes - Array of note objects
   * @param {Date} startDate - Start date
   * @param {Date} endDate - End date
   * @param {String} period - Period ('day', 'week', or 'month')
   * @return {Object} Activity data
   */
  function generateActivityData_(notes, startDate, endDate, period) {
    const labels = [];
    const values = [];
    
    // Create date buckets based on period
    let current = new Date(startDate);
    
    while (current <= endDate) {
      let label;
      let nextDate = new Date(current);
      
      if (period === 'day') {
        label = current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        nextDate.setDate(nextDate.getDate() + 1);
      } else if (period === 'week') {
        const weekEnd = new Date(current);
        weekEnd.setDate(weekEnd.getDate() + 6);
        label = `${current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${weekEnd.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        nextDate.setDate(nextDate.getDate() + 7);
      } else { // month
        label = current.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        nextDate.setMonth(nextDate.getMonth() + 1);
      }
      
      labels.push(label);
      
      // Count notes created in this period
      const count = notes.filter(note => {
        const noteDate = new Date(note.createdDate);
        return noteDate >= current && noteDate < nextDate;
      }).length;
      
      values.push(count);
      
      current = nextDate;
    }
    
    return { labels, values };
  }
  
  /**
   * Generate categories data
   * @param {Array} notes - Array of note objects
   * @return {Array} Categories data
   */
  function generateCategoriesData_(notes) {
    const categories = {};
    
    notes.forEach(note => {
      const category = note.category || 'Uncategorized';
      categories[category] = (categories[category] || 0) + 1;
    });
    
    // Convert to array of objects
    const result = Object.keys(categories).map(category => ({
      category,
      count: categories[category]
    }));
    
    // Sort by count (descending)
    result.sort((a, b) => b.count - a.count);
    
    return result;
  }
  
  /**
   * Generate priority data
   * @param {Array} notes - Array of note objects
   * @return {Object} Priority data
   */
  function generatePriorityData_(notes) {
    const priorities = {
      high: 0,
      medium: 0,
      low: 0
    };
    
    notes.forEach(note => {
      const priority = note.priority || 'medium';
      priorities[priority] = (priorities[priority] || 0) + 1;
    });
    
    return priorities;
  }
  
  /**
   * Generate word count distribution data
   * @param {Array} notes - Array of note objects
   * @return {Object} Word count distribution data
   */
  function generateWordCountData_(notes) {
    // Count words in each note
    const counts = notes.map(note => getWordCount_(note.content));
    
    // Create distribution buckets
    const buckets = {
      '0-50': 0,
      '51-100': 0,
      '101-250': 0,
      '251-500': 0,
      '501+': 0
    };
    
    counts.forEach(count => {
      if (count <= 50) {
        buckets['0-50']++;
      } else if (count <= 100) {
        buckets['51-100']++;
      } else if (count <= 250) {
        buckets['101-250']++;
      } else if (count <= 500) {
        buckets['251-500']++;
      } else {
        buckets['501+']++;
      }
    });
    
    return {
      labels: Object.keys(buckets),
      values: Object.values(buckets)
    };
  }
  
  /**
   * Generate tag data
   * @param {Array} notes - Array of note objects
   * @return {Array} Tag data
   */
  function generateTagData_(notes) {
    const tagCounts = {};
    
    notes.forEach(note => {
      if (note.tags && note.tags.length) {
        note.tags.forEach(tag => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      }
    });
    
    // Convert to array of objects
    const result = Object.keys(tagCounts).map(tag => ({
      tag,
      count: tagCounts[tag]
    }));
    
    // Sort by count (descending)
    result.sort((a, b) => b.count - a.count);
    
    // Return top 30 tags
    return result.slice(0, 30);
  }
  
  /**
   * Generate timeline data
   * @param {Array} notes - Array of note objects
   * @param {Number} limit - Maximum number of entries
   * @return {Array} Timeline data
   */
  function generateTimelineData_(notes, limit = 10) {
    // Get the most recent notes
    const sortedNotes = [...notes].sort((a, b) => new Date(b.updatedDate) - new Date(a.updatedDate));
    const recentNotes = sortedNotes.slice(0, limit);
    
    // Create timeline entries
    return recentNotes.map(note => {
      const description = extractTextFromHtml_(note.content).substring(0, 120) + 
                          (extractTextFromHtml_(note.content).length > 120 ? '...' : '');
      
      let title = note.title || 'Untitled Note';
      
      if (note.draft) {
        title += ' (Draft)';
      }
      
      return {
        date: note.updatedDate,
        title: title,
        description: description
      };
    });
  }
  
  // Public API
  return {
    /**
     * Gets all general notes, optionally filtered
     * @param {Object} filters - Optional filters to apply
     * @return {Array} Array of note objects
     */
    getGeneralNotes: function(filters = {}) {
      try {
        const sheet = getOrCreateNotesSheet_();
        const data = sheet.getDataRange().getValues();
        
        if (data.length <= 1) {
          return []; // No notes yet
        }
        
        const headers = data[0];
        let notes = [];
        
        // Convert each row to a note object
        for (let i = 1; i < data.length; i++) {
          const note = rowToNote_(data[i], headers);
          notes.push(note);
        }
        
        // Apply search term filter
        if (filters.searchTerm) {
          const searchTerm = filters.searchTerm.toLowerCase();
          notes = notes.filter(note => {
            return (
              (note.title && note.title.toLowerCase().includes(searchTerm)) ||
              (note.content && extractTextFromHtml_(note.content).toLowerCase().includes(searchTerm)) ||
              (note.tags && note.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
            );
          });
        }
        
        // Apply category filter
        if (filters.category) {
          notes = notes.filter(note => note.category === filters.category);
        }
        
        // Apply priority filter
        if (filters.priority) {
          notes = notes.filter(note => note.priority === filters.priority);
        }
        
        // Apply time filter
        if (filters.timeFilter && filters.timeFilter !== 'all') {
          const { startDate, endDate } = getDateRangeForPeriod_(filters.timeFilter);
          
          notes = notes.filter(note => {
            const noteDate = new Date(note.updatedDate);
            return noteDate >= startDate && noteDate <= endDate;
          });
        }
        
        // Apply tag filter
        if (filters.tag) {
          notes = notes.filter(note => {
            return note.tags && note.tags.includes(filters.tag);
          });
        }
        
        return notes;
      } catch (e) {
        Logger.log('Error in getGeneralNotes: ' + e.toString());
        return [];
      }
    },
    
    /**
     * Gets a specific general note by ID
     * @param {String} noteId - The ID of the note
     * @return {Object} Note object or null if not found
     */
    getGeneralNoteById: function(noteId) {
      try {
        if (!noteId) {
          return null;
        }
        
        const sheet = getOrCreateNotesSheet_();
        const data = sheet.getDataRange().getValues();
        
        if (data.length <= 1) {
          return null; // No notes yet
        }
        
        const headers = data[0];
        const idIndex = headers.indexOf('ID');
        
        if (idIndex === -1) {
          throw new Error('ID column not found in notes sheet');
        }
        
        // Find row with matching ID
        for (let i = 1; i < data.length; i++) {
          if (data[i][idIndex] === noteId) {
            return rowToNote_(data[i], headers);
          }
        }
        
        return null; // Not found
      } catch (e) {
        Logger.log('Error in getGeneralNoteById: ' + e.toString());
        return null;
      }
    },
    
    /**
     * Saves a general note
     * @param {Object} noteData - The note data to save
     * @return {Object} Result object with success status and message
     */
    saveGeneralNote: function(noteData) {
      try {
        const sheet = getOrCreateNotesSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        const idIndex = headers.indexOf('ID');
        
        if (idIndex === -1) {
          throw new Error('ID column not found in notes sheet');
        }
        
        const isNewNote = !noteData.id;
        
        // Generate ID for new notes
        if (isNewNote) {
          noteData.id = generateUniqueId_();
          noteData.createdDate = new Date().toISOString();
          noteData.createdBy = Session.getActiveUser().getEmail();
        }
        
        // Always update the updated date
        noteData.updatedDate = new Date().toISOString();
        
        // Convert to row data
        const rowData = noteToRowData_(noteData);
        
        if (isNewNote) {
          // Append new note
          sheet.appendRow(rowData);
          sheet.getLastRow().activate();
        } else {
          // Update existing note
          let rowIndex = -1;
          
          // Find the row with the matching ID
          for (let i = 1; i < data.length; i++) {
            if (data[i][idIndex] === noteData.id) {
              rowIndex = i + 1; // +1 because rows are 1-indexed
              break;
            }
          }
          
          if (rowIndex === -1) {
            throw new Error('Note not found with ID: ' + noteData.id);
          }
          
          // Update the row
          sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
        }
        
        // Cache the note ID for potential further edits
        this.cacheGeneralNoteId(noteData.id);
        
        return {
          success: true,
          id: noteData.id,
          message: isNewNote ? 'Note created successfully' : 'Note updated successfully'
        };
      } catch (e) {
        Logger.log('Error in saveGeneralNote: ' + e.toString());
        return {
          success: false,
          message: 'Error saving note: ' + e.toString()
        };
      }
    },
    
    /**
     * Deletes a general note
     * @param {String} noteId - The ID of the note to delete
     * @return {Object} Result object with success status and message
     */
    deleteGeneralNote: function(noteId) {
      try {
        if (!noteId) {
          throw new Error('Note ID is required');
        }
        
        const sheet = getOrCreateNotesSheet_();
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        const idIndex = headers.indexOf('ID');
        
        if (idIndex === -1) {
          throw new Error('ID column not found in notes sheet');
        }
        
        // Find the row with the matching ID
        let rowIndex = -1;
        for (let i = 1; i < data.length; i++) {
          if (data[i][idIndex] === noteId) {
            rowIndex = i + 1; // +1 because rows are 1-indexed
            break;
          }
        }
        
        if (rowIndex === -1) {
          throw new Error('Note not found with ID: ' + noteId);
        }
        
        // Delete the row
        sheet.deleteRow(rowIndex);
        
        // Clear the cached note ID
        this.cacheGeneralNoteId(null);
        
        return {
          success: true,
          message: 'Note deleted successfully'
        };
      } catch (e) {
        Logger.log('Error in deleteGeneralNote: ' + e.toString());
        return {
          success: false,
          message: 'Error deleting note: ' + e.toString()
        };
      }
    },
    
    /**
     * Duplicates a general note
     * @param {String} noteId - The ID of the note to duplicate
     * @return {Object} Result object with success status and message
     */
    duplicateGeneralNote: function(noteId) {
      try {
        if (!noteId) {
          throw new Error('Note ID is required');
        }
        
        // Get the original note
        const note = this.getGeneralNoteById(noteId);
        
        if (!note) {
          throw new Error('Note not found with ID: ' + noteId);
        }
        
        // Create a copy with a new ID
        const copy = {...note};
        delete copy.id; // Remove ID so a new one is generated
        copy.title = copy.title ? (copy.title + ' (Copy)') : 'Untitled Note (Copy)';
        copy.createdDate = new Date().toISOString();
        copy.updatedDate = new Date().toISOString();
        copy.createdBy = Session.getActiveUser().getEmail();
        
        // Save the copy
        const result = this.saveGeneralNote(copy);
        
        return result;
      } catch (e) {
        Logger.log('Error in duplicateGeneralNote: ' + e.toString());
        return {
          success: false,
          message: 'Error duplicating note: ' + e.toString()
        };
      }
    },
    
    /**
     * Toggles whether a general note is pinned
     * @param {String} noteId - The ID of the note to toggle
     * @return {Object} Result object with success status and message
     */
    toggleGeneralNotePin: function(noteId) {
      try {
        if (!noteId) {
          throw new Error('Note ID is required');
        }
        
        // Get the note
        const note = this.getGeneralNoteById(noteId);
        
        if (!note) {
          throw new Error('Note not found with ID: ' + noteId);
        }
        
        // Toggle the pinned status
        note.pinned = !note.pinned;
        
        // Save the updated note
        const result = this.saveGeneralNote(note);
        
        if (result.success) {
          result.message = note.pinned ? 'Note pinned successfully' : 'Note unpinned successfully';
        }
        
        return result;
      } catch (e) {
        Logger.log('Error in toggleGeneralNotePin: ' + e.toString());
        return {
          success: false,
          message: 'Error toggling pin status: ' + e.toString()
        };
      }
    },
    
    /**
     * Caches a general note ID for editing
     * @param {String} noteId - The ID to cache (or null to clear)
     * @return {Boolean} Success status
     */
    cacheGeneralNoteId: function(noteId) {
      try {
        const cache = CacheService.getUserCache();
        
        if (noteId) {
          cache.put(NOTE_CACHE_KEY, noteId, 3600); // Cache for 1 hour
        } else {
          cache.remove(NOTE_CACHE_KEY);
        }
        
        return true;
      } catch (e) {
        Logger.log('Error in cacheGeneralNoteId: ' + e.toString());
        return false;
      }
    },
    
    /**
     * Gets the cached general note ID
     * @return {Object} The cached note object or null if not found
     */
    getCachedGeneralNoteId: function() {
      try {
        const cache = CacheService.getUserCache();
        const noteId = cache.get(NOTE_CACHE_KEY);
        
        if (!noteId) {
          return null;
        }
        
        // Get the note data
        const note = this.getGeneralNoteById(noteId);
        return note;
      } catch (e) {
        Logger.log('Error in getCachedGeneralNoteId: ' + e.toString());
        return null;
      }
    },
    
    /**
     * Gets options for a related item type
     * @param {String} type - The type of related item
     * @return {Array} Array of option objects
     */
    getRelatedItemOptions: function(type) {
      try {
        let options = [];
        
        switch (type) {
          case 'team-member':
            // Get team members from TeamService
            const teamMembers = getTeamService().getTeamMembers();
            options = teamMembers.map(member => ({
              id: member.email,
              name: member.name || member.email
            }));
            break;
          
          case 'one-on-one':
            // Get one-on-one sessions
            let oneOnOnes = [];
            
            try {
              // Try manager one-on-ones first
              if (typeof getManagerOneOnOneService === 'function') {
                const managerSessions = getManagerOneOnOneService().getManagerOneOnOneSessions();
                oneOnOnes = oneOnOnes.concat(managerSessions.map(session => ({
                  id: session.id,
                  name: `Manager: ${session.managerName || 'Unknown'} (${formatDate_(session.date)})`
                })));
              }
            } catch (e) {
              Logger.log('Error getting manager one-on-ones: ' + e.toString());
            }
            
            try {
              // Try team member one-on-ones
              if (typeof getOneOnOneService === 'function') {
                const teamSessions = getOneOnOneService().getOneOnOneSessions();
                oneOnOnes = oneOnOnes.concat(teamSessions.map(session => ({
                  id: session.id,
                  name: `Team: ${session.teamMemberName || 'Unknown'} (${formatDate_(session.date)})`
                })));
              }
            } catch (e) {
              Logger.log('Error getting team one-on-ones: ' + e.toString());
            }
            
            options = oneOnOnes;
            break;
          
          case 'project':
            // Get projects
            try {
              if (typeof getProjectService === 'function') {
                const projects = getProjectService().getProjects();
                options = projects.map(project => ({
                  id: project.id,
                  name: project.name || `Project ${project.id}`
                }));
              }
            } catch (e) {
              Logger.log('Error getting projects: ' + e.toString());
            }
            break;
          
          case 'task':
            // Get tasks
            try {
              if (typeof getTaskService === 'function') {
                const tasks = getTaskService().getTasks();
                options = tasks.map(task => ({
                  id: task.id,
                  name: task.title || `Task ${task.id}`
                }));
              }
            } catch (e) {
              Logger.log('Error getting tasks: ' + e.toString());
            }
            break;
        }
        
        return options;
      } catch (e) {
        Logger.log('Error in getRelatedItemOptions: ' + e.toString());
        return [];
      }
    },
    
    /**
     * Gets dashboard data for general notes
     * @param {Object} filters - Optional filters to apply
     * @return {Object} Dashboard data
     */
    getGeneralNotesDashboardData: function(filters = {}) {
      try {
        // Get the time period from filters
        const timePeriod = filters.timePeriod || '365';
        const { startDate, endDate } = getDateRangeForPeriod_(timePeriod);
        
        // Get notes for the current period
        const currentPeriodFilters = {...filters};
        currentPeriodFilters.startDate = startDate;
        currentPeriodFilters.endDate = endDate;
        const currentNotes = this.getGeneralNotes(currentPeriodFilters);
        
        // Calculate start date for previous period
        const previousStartDate = new Date(startDate);
        const previousEndDate = new Date(startDate);
        previousEndDate.setDate(previousEndDate.getDate() - 1);
        
        // Calculate how many days in the current period
        const daysDiff = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
        previousStartDate.setDate(previousStartDate.getDate() - daysDiff);
        
        // Get notes for the previous period
        const previousPeriodFilters = {...filters};
        previousPeriodFilters.startDate = previousStartDate;
        previousPeriodFilters.endDate = previousEndDate;
        const previousNotes = this.getGeneralNotes(previousPeriodFilters);
        
        // Calculate metrics
        const metrics = calculateMetrics_(currentNotes, previousNotes);
        
        // Get unique categories
        const categories = [...new Set(currentNotes.map(note => note.category).filter(Boolean))];
        
        // Generate chart data
        const chartPeriod = filters.chartPeriod || 'month';
        const activityData = generateActivityData_(currentNotes, startDate, endDate, chartPeriod);
        
        // Generate categories data
        const categoriesData = generateCategoriesData_(currentNotes);
        
        // Generate priority data
        const priorityData = generatePriorityData_(currentNotes);
        
        // Generate word count data
        const wordCountData = generateWordCountData_(currentNotes);
        
        // Generate tag data
        const tagData = generateTagData_(currentNotes);
        
        // Generate timeline data
        const timelineData = generateTimelineData_(currentNotes);
        
        // Get recent notes
        const recentNotes = [...currentNotes]
          .sort((a, b) => new Date(b.updatedDate) - new Date(a.updatedDate))
          .slice(0, 5);
        
        return {
          metrics,
          categories,
          activityData,
          categoriesData,
          priorityData,
          wordCountData,
          tagData,
          timelineData,
          recentNotes
        };
      } catch (e) {
        Logger.log('Error in getGeneralNotesDashboardData: ' + e.toString());
        return {
          error: e.toString()
        };
      }
    },
    
    /**
     * Exports general notes to a spreadsheet
     * @param {Object} filters - Optional filters to apply
     * @return {Object} Result object with success status and URL
     */
    exportGeneralNotes: function(filters = {}) {
      try {
        // Get notes with filters
        const notes = this.getGeneralNotes(filters);
        
        if (!notes.length) {
          return {
            success: false,
            message: 'No notes to export'
          };
        }
        
        // Create a new spreadsheet
        const ss = SpreadsheetApp.create('General Notes Export - ' + new Date().toISOString().split('T')[0]);
        const sheet = ss.getActiveSheet();
        sheet.setName('Notes');
        
        // Add headers
        const headers = [
          'Title', 'Category', 'Priority', 'Content',
          'Created Date', 'Updated Date', 'Created By',
          'Tags', 'Status', 'Pinned', 'Shared'
        ];
        
        sheet.getRange(1, 1, 1, headers.length).setValues([headers])
             .setFontWeight('bold')
             .setBackground('#eef2ff');
        
        // Add note data
        const rows = notes.map(note => {
          return [
            note.title || '',
            note.category || '',
            note.priority || 'medium',
            extractTextFromHtml_(note.content) || '',
            note.createdDate ? new Date(note.createdDate) : '',
            note.updatedDate ? new Date(note.updatedDate) : '',
            note.createdBy || '',
            note.tags ? note.tags.join(', ') : '',
            note.draft ? 'Draft' : 'Published',
            note.pinned ? 'Yes' : 'No',
            note.shared ? 'Yes' : 'No'
          ];
        });
        
        // Write data
        if (rows.length > 0) {
          sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
        }
        
        // Auto-resize columns
        sheet.autoResizeColumns(1, headers.length);
        
        // Create summary sheet
        const summarySheet = ss.insertSheet('Summary');
        
        // Add summary data
        const categories = [...new Set(notes.map(note => note.category).filter(Boolean))];
        const totalNotes = notes.length;
        const publishedNotes = notes.filter(note => !note.draft).length;
        const avgWordCount = Math.round(notes.reduce((sum, note) => sum + getWordCount_(note.content), 0) / notes.length);
        
        const summaryData = [
          ['General Notes Export'],
          ['Generated on', new Date()],
          ['Generated by', Session.getActiveUser().getEmail()],
          [''],
          ['Total Notes', totalNotes],
          ['Published Notes', publishedNotes],
          ['Draft Notes', totalNotes - publishedNotes],
          ['Average Word Count', avgWordCount],
          ['Categories', categories.join(', ')]
        ];
        
        summarySheet.getRange(1, 1, summaryData.length, 2).setValues(summaryData);
        summarySheet.getRange(1, 1).setFontWeight('bold').setFontSize(14);
        summarySheet.autoResizeColumns(1, 2);
        
        // Set summary as active sheet
        ss.setActiveSheet(summarySheet);
        
        return {
          success: true,
          message: 'Notes exported successfully',
          url: ss.getUrl(),
          noteCount: notes.length
        };
      } catch (e) {
        Logger.log('Error in exportGeneralNotes: ' + e.toString());
        return {
          success: false,
          message: 'Error exporting notes: ' + e.toString()
        };
      }
    },
    
    /**
     * Exports the general notes dashboard data
     * @param {Object} filters - Optional filters to apply
     * @return {Object} Result object with success status and URL
     */
    exportGeneralNotesDashboard: function(filters = {}) {
      try {
        // Get dashboard data
        const dashboardData = this.getGeneralNotesDashboardData(filters);
        
        // Create a new spreadsheet
        const ss = SpreadsheetApp.create('General Notes Dashboard Export - ' + new Date().toISOString().split('T')[0]);
        const metricsSheet = ss.getActiveSheet();
        metricsSheet.setName('Metrics');
        
        // Add metrics data
        const metrics = dashboardData.metrics;
        const metricsData = [
          ['General Notes Dashboard Metrics'],
          ['Generated on', new Date()],
          ['Generated by', Session.getActiveUser().getEmail()],
          [''],
          ['Metric', 'Value', 'Trend'],
          ['Total Notes', metrics.totalNotes, metrics.notesTrend + '%'],
          ['Published Notes', metrics.activeNotes, metrics.activeNotesTrend + '%'],
          ['Average Word Count', metrics.avgContentLength, metrics.contentLengthTrend + '%'],
          ['Total Tags', metrics.totalTags, metrics.tagsTrend + '%']
        ];
        
        metricsSheet.getRange(1, 1, metricsData.length, 3).setValues(metricsData);
        metricsSheet.getRange(1, 1).setFontWeight('bold').setFontSize(14);
        metricsSheet.getRange(5, 1, 1, 3).setFontWeight('bold').setBackground('#eef2ff');
        metricsSheet.autoResizeColumns(1, 3);
        
        // Add categories sheet
        const categoriesSheet = ss.insertSheet('Categories');
        
        // Add headers
        categoriesSheet.getRange(1, 1, 1, 2).setValues([['Category', 'Count']])
                       .setFontWeight('bold')
                       .setBackground('#eef2ff');
        
        // Add data
        if (dashboardData.categoriesData && dashboardData.categoriesData.length) {
          const rows = dashboardData.categoriesData.map(item => [item.category, item.count]);
          categoriesSheet.getRange(2, 1, rows.length, 2).setValues(rows);
        }
        
        categoriesSheet.autoResizeColumns(1, 2);
        
        // Add priorities sheet
        const prioritiesSheet = ss.insertSheet('Priorities');
        
        // Add headers
        prioritiesSheet.getRange(1, 1, 1, 2).setValues([['Priority', 'Count']])
                      .setFontWeight('bold')
                      .setBackground('#eef2ff');
        
        // Add data
        const priorityData = dashboardData.priorityData;
        prioritiesSheet.getRange(2, 1, 3, 2).setValues([
          ['High', priorityData.high],
          ['Medium', priorityData.medium],
          ['Low', priorityData.low]
        ]);
        
        prioritiesSheet.autoResizeColumns(1, 2);
        
        // Add tags sheet
        const tagsSheet = ss.insertSheet('Tags');
        
        // Add headers
        tagsSheet.getRange(1, 1, 1, 2).setValues([['Tag', 'Count']])
                .setFontWeight('bold')
                .setBackground('#eef2ff');
        
        // Add data
        if (dashboardData.tagData && dashboardData.tagData.length) {
          const rows = dashboardData.tagData.map(item => [item.tag, item.count]);
          tagsSheet.getRange(2, 1, rows.length, 2).setValues(rows);
        }
        
        tagsSheet.autoResizeColumns(1, 2);
        
        // Add activity sheet
        const activitySheet = ss.insertSheet('Activity');
        
        // Add headers
        activitySheet.getRange(1, 1, 1, 2).setValues([['Period', 'Count']])
                    .setFontWeight('bold')
                    .setBackground('#eef2ff');
        
        // Add data
        if (dashboardData.activityData && dashboardData.activityData.labels) {
          const rows = dashboardData.activityData.labels.map((label, index) => [
            label,
            dashboardData.activityData.values[index]
          ]);
          activitySheet.getRange(2, 1, rows.length, 2).setValues(rows);
        }
        
        activitySheet.autoResizeColumns(1, 2);
        
        // Set metrics as active sheet
        ss.setActiveSheet(metricsSheet);
        
        return {
          success: true,
          message: 'Dashboard exported successfully',
          url: ss.getUrl()
        };
      } catch (e) {
        Logger.log('Error in exportGeneralNotesDashboard: ' + e.toString());
        return {
          success: false,
          message: 'Error exporting dashboard: ' + e.toString()
        };
      }
    },
    
    /**
     * Opens a related item
     * @param {String} type - The type of related item
     * @param {String} id - The ID of the item
     * @return {Boolean} Success status
     */
    openRelatedItem: function(type, id) {
      try {
        switch (type) {
          case 'team-member':
            // Open team member view
            try {
              if (typeof viewTeamMember === 'function') {
                viewTeamMember(id);
                return true;
              }
            } catch (e) {
              Logger.log('Error opening team member: ' + e.toString());
            }
            break;
            
          case 'one-on-one':
            // Determine if it's a manager one-on-one or team one-on-one
            if (id.startsWith('mgr1on1_')) {
              // Manager one-on-one
              try {
                if (typeof getManagerOneOnOneService === 'function') {
                  getManagerOneOnOneService().cacheManagerOneOnOneSessionId(id);
                  viewManagerOneOnOneNotes();
                  return true;
                }
              } catch (e) {
                Logger.log('Error opening manager one-on-one: ' + e.toString());
              }
            } else {
              // Team one-on-one
              try {
                if (typeof getOneOnOneService === 'function') {
                  getOneOnOneService().cacheOneOnOneSessionId(id);
                  viewOneOnOneNotes();
                  return true;
                }
              } catch (e) {
                Logger.log('Error opening team one-on-one: ' + e.toString());
              }
            }
            break;
            
          case 'project':
            // Open project view
            try {
              if (typeof viewProject === 'function') {
                viewProject(id);
                return true;
              }
            } catch (e) {
              Logger.log('Error opening project: ' + e.toString());
            }
            break;
            
          case 'task':
            // Open task view
            try {
              if (typeof viewTask === 'function') {
                viewTask(id);
                return true;
              }
            } catch (e) {
              Logger.log('Error opening task: ' + e.toString());
            }
            break;
        }
        
        return false;
      } catch (e) {
        Logger.log('Error in openRelatedItem: ' + e.toString());
        return false;
      }
    }
  };
  
  /**
   * Format date
   * @param {String} dateString - Date string
   * @return {String} Formatted date
   */
  function formatDate_(dateString) {
    if (!dateString) return 'Unknown';
    
    try {
      const date = new Date(dateString);
      
      if (isNaN(date.getTime())) {
        return 'Invalid Date';
      }
      
      return date.toLocaleDateString();
    } catch (e) {
      return 'Date Error';
    }
  }
})();

/**
 * Get the GeneralNotesService instance
 * @return {Object} GeneralNotesService instance
 */
function getGeneralNotesService() {
  return GeneralNotesService;
}

// Functions to be called from HTML or main code

/**
 * Gets all general notes
 * @param {Object} filters - Optional filters
 * @return {Array} Notes array
 */
function getGeneralNotes(filters) {
  return getGeneralNotesService().getGeneralNotes(filters);
}

/**
 * Gets a specific general note
 * @param {String} noteId - Note ID
 * @return {Object} Note object
 */
function getGeneralNoteById(noteId) {
  return getGeneralNotesService().getGeneralNoteById(noteId);
}

/**
 * Saves a general note
 * @param {Object} noteData - Note data
 * @return {Object} Result object
 */
function saveGeneralNote(noteData) {
  return getGeneralNotesService().saveGeneralNote(noteData);
}

/**
 * Deletes a general note
 * @param {String} noteId - Note ID
 * @return {Object} Result object
 */
function deleteGeneralNote(noteId) {
  return getGeneralNotesService().deleteGeneralNote(noteId);
}

/**
 * Duplicates a general note
 * @param {String} noteId - Note ID
 * @return {Object} Result object
 */
function duplicateGeneralNote(noteId) {
  return getGeneralNotesService().duplicateGeneralNote(noteId);
}

/**
 * Toggles whether a note is pinned
 * @param {String} noteId - Note ID
 * @return {Object} Result object
 */
function toggleGeneralNotePin(noteId) {
  return getGeneralNotesService().toggleGeneralNotePin(noteId);
}

/**
 * Caches a general note ID
 * @param {String} noteId - Note ID
 * @return {Boolean} Success status
 */
function cacheGeneralNoteId(noteId) {
  return getGeneralNotesService().cacheGeneralNoteId(noteId);
}

/**
 * Gets the cached general note
 * @return {Object} Note object
 */
function getCachedGeneralNoteId() {
  return getGeneralNotesService().getCachedGeneralNoteId();
}

/**
 * Gets options for a related item type
 * @param {String} type - Item type
 * @return {Array} Options array
 */
function getRelatedItemOptions(type) {
  return getGeneralNotesService().getRelatedItemOptions(type);
}

/**
 * Gets dashboard data for general notes
 * @param {Object} filters - Optional filters
 * @return {Object} Dashboard data
 */
function getGeneralNotesDashboardData(filters) {
  return getGeneralNotesService().getGeneralNotesDashboardData(filters);
}

/**
 * Exports general notes
 * @param {Object} filters - Optional filters
 * @return {Object} Result object
 */
function exportGeneralNotes(filters) {
  return getGeneralNotesService().exportGeneralNotes(filters);
}

/**
 * Exports general notes dashboard
 * @param {Object} filters - Optional filters
 * @return {Object} Result object
 */
function exportGeneralNotesDashboard(filters) {
  return getGeneralNotesService().exportGeneralNotesDashboard(filters);
}

/**
 * Opens a related item
 * @param {String} type - Item type
 * @param {String} id - Item ID
 * @return {Boolean} Success status
 */
function openRelatedItem(type, id) {
  return getGeneralNotesService().openRelatedItem(type, id);
}

/**
 * Create/show the general note form
 */
function createGeneralNoteForm() {
  const html = HtmlService.createTemplateFromFile('general-note-form')
                          .evaluate()
                          .setWidth(900)
                          .setHeight(800)
                          .setTitle('General Note');
  SpreadsheetApp.getUi().showModalDialog(html, 'General Note');
}

/**
 * View general notes
 */
function viewGeneralNotes() {
  const html = HtmlService.createTemplateFromFile('general-notes')
                          .evaluate()
                          .setWidth(1000)
                          .setHeight(800)
                          .setTitle('General Notes');
  SpreadsheetApp.getUi().showModalDialog(html, 'General Notes');
}

/**
 * View general notes dashboard
 */
function viewGeneralNotesDashboard() {
  const html = HtmlService.createTemplateFromFile('general-notes-dashboard')
                          .evaluate()
                          .setWidth(1000)
                          .setHeight(800)
                          .setTitle('General Notes Dashboard');
  SpreadsheetApp.getUi().showModalDialog(html, 'General Notes Dashboard');
}

/**
 * Gets current user information
 * @return {Object} User info including email and timestamp
 */
function getCurrentUserInfo() {
  const user = Session.getActiveUser().getEmail();
  
  // Get current date/time in UTC format
  const now = new Date();
  const year = now.getUTCFullYear();
  const month = (now.getUTCMonth() + 1).toString().padStart(2, '0');
  const day = now.getUTCDate().toString().padStart(2, '0');
  const hours = now.getUTCHours().toString().padStart(2, '0');
  const minutes = now.getUTCMinutes().toString().padStart(2, '0');
  const seconds = now.getUTCSeconds().toString().padStart(2, '0');
  const timestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  
  return {
    email: user,
    timestamp: timestamp
  };
}


/**
 * QAService.gs - Services for quality assessment reviews
 */

var QAService = (function() {
  // Private variables and methods
  var QA_SHEET_NAME = 'QAReviews';
  var QA_HISTORY_SHEET_NAME = 'QAExportHistory';
  
  /**
   * Gets the QA reviews sheet, creates if it doesn't exist
   * @return {Sheet} - Google Sheet for QA reviews
   */
  function getQASheet_() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(QA_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(QA_SHEET_NAME);
      
      // Create the headers
      var headers = [
        'ID', 'Date', 'Team Member', 'Interaction ID', 'Type', 
        'Criteria JSON', 'Total Score', 'Feedback', 
        'Created By', 'Created Date', 'Last Updated'
      ];
      
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
      
      // Format date columns
      var dateColumns = [2, 10, 11]; // Date, Created Date, Last Updated
      dateColumns.forEach(function(col) {
        sheet.getRange(2, col, 999, 1).setNumberFormat('yyyy-mm-dd');
      });
    }
    
    return sheet;
  }
  
  /**
   * Initialize the QA sheets with the modern structure
   * @return {Object} Result with success flag
   */
  function initializeSheet() {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName(QA_SHEET_NAME);
      
      if (!sheet) {
        sheet = ss.insertSheet(QA_SHEET_NAME);
        
        // Add headers
        const headers = [
          'id', 'counselorEmail', 'counselorName', 'reviewer', 'interactionDate', 
          'interactionId', 'interactionType', 'interactionLength', 'shadowSession', 
          'interactionSummary', 'evaluation', 'totalPoints', 'totalPossible', 
          'scorePercentage', 'callOpeningPoints', 'callOpeningPossible',
          'riskAssessmentPoints', 'riskAssessmentPossible', 'communicationSkillsPoints',
          'communicationSkillsPossible', 'supportEffectivenessPoints', 'supportEffectivenessPossible',
          'callClosurePoints', 'callClosurePossible', 'overallFeedback', 'actionItems',
          'qualityStatus', 'status', 'sendEmail', 'emailTemplate', 'lastEmailed',
          'createdDate', 'lastUpdated', 'createdBy'
        ];
        
        sheet.appendRow(headers);
        sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold').setBackground('#E8EAED');
        sheet.setFrozenRows(1);
      }
      
      // Initialize export history sheet if needed
      let historySheet = ss.getSheetByName(QA_HISTORY_SHEET_NAME);
      if (!historySheet) {
        historySheet = ss.insertSheet(QA_HISTORY_SHEET_NAME);
        historySheet.appendRow(['name', 'date', 'format', 'url', 'exportedBy', 'recordCount']);
        historySheet.getRange(1, 1, 1, 6).setFontWeight('bold').setBackground('#E8EAED');
      }
      
      return {
        success: true,
        message: 'QA sheets initialized successfully'
      };
    } catch (e) {
      Logger.log('Error initializing QA sheet: ' + e.toString());
      return {
        success: false,
        message: 'Error: ' + e.toString()
      };
    }
  }
  
  /**
   * Save a QA review
   * @param {Object} review - The review data to save
   * @return {Object} Result with success flag and the review ID
   */
  function saveQAReview(review) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(QA_SHEET_NAME);
      
      if (!sheet) {
        return {
          success: false,
          message: 'QA sheet not found. Please initialize it first.'
        };
      }
      
      // Check if evaluation and action items are objects to convert to JSON
      if (review.evaluation && typeof review.evaluation !== 'string') {
        review.evaluation = JSON.stringify(review.evaluation);
      }
      
      if (review.actionItems && typeof review.actionItems !== 'string') {
        review.actionItems = JSON.stringify(review.actionItems);
      }
      
      // Generate a unique ID if this is a new review
      if (!review.id) {
        review.id = Utilities.getUuid();
        review.createdDate = new Date();
        review.createdBy = Session.getActiveUser().getEmail();
      }
      
      // Set last updated
      review.lastUpdated = new Date();
      
      // Find the review if it exists by ID
      const data = sheet.getDataRange().getValues();
      const headers = data[0];
      let rowIndex = -1;
      
      for (let i = 1; i < data.length; i++) {
        if (data[i][0] === review.id) {
          rowIndex = i + 1; // Sheet rows are 1-indexed but data array is 0-indexed
          break;
        }
      }
      
      // Create row array to write to sheet
      const rowData = [];
      headers.forEach(header => {
        rowData.push(review[header] !== undefined ? review[header] : '');
      });
      
      if (rowIndex > 0) {
        // Update existing review
        sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
      } else {
        // Add new review
        sheet.appendRow(rowData);
      }
      
      return {
        success: true,
        message: 'QA review saved successfully',
        reviewId: review.id
      };
    } catch (e) {
      Logger.log('Error saving QA review: ' + e.toString());
      return {
        success: false,
        message: 'Error: ' + e.toString()
      };
    }
  }
  
  /**
   * Get a QA review by ID
   * @param {string} id - The ID of the review to get
   * @return {Object} The review data or null if not found
   */
  function getQAReviewById(id) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(QA_SHEET_NAME);
      
      if (!sheet) {
        return null;
      }
      
      const data = sheet.getDataRange().getValues();
      const headers = data[0];
      
      for (let i = 1; i < data.length; i++) {
        if (data[i][0] === id) {
          const review = {};
          
          headers.forEach((header, index) => {
            review[header] = data[i][index];
          });
          
          // Parse JSON fields
          if (review.evaluation && typeof review.evaluation === 'string') {
            try {
              review.evaluation = JSON.parse(review.evaluation);
            } catch (e) {
              Logger.log('Error parsing evaluation JSON: ' + e.toString());
            }
          }
          
          if (review.actionItems && typeof review.actionItems === 'string') {
            try {
              review.actionItems = JSON.parse(review.actionItems);
            } catch (e) {
              Logger.log('Error parsing actionItems JSON: ' + e.toString());
            }
          }
          
          return review;
        }
      }
      
      return null;
    } catch (e) {
      Logger.log('Error getting QA review: ' + e.toString());
      return null;
    }
  }
  
  /**
   * Get all QA reviews with optional filtering
   * @param {Object} options - Filter options
   * @return {Array} Array of QA reviews
   */
  function getQAReviews(options = {}) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheet = ss.getSheetByName(QA_SHEET_NAME);
      
      if (!sheet) {
        return [];
      }
      
      const data = sheet.getDataRange().getValues();
      const headers = data[0];
      const reviews = [];
      
      // Default values if not provided
      const startDate = options.startDate || new Date(0); // Beginning of time
      const endDate = options.endDate || new Date(); // Now
      
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        const review = {};
        
        headers.forEach((header, index) => {
          review[header] = row[index];
        });
        
        // Apply filters
        
        // Date filter - Using interaction date
        const reviewDate = new Date(review.interactionDate);
        if (reviewDate < startDate || reviewDate > endDate) {
          continue;
        }
        
        // Counselor filter
        if (options.counselorEmail && review.counselorEmail !== options.counselorEmail) {
          continue;
        }
        
        // Status filter
        if (options.status && review.status !== options.status) {
          continue;
        }
        
        // Quality status filter (only apply to Complete reviews)
        if (options.qualityStatus && review.status === 'Complete' && review.qualityStatus !== options.qualityStatus) {
          continue;
        }
        
        // Parse JSON fields if needed
        if (options.includeDetails) {
          if (review.evaluation && typeof review.evaluation === 'string') {
            try {
              review.evaluation = JSON.parse(review.evaluation);
            } catch (e) {
              Logger.log('Error parsing evaluation JSON: ' + e.toString());
            }
          }
          
          if (review.actionItems && typeof review.actionItems === 'string') {
            try {
              review.actionItems = JSON.parse(review.actionItems);
            } catch (e) {
              Logger.log('Error parsing actionItems JSON: ' + e.toString());
            }
          }
        }
        
        reviews.push(review);
      }
      
      return reviews;
    } catch (e) {
      Logger.log('Error getting QA reviews: ' + e.toString());
      return [];
    }
  }
  
  /**
   * Get QA dashboard data with analytics
   * @param {Object} options - Filter options
   * @return {Object} Dashboard data and analytics
   */
  function getQADashboardData(options = {}) {
    try {
      // Get filtered reviews
      const reviews = getQAReviews({
        ...options,
        includeDetails: true
      });
      
      if (reviews.length === 0) {
        return {
          totalReviews: 0,
          excellentCount: 0,
          goodCount: 0,
          needsImprovementCount: 0,
          averageScore: 0,
          recentReviews: [],
          topPerformers: [],
          weeklyScoreTrend: {},
          monthlyScoreTrend: {},
          sectionScores: {
            callOpeningPercentage: 0,
            riskAssessmentPercentage: 0,
            communicationSkillsPercentage: 0,
            supportEffectivenessPercentage: 0,
            callClosurePercentage: 0
          }
        };
      }
      
      // Calculate summary stats
      const completedReviews = reviews.filter(r => r.status === 'Complete');
      const excellentCount = completedReviews.filter(r => r.qualityStatus === 'Excellent').length;
      const goodCount = completedReviews.filter(r => r.qualityStatus === 'Good').length;
      const needsImprovementCount = completedReviews.filter(r => r.qualityStatus === 'Needs Improvement').length;
      
      // Calculate average score
      let totalScore = 0;
      completedReviews.forEach(r => {
        totalScore += r.scorePercentage || 0;
      });
      const averageScore = completedReviews.length > 0 ? totalScore / completedReviews.length : 0;
      
      // Get recent reviews (latest 10)
      const recentReviews = [...reviews].sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated)).slice(0, 10);
      
      // Calculate weekly score trends
      const weeklyScoreTrend = calculateWeeklyTrends(completedReviews);
      
      // Calculate monthly score trends
      const monthlyScoreTrend = calculateMonthlyTrends(completedReviews);
      
      // Calculate section scores
      const sectionScores = calculateSectionScores(completedReviews);
      
      // Get top performers (counselors with highest average scores)
      const topPerformers = getTopPerformers(completedReviews);
      
      return {
        totalReviews: reviews.length,
        excellentCount: excellentCount,
        goodCount: goodCount,
        needsImprovementCount: needsImprovementCount,
        averageScore: averageScore,
        recentReviews: recentReviews,
        topPerformers: topPerformers,
        weeklyScoreTrend: weeklyScoreTrend,
        monthlyScoreTrend: monthlyScoreTrend,
        sectionScores: sectionScores
      };
    } catch (e) {
      Logger.log('Error getting QA dashboard data: ' + e.toString());
      return null;
    }
  }
  
  /**
   * Calculate weekly trends from review data
   * @param {Array} reviews - Array of completed reviews
   * @return {Object} Weekly trend data
   */
  function calculateWeeklyTrends(reviews) {
    const weeks = {};
    
    reviews.forEach(review => {
      const date = new Date(review.interactionDate);
      const year = date.getFullYear();
      const weekNumber = getWeekNumber(date);
      const weekKey = `${year}-W${weekNumber.toString().padStart(2, '0')}`;
      
      if (!weeks[weekKey]) {
        weeks[weekKey] = {
          totalScore: 0,
          reviewCount: 0,
          averageScore: 0
        };
      }
      
      weeks[weekKey].totalScore += review.scorePercentage || 0;
      weeks[weekKey].reviewCount++;
    });
    
    // Calculate averages
    Object.keys(weeks).forEach(week => {
      weeks[week].averageScore = weeks[week].totalScore / weeks[week].reviewCount;
    });
    
    return weeks;
  }
  
  /**
   * Calculate monthly trends from review data
   * @param {Array} reviews - Array of completed reviews
   * @return {Object} Monthly trend data
   */
  function calculateMonthlyTrends(reviews) {
    const months = {};
    
    reviews.forEach(review => {
      const date = new Date(review.interactionDate);
      const year = date.getFullYear();
      const month = date.getMonth() + 1; // 1-12
      const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
      
      if (!months[monthKey]) {
        months[monthKey] = {
          totalScore: 0,
          reviewCount: 0,
          averageScore: 0
        };
      }
      
      months[monthKey].totalScore += review.scorePercentage || 0;
      months[monthKey].reviewCount++;
    });
    
    // Calculate averages
    Object.keys(months).forEach(month => {
      months[month].averageScore = months[month].totalScore / months[month].reviewCount;
    });
    
    return months;
  }
  
  /**
   * Calculate section scores from completed reviews
   * @param {Array} reviews - Array of completed reviews
   * @return {Object} Section score percentages
   */
  function calculateSectionScores(reviews) {
    let totalCallOpeningPoints = 0;
    let totalCallOpeningPossible = 0;
    let totalRiskAssessmentPoints = 0;
    let totalRiskAssessmentPossible = 0;
    let totalCommunicationSkillsPoints = 0;
    let totalCommunicationSkillsPossible = 0;
    let totalSupportEffectivenessPoints = 0;
    let totalSupportEffectivenessPossible = 0;
    let totalCallClosurePoints = 0;
    let totalCallClosurePossible = 0;
    
    reviews.forEach(review => {
      totalCallOpeningPoints += review.callOpeningPoints || 0;
      totalCallOpeningPossible += review.callOpeningPossible || 0;
      totalRiskAssessmentPoints += review.riskAssessmentPoints || 0;
      totalRiskAssessmentPossible += review.riskAssessmentPossible || 0;
      totalCommunicationSkillsPoints += review.communicationSkillsPoints || 0;
      totalCommunicationSkillsPossible += review.communicationSkillsPossible || 0;
      totalSupportEffectivenessPoints += review.supportEffectivenessPoints || 0;
      totalSupportEffectivenessPossible += review.supportEffectivenessPossible || 0;
      totalCallClosurePoints += review.callClosurePoints || 0;
      totalCallClosurePossible += review.callClosurePossible || 0;
    });
    
    const calculatePercentage = (points, possible) => {
      return possible > 0 ? (points / possible) * 100 : 0;
    };
    
    return {
      callOpeningPercentage: calculatePercentage(totalCallOpeningPoints, totalCallOpeningPossible),
      riskAssessmentPercentage: calculatePercentage(totalRiskAssessmentPoints, totalRiskAssessmentPossible),
      communicationSkillsPercentage: calculatePercentage(totalCommunicationSkillsPoints, totalCommunicationSkillsPossible),
      supportEffectivenessPercentage: calculatePercentage(totalSupportEffectivenessPoints, totalSupportEffectivenessPossible),
      callClosurePercentage: calculatePercentage(totalCallClosurePoints, totalCallClosurePossible)
    };
  }
  
  /**
   * Get top performers based on average scores
   * @param {Array} reviews - Array of completed reviews
   * @return {Array} Top 5 performing counselors
   */
  function getTopPerformers(reviews) {
    const counselors = {};
    
    reviews.forEach(review => {
      const email = review.counselorEmail;
      
      if (!counselors[email]) {
        counselors[email] = {
          email: email,
          name: review.counselorName,
          totalScore: 0,
          reviewCount: 0
        };
      }
      
      counselors[email].totalScore += review.scorePercentage || 0;
      counselors[email].reviewCount++;
    });
    
    // Calculate average scores
    Object.values(counselors).forEach(counselor => {
      counselor.averageScore = counselor.totalScore / counselor.reviewCount;
    });
    
    // Get top 5 by average score
    return Object.values(counselors)
      .sort((a, b) => b.averageScore - a.averageScore)
      .slice(0, 5);
  }
  
  /**
   * Get week number from date
   * @param {Date} date - Date to get week number for
   * @return {number} Week number (1-53)
   */
  function getWeekNumber(date) {
    // Copy date to avoid modifying original
    const d = new Date(date);
    // Set to nearest Thursday (to match ISO 8601 week date definition)
    d.setHours(0, 0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    // Get first day of year
    const yearStart = new Date(d.getFullYear(), 0, 1);
    // Calculate week number
    return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
  }
  
  /**
   * Send QA review email to counselor
   * @param {string} reviewId - The ID of the review to email
   * @return {Object} Result with success flag
   */
  function sendQAReviewEmail(reviewId) {
    try {
      const review = getQAReviewById(reviewId);
      
      if (!review) {
        return {
          success: false,
          message: 'Review not found'
        };
      }
      
      if (review.status !== 'Complete') {
        return {
          success: false,
          message: 'Cannot send email for incomplete review'
        };
      }
      
      // Get counselor email
      const recipientEmail = review.counselorEmail;
      
      if (!recipientEmail) {
        return {
          success: false,
          message: 'Recipient email not found'
        };
      }
      
      // Determine email template to use
      let template = review.emailTemplate || 'standard';
      
      // Create email subject
      const subject = `QA Review Feedback - ${new Date(review.interactionDate).toLocaleDateString()}`;
      
      // Create email body
      let body = createEmailBody(review, template);
      
      // Send the email
      GmailApp.sendEmail(recipientEmail, subject, "", {
        htmlBody: body,
        name: "QA Feedback System",
        replyTo: Session.getActiveUser().getEmail()
      });
      
      // Update the review with email sent date
      review.lastEmailed = new Date();
      saveQAReview(review);
      
      return {
        success: true,
        message: 'Email sent successfully'
      };
    } catch (e) {
      Logger.log('Error sending QA review email: ' + e.toString());
      return {
        success: false,
        message: 'Error: ' + e.toString()
      };
    }
  }
  
  /**
   * Create HTML email body based on review and template
   * @param {Object} review - QA review data
   * @param {string} template - Email template to use
   * @return {string} HTML email body
   */
  function createEmailBody(review, template) {
    // Common header and footer
    const header = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background-color: #4e73df; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0;">QA Review Feedback</h1>
          <p style="margin: 10px 0 0;">Interaction Date: ${new Date(review.interactionDate).toLocaleDateString()}</p>
        </div>
        <div style="padding: 20px; background-color: #f8f9fc;">
    `;
    
    const footer = `
        </div>
        <div style="background-color: #f1f1f1; padding: 15px; text-align: center; font-size: 12px; color: #666;">
          <p>This is an automated message from the QA Review System.</p>
        </div>
      </div>
    `;
    
    // Determine status color
    let statusColor = '#e74a3b'; // Default to red for Needs Improvement
    if (review.qualityStatus === 'Excellent') {
      statusColor = '#1cc88a'; // Green
    } else if (review.qualityStatus === 'Good') {
      statusColor = '#36b9cc'; // Blue
    }
    
    // Status badge
    const statusBadge = `
      <div style="margin: 20px 0; text-align: center;">
        <div style="display: inline-block; background-color: ${statusColor}; color: white; padding: 10px 20px; border-radius: 20px; font-weight: bold;">
          ${review.qualityStatus} - ${review.scorePercentage.toFixed(1)}%
        </div>
      </div>
    `;
    
    // Score breakdown
    const scoreBreakdown = `
      <div style="margin-bottom: 20px; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0; color: #4e73df; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Score Breakdown</h3>
        <table style="width: 100%; border-collapse: collapse;">
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;"><strong>Call Opening:</strong></td>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;">${review.callOpeningPoints || 0} / ${review.callOpeningPossible || 0} points</td>
          </tr>
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;"><strong>Risk Assessment:</strong></td>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;">${review.riskAssessmentPoints || 0} / ${review.riskAssessmentPossible || 0} points</td>
          </tr>
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;"><strong>Communication Skills:</strong></td>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;">${review.communicationSkillsPoints || 0} / ${review.communicationSkillsPossible || 0} points</td>
          </tr>
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;"><strong>Support Effectiveness:</strong></td>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;">${review.supportEffectivenessPoints || 0} / ${review.supportEffectivenessPossible || 0} points</td>
          </tr>
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;"><strong>Call Closure:</strong></td>
            <td style="padding: 8px; border-bottom: 1px solid #eaecf4;">${review.callClosurePoints || 0} / ${review.callClosurePossible || 0} points</td>
          </tr>
          <tr>
            <td style="padding: 8px; font-weight: bold;"><strong>Total Score:</strong></td>
            <td style="padding: 8px; font-weight: bold;">${review.totalPoints || 0} / ${review.totalPossible || 0} points (${review.scorePercentage.toFixed(1)}%)</td>
          </tr>
        </table>
      </div>
    `;
    
    // Feedback section
    const feedbackSection = `
      <div style="margin-bottom: 20px; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0; color: #4e73df; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Feedback</h3>
        <p>${review.overallFeedback || 'No feedback provided.'}</p>
      </div>
    `;
    
    // Action items section (if any)
    let actionItemsSection = '';
    if (review.actionItems && review.actionItems.length > 0) {
      let actionItems;
      
      if (typeof review.actionItems === 'string') {
        try {
          actionItems = JSON.parse(review.actionItems);
        } catch (e) {
          actionItems = [];
        }
      } else {
        actionItems = review.actionItems;
      }
      
      if (actionItems.length > 0) {
        let actionItemsHtml = '';
        actionItems.forEach(item => {
          actionItemsHtml += `
            <li style="margin-bottom: 8px;">
              ${item.text}
              ${item.completed ? '<span style="color: #1cc88a;">(Completed)</span>' : ''}
            </li>
          `;
        });
        
        actionItemsSection = `
          <div style="margin-bottom: 20px; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
            <h3 style="margin-top: 0; color: #4e73df; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Action Items</h3>
            <ul style="padding-left: 20px;">
              ${actionItemsHtml}
            </ul>
          </div>
        `;
      }
    }
    
    // Create template-specific content
    let templateContent = '';
    
    if (template === 'development') {
      // Development focus template - emphasizes areas for improvement
      templateContent = `
        <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
          Dear ${review.counselorName},
        </p>
        <p style="line-height: 1.5; margin-bottom: 15px;">
          Thank you for your hard work and dedication. This QA review has identified some areas where we believe
          focused development would help enhance your interactions with contacts and improve overall service quality.
        </p>
        ${statusBadge}
        ${scoreBreakdown}
        <div style="margin-bottom: 20px; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4e73df; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Development Opportunities</h3>
          <p>${review.overallFeedback || 'No feedback provided.'}</p>
        </div>
        ${actionItemsSection}
        <p style="line-height: 1.5; margin-top: 30px;">
          We're here to support your growth. If you'd like to discuss these observations or need any additional resources,
          please don't hesitate to reach out to your supervisor.
        </p>
      `;
    } else if (template === 'recognition') {
      // Recognition template - emphasizes strengths and positive feedback
      templateContent = `
        <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
          Dear ${review.counselorName},
        </p>
        <p style="line-height: 1.5; margin-bottom: 15px;">
          Congratulations on your excellent performance! This QA review highlights the outstanding work you're doing
          and the positive impact you're making with our contacts.
        </p>
        ${statusBadge}
        ${scoreBreakdown}
        <div style="margin-bottom: 20px; background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <h3 style="margin-top: 0; color: #4e73df; border-bottom: 1px solid #eaecf4; padding-bottom: 10px;">Strengths & Recognition</h3>
          <p>${review.overallFeedback || 'No feedback provided.'}</p>
        </div>
        ${actionItemsSection}
        <p style="line-height: 1.5; margin-top: 30px;">
          Thank you for your commitment to excellence. Your dedication and skills are making a real difference in the lives
          of those we serve. Keep up the amazing work!
        </p>
      `;
    } else {
      // Standard template
      templateContent = `
        <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
          Dear ${review.counselorName},
        </p>
        <p style="line-height: 1.5; margin-bottom: 15px;">
          Below is your Quality Assurance review for the interaction on ${new Date(review.interactionDate).toLocaleDateString()}.
          This feedback is provided to help support your development and recognize your strengths.
        </p>
        ${statusBadge}
        ${scoreBreakdown}
        ${feedbackSection}
        ${actionItemsSection}
        <p style="line-height: 1.5; margin-top: 30px;">
          If you have any questions about this review or would like to discuss it further, please contact your supervisor.
        </p>
      `;
    }
    
    // Combine all sections
    return header + templateContent + footer;
  }
  
  /**
   * Export QA data with various options
   * @param {Object} options - Export options
   * @return {Object} Result with success flag and url
   */
  function exportQAData(options) {
    try {
      const exportName = options.exportName || 'QA Export';
      const format = options.format || 'excel';
      
      // Get the data based on filters
      const reviews = getQAReviews({
        ...options,
        includeDetails: true
      });
      
      if (reviews.length === 0) {
        return {
          success: false,
          message: 'No QA data found matching the specified criteria'
        };
      }
      
      // Record export in history
      const result = {
        name: exportName,
        format: format,
        recordCount: reviews.length
      };
      
      // Export based on format
      if (format === 'csv') {
        // CSV export logic here
        return {
          success: true,
          message: 'Exported ' + reviews.length + ' reviews to CSV',
          url: 'CSV_URL_HERE'
        };
      } else if (format === 'pdf') {
        // PDF export logic here
        return {
          success: true,
          message: 'Exported ' + reviews.length + ' reviews to PDF',
          url: 'PDF_URL_HERE'
        };
      } else if (format === 'gsheet') {
        // Google Sheet export logic here
        return {
          success: true,
          message: 'Exported ' + reviews.length + ' reviews to Google Sheet',
          url: 'GSHEET_URL_HERE'
        };
      } else {
        // Default to Excel-like export
        const ss = SpreadsheetApp.create(exportName);
        
        // Create main data sheet
        const mainSheet = ss.getActiveSheet();
        mainSheet.setName('QA Reviews');
        
        // Define columns for main sheet
        const columns = [
          'ID', 'Interaction Date', 'Counselor Name', 'Interaction Type',
          'Interaction ID', 'Reviewer', 'Score', 'Status', 'Quality Status'
        ];
        
        // Add headers
        mainSheet.appendRow(columns);
        
        // Add data rows
        reviews.forEach(review => {
          const interactionDate = review.interactionDate instanceof Date ? 
            review.interactionDate : new Date(review.interactionDate);
          
          mainSheet.appendRow([
            review.id,
            interactionDate,
            review.counselorName,
            review.interactionType,
            review.interactionId,
            review.reviewer,
            review.scorePercentage || 0,
            review.status,
            review.qualityStatus || ''
          ]);
        });
        
        // Format header row
        mainSheet.getRange(1, 1, 1, columns.length).setFontWeight('bold').setBackground('#E8EAED');
        
        // Record export in history with URL
        result.url = ss.getUrl();
        recordExport(result);
        
        return {
          success: true,
          message: 'Exported ' + reviews.length + ' reviews to spreadsheet',
          url: ss.getUrl()
        };
      }
    } catch (e) {
      Logger.log('Error exporting QA data: ' + e.toString());
      return {
        success: false,
        message: 'Error: ' + e.toString()
      };
    }
  }
  
  /**
   * Record an export in the history sheet
   * @param {Object} exportData - Data about the export
   */
  function recordExport(exportData) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName(QA_HISTORY_SHEET_NAME);
      
      if (!sheet) {
        // Create the history sheet if it doesn't exist
        sheet = ss.insertSheet(QA_HISTORY_SHEET_NAME);
        sheet.appendRow(['name', 'date', 'format', 'url', 'exportedBy', 'recordCount']);
        sheet.getRange(1, 1, 1, 6).setFontWeight('bold').setBackground('#E8EAED');
      }
      
      // Add the export record
      sheet.appendRow([
        exportData.name,
        new Date(),
        exportData.format,
        exportData.url || '',
        Session.getActiveUser().getEmail(),
        exportData.recordCount || 0
      ]);
      
    } catch (e) {
      Logger.log('Error recording export: ' + e.toString());
    }
  }
  
  /**
   * Get export history data
   * @return {Array} List of previous exports
   */
  function getQAExportHistory() {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName(QA_HISTORY_SHEET_NAME);
      
      if (!sheet) {
        // Create the history sheet if it doesn't exist
        sheet = ss.insertSheet(QA_HISTORY_SHEET_NAME);
        sheet.appendRow(['name', 'date', 'format', 'url', 'exportedBy', 'recordCount']);
        sheet.getRange(1, 1, 1, 6).setFontWeight('bold').setBackground('#E8EAED');
        return [];
      }
      
      const data = sheet.getDataRange().getValues();
      if (data.length <= 1) {
        return []; // Only header row exists
      }
      
      const headers = data[0];
      const exports = [];
      
      // Convert data to objects
      for (let i = 1; i < data.length; i++) {
        const exportItem = {};
        
        for (let j = 0; j < headers.length; j++) {
          exportItem[headers[j]] = data[i][j];
        }
        
        exports.push(exportItem);
      }
      
      return exports;
    } catch (e) {
      Logger.log('Error getting export history: ' + e.toString());
      return [];
    }
  }
  
  // Combine all functions from original QAService and new implementations
  return {
    // Original functions
    createReview: function(reviewData) {
      // Input validation
      if (!reviewData.teamMember || !reviewData.criteria) {
        throw new Error('Team member and criteria are required for QA reviews');
      }
      
      var sheet = getQASheet_();
      var reviewId = Utilities.getUuid();
      var currentUser = Session.getActiveUser().getEmail();
      var now = new Date();
      
      // Calculate total score
      var totalScore = 0;
      var maxScore = 0;
      
      Object.keys(reviewData.criteria).forEach(function(key) {
        totalScore += reviewData.criteria[key].score || 0;
        maxScore += reviewData.criteria[key].maxScore || 0;
      });
      
      var finalScore = maxScore > 0 ? (totalScore / maxScore) * 100 : 0;
      
      var rowData = [
        reviewId,
        reviewData.date ? new Date(reviewData.date) : now,
        reviewData.teamMember,
        reviewData.interactionId || '',
        reviewData.type || 'Call',
        JSON.stringify(reviewData.criteria),
        finalScore.toFixed(2),
        reviewData.feedback || '',
        currentUser,
        now,
        now
      ];
      
      var lastRow = Math.max(sheet.getLastRow(), 1);
      sheet.getRange(lastRow + 1, 1, 1, rowData.length).setValues([rowData]);
      
      return reviewId;
    },
    
    getReviews: function(filters) {
      var sheet = getQASheet_();
      var data = sheet.getDataRange().getValues();
      var reviews = [];
      
      // Skip header row
      for (var i = 1; i < data.length; i++) {
        var row = data[i];
        
        try {
          var criteria = JSON.parse(row[5]);
          
          var review = {
            id: row[0],
            date: row[1],
            teamMember: row[2],
            interactionId: row[3],
            type: row[4],
            criteria: criteria,
            totalScore: parseFloat(row[6]),
            feedback: row[7],
            createdBy: row[8],
            createdDate: row[9],
            lastUpdated: row[10]
          };
          
          // Apply filters if provided
          if (filters) {
            if (filters.id && review.id !== filters.id) continue;
            if (filters.teamMember && review.teamMember !== filters.teamMember) continue;
            if (filters.type && review.type !== filters.type) continue;
            if (filters.minScore && review.totalScore < filters.minScore) continue;
            if (filters.maxScore && review.totalScore > filters.maxScore) continue;
            if (filters.startDate && review.date < filters.startDate) continue;
            if (filters.endDate && review.date > filters.endDate) continue;
            if (filters.createdBy && review.createdBy !== filters.createdBy) continue;
          }
          
          reviews.push(review);
        } catch (e) {
          // Skip malformed rows
          Logger.log('Error parsing row ' + (i+1) + ': ' + e.toString());
        }
      }
      
      return reviews;
    },
    
    getReview: function(reviewId) {
      var reviews = this.getReviews({id: reviewId});
      return reviews.length > 0 ? reviews[0] : null;
    },
    
    updateReview: function(reviewId, reviewData) {
      var sheet = getQASheet_();
      var data = sheet.getDataRange().getValues();
      var rowIndex = -1;
      
      // Find the review by ID
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === reviewId) {
          rowIndex = i + 1; // +1 because i is 0-based and row indices are 1-based
          break;
        }
      }
      
      if (rowIndex === -1) {
        throw new Error('Review not found');
      }
      
      // Update the fields that are provided
      var row = data[rowIndex-1];
      
      if (reviewData.date !== undefined) row[1] = new Date(reviewData.date);
      if (reviewData.teamMember !== undefined) row[2] = reviewData.teamMember;
      if (reviewData.interactionId !== undefined) row[3] = reviewData.interactionId;
      if (reviewData.type !== undefined) row[4] = reviewData.type;
      
      if (reviewData.criteria !== undefined) {
        // Recalculate total score
        var totalScore = 0;
        var maxScore = 0;
        
        Object.keys(reviewData.criteria).forEach(function(key) {
          totalScore += reviewData.criteria[key].score || 0;
          maxScore += reviewData.criteria[key].maxScore || 0;
        });
        
        var finalScore = maxScore > 0 ? (totalScore / maxScore) * 100 : 0;
        
        row[5] = JSON.stringify(reviewData.criteria);
        row[6] = finalScore.toFixed(2);
      }
      
      if (reviewData.feedback !== undefined) row[7] = reviewData.feedback;
      row[10] = new Date(); // Last updated
      
      sheet.getRange(rowIndex, 1, 1, row.length).setValues([row]);
      
      return true;
    },
    
    deleteReview: function(reviewId) {
      var sheet = getQASheet_();
      var data = sheet.getDataRange().getValues();
      
      // Find the review by ID
      for (var i = 1; i < data.length; i++) {
        if (data[i][0] === reviewId) {
          sheet.deleteRow(i + 1); // +1 because i is 0-based and row indices are 1-based
          return true;
        }
      }
      
      return false; // Review not found
    },
    
    getReviewSummary: function(filters) {
      var reviews = this.getReviews(filters);
      
      if (reviews.length === 0) {
        return {
          count: 0,
          averageScore: 0,
          typeBreakdown: {},
          criteriaBreakdown: {}
        };
      }
      
      var summary = {
        count: reviews.length,
        averageScore: 0,
        typeBreakdown: {},
        criteriaBreakdown: {}
      };
      
      var totalScore = 0;
      var criteriaScores = {};
      var criteriaCounts = {};
      
      reviews.forEach(function(review) {
        // Calculate average score
        totalScore += review.totalScore;
        
        // Count by type
        if (!summary.typeBreakdown[review.type]) {
          summary.typeBreakdown[review.type] = {
            count: 0,
            averageScore: 0
          };
        }
        summary.typeBreakdown[review.type].count++;
        summary.typeBreakdown[review.type].averageScore += review.totalScore;
        
        // Track criteria scores
        Object.keys(review.criteria).forEach(function(criteriaName) {
          var criteria = review.criteria[criteriaName];
          
          if (!criteriaScores[criteriaName]) {
            criteriaScores[criteriaName] = 0;
            criteriaCounts[criteriaName] = 0;
          }
          
          criteriaScores[criteriaName] += (criteria.score / criteria.maxScore) * 100;
          criteriaCounts[criteriaName]++;
        });
      });
      
      // Calculate averages
      summary.averageScore = totalScore / reviews.length;
      
      // Calculate type breakdown averages
      Object.keys(summary.typeBreakdown).forEach(function(type) {
        var typeData = summary.typeBreakdown[type];
        typeData.averageScore = typeData.averageScore / typeData.count;
      });
      
      // Calculate criteria breakdown
      Object.keys(criteriaScores).forEach(function(criteriaName) {
        summary.criteriaBreakdown[criteriaName] = criteriaScores[criteriaName] / criteriaCounts[criteriaName];
      });
      
      return summary;
    },
    
    getTeamQAComparison: function(startDate, endDate) {
      var filters = {};
      if (startDate) filters.startDate = startDate;
      if (endDate) filters.endDate = endDate;
      
      var reviews = this.getReviews(filters);
      var teamScores = {};
      
      reviews.forEach(function(review) {
        var teamMember = review.teamMember;
        
        if (!teamScores[teamMember]) {
          teamScores[teamMember] = {
            totalScore: 0,
            count: 0,
            averageScore: 0,
            byType: {},
            byCriteria: {}
          };
        }
        
        // Add to total score
        teamScores[teamMember].totalScore += review.totalScore;
        teamScores[teamMember].count++;
        
        // Track by type
        var type = review.type;
        if (!teamScores[teamMember].byType[type]) {
          teamScores[teamMember].byType[type] = {
            totalScore: 0,
            count: 0
          };
        }
        teamScores[teamMember].byType[type].totalScore += review.totalScore;
        teamScores[teamMember].byType[type].count++;
        
        // Track by criteria
        Object.keys(review.criteria).forEach(function(criteriaName) {
          var criteria = review.criteria[criteriaName];
          
          if (!teamScores[teamMember].byCriteria[criteriaName]) {
            teamScores[teamMember].byCriteria[criteriaName] = {
              totalScore: 0,
              totalMaxScore: 0,
              count: 0
            };
          }
          
          teamScores[teamMember].byCriteria[criteriaName].totalScore += criteria.score;
          teamScores[teamMember].byCriteria[criteriaName].totalMaxScore += criteria.maxScore;
          teamScores[teamMember].byCriteria[criteriaName].count++;
        });
      });
      
      // Calculate averages
      Object.keys(teamScores).forEach(function(teamMember) {
        var memberData = teamScores[teamMember];
        
        // Overall average
        memberData.averageScore = memberData.totalScore / memberData.count;
        
        // Averages by type
        Object.keys(memberData.byType).forEach(function(type) {
          var typeData = memberData.byType[type];
          typeData.averageScore = typeData.totalScore / typeData.count;
        });
        
        // Averages by criteria
        Object.keys(memberData.byCriteria).forEach(function(criteria) {
          var criteriaData = memberData.byCriteria[criteria];
          criteriaData.averageScore = (criteriaData.totalScore / criteriaData.totalMaxScore) * 100;
        });
      });
      
      return teamScores;
    },
    
    exportQAData: function(filters) {
      var reviews = this.getReviews(filters);
      
      if (reviews.length === 0) {
        throw new Error('No QA reviews found matching the criteria');
      }
      
      var ss = SpreadsheetApp.create('QA Reviews Export - ' + 
                                   Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd'));
      var sheet = ss.getActiveSheet().setName('QA Reviews');
      
      // Create headers
      var headers = [
        'Date', 'Team Member', 'Interaction ID', 'Type',
        'Total Score', 'Feedback'
      ];
      
      // Add criteria headers - get all unique criteria from reviews
      var allCriteria = {};
      reviews.forEach(function(review) {
        Object.keys(review.criteria).forEach(function(criteriaName) {
          allCriteria[criteriaName] = true;
        });
      });
      
      var criteriaHeaders = Object.keys(allCriteria);
      headers = headers.concat(criteriaHeaders);
      
      // Add creator and date columns
      headers.push('Created By', 'Created Date');
      
      // Set headers
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
      
      // Add data
      var data = reviews.map(function(review) {
        var row = [
          Utilities.formatDate(review.date, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
          review.teamMember,
          review.interactionId,
          review.type,
          review.totalScore,
          review.feedback
        ];
        
        // Add criteria scores
        criteriaHeaders.forEach(function(criteriaName) {
          var criteria = review.criteria[criteriaName];
          if (criteria) {
            var scoreFormatted = criteria.score + '/' + criteria.maxScore;
            row.push(scoreFormatted);
          } else {
            row.push('N/A');
          }
        });
        
        // Add creator and date
        row.push(review.createdBy);
        row.push(Utilities.formatDate(review.createdDate, Session.getScriptTimeZone(), 'yyyy-MM-dd'));
        
        return row;
      });
      
      if (data.length > 0) {
        sheet.getRange(2, 1, data.length, headers.length).setValues(data);
      }
      
      // Auto-size columns and apply formatting
      for (var i = 1; i <= headers.length; i++) {
        sheet.autoResizeColumn(i);
      }
      
      // Add summary sheet
      var summarySheet = ss.insertSheet('Summary');
      var summary = this.getReviewSummary(filters);
      
      // Add overall summary
      summarySheet.getRange('A1').setValue('QA Reviews Summary').setFontWeight('bold');
      summarySheet.getRange('A3').setValue('Total Reviews:');
      summarySheet.getRange('B3').setValue(summary.count);
      summarySheet.getRange('A4').setValue('Average Score:');
      summarySheet.getRange('B4').setValue(summary.averageScore.toFixed(2) + '%');
      
      // Add type breakdown
      var row = 6;
      summarySheet.getRange('A' + row).setValue('Type Breakdown').setFontWeight('bold');
      row++;
      summarySheet.getRange('A' + row).setValue('Type');
      summarySheet.getRange('B' + row).setValue('Count');
      summarySheet.getRange('C' + row).setValue('Average Score');
      
      Object.keys(summary.typeBreakdown).forEach(function(type) {
        row++;
        var typeData = summary.typeBreakdown[type];
        summarySheet.getRange('A' + row).setValue(type);
        summarySheet.getRange('B' + row).setValue(typeData.count);
        summarySheet.getRange('C' + row).setValue(typeData.averageScore.toFixed(2) + '%');
      });
      
      // Add criteria breakdown
      row += 2;
      summarySheet.getRange('A' + row).setValue('Criteria Breakdown').setFontWeight('bold');
      row++;
      summarySheet.getRange('A' + row).setValue('Criteria');
      summarySheet.getRange('B' + row).setValue('Average Score');
      
      Object.keys(summary.criteriaBreakdown).forEach(function(criteria) {
        row++;
        summarySheet.getRange('A' + row).setValue(criteria);
        summarySheet.getRange('B' + row).setValue(summary.criteriaBreakdown[criteria].toFixed(2) + '%');
      });
      
      // Auto-size columns
      for (var i = 1; i <= 3; i++) {
        summarySheet.autoResizeColumn(i);
      }
      
      return ss.getUrl();
    },
    
    getDefaultCriteria: function() {
      return {
        'Call Opening': {
          score: 0,
          maxScore: 10,
          notes: ''
        },
        'Risk Assessment': {
          score: 0,
          maxScore: 10,
          notes: ''
        },
        'Communication Skills': {
          score: 0,
          maxScore: 10,
          notes: ''
        },
        'Support Effectiveness': {
          score: 0,
          maxScore: 10,
          notes: ''
        },
        'Call Closure': {
          score: 0,
          maxScore: 10,
          notes: ''
        }
      };
    },
    
    // New functions
    initializeSheet: initializeSheet,
    saveQAReview: saveQAReview,
    getQAReviewById: getQAReviewById,
    getQAReviews: getQAReviews,
    getQADashboardData: getQADashboardData,
    sendQAReviewEmail: sendQAReviewEmail,
    exportQAData: exportQAData,
    getQAExportHistory: getQAExportHistory
  };
})();

/**
 * Get the QAService instance
 * @return {Object} - QAService instance
 */
function getQAService() {
  return QAService;
}

/**
 * Navigation functions for opening different QA pages
 */
function openQAReviewForm(reviewId) {
  const url = reviewId ? '?id=' + reviewId : '';
  const html = HtmlService.createTemplateFromFile('HTML/QA/qa-review-form')
    .evaluate()
    .setTitle('QA Review Form')
    .setWidth(1200)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'QA Review Form');
}

function openQADashboard() {
  const html = HtmlService.createTemplateFromFile('HTML/QA/qa-dashboard')
    .evaluate()
    .setTitle('QA Dashboard')
    .setWidth(1200)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'QA Dashboard');
}

function openQAReports(reviewId) {
  const url = reviewId ? '?id=' + reviewId : '';
  const html = HtmlService.createTemplateFromFile('HTML/QA/qa-reports')
    .evaluate()
    .setTitle('QA Reports')
    .setWidth(1200)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'QA Reports');
}

function openQAReportWithId(reviewId) {
  openQAReports(reviewId);
}

function openQAExport() {
  const html = HtmlService.createTemplateFromFile('HTML/QA/qa-export')
    .evaluate()
    .setTitle('QA Export')
    .setWidth(1200)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'QA Export');
}
// Inside QAService's IIFE
function getTeamMembers() {
  try {
    // Get team members from your TeamMemberService
    return getTeamMemberService().getTeamMembers();
  } catch (e) {
    Logger.log('Error getting team members: ' + e.toString());
    return [];
  }
}
/******************************************
 * ADDITIONAL QA FUNCTIONS
 ******************************************/

/**
 * Gets QA categories from settings or defaults
 * @return {Array} List of QA categories
 */
function getQACategories() {
  try {
    const configService = getConfigService();
    const categoriesStr = configService.getSetting('default_qa_categories');
    return categoriesStr ? categoriesStr.split(',') : [
      'Customer Service',
      'Technical Knowledge',
      'Process Adherence',
      'Soft Skills'
    ];
  } catch (e) {
    logError('getQACategories', e.toString());
    return [
      'Customer Service',
      'Technical Knowledge',
      'Process Adherence',
      'Soft Skills'
    ];
  }
}

/**
 * Gets QA scoring rubric
 * @return {Object} QA scoring rubric
 */
function getQAScoringRubric() {
  try {
    const qaService = getQAService();
    return qaService.getDefaultCriteria();
  } catch (e) {
    logError('getQAScoringRubric', e.toString());
    return {
      'Call Opening': {
        score: 0,
        maxScore: 10,
        notes: ''
      },
      'Risk Assessment': {
        score: 0,
        maxScore: 10,
        notes: ''
      },
      'Communication Skills': {
        score: 0,
        maxScore: 10,
        notes: ''
      },
      'Support Effectiveness': {
        score: 0,
        maxScore: 10,
        notes: ''
      },
      'Call Closure': {
        score: 0,
        maxScore: 10,
        notes: ''
      }
    };
  }
}

/**
 * Gets QA review summary with statistics
 * @param {Object} filters - Filter options
 * @return {Object} QA review summary
 */
function getQAReviewSummary(filters = {}) {
  try {
    const qaService = getQAService();
    return qaService.getReviewSummary(filters);
  } catch (e) {
    logError('getQAReviewSummary', e.toString(), {filters: JSON.stringify(filters)});
    return {
      count: 0,
      averageScore: 0,
      typeBreakdown: {},
      criteriaBreakdown: {}
    };
  }
}

/**
 * Gets QA statistics for a team member
 * @param {String} email - Team member email
 * @return {Object} QA statistics
 */
function getQAStatsByTeamMember(email) {
  try {
    const qaService = getQAService();
    return qaService.getReviews({teamMember: email});
  } catch (e) {
    logError('getQAStatsByTeamMember', e.toString(), {email: email});
    return [];
  }
}

/**
 * Gets QA team comparison data
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @return {Object} Team comparison data
 */
function getQATeamComparison(startDate, endDate) {
  try {
    const qaService = getQAService();
    return qaService.getTeamQAComparison(startDate, endDate);
  } catch (e) {
    logError('getQATeamComparison', e.toString(), {
      startDate: startDate ? startDate.toISOString() : null,
      endDate: endDate ? endDate.toISOString() : null
    });
    return {};
  }
}

/**
 * Gets QA trend data for charts
 * @param {Object} options - Filter options
 * @return {Object} QA trend data
 */
function getQATrendData(options = {}) {
  try {
    const qaService = getQAService();
    const reviews = qaService.getQAReviews(options);
    
    // Process the reviews to get trend data
    const monthlyData = {};
    const weeklyData = {};
    
    reviews.forEach(review => {
      const date = new Date(review.interactionDate);
      
      // Monthly trend
      const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      if (!monthlyData[monthKey]) {
        monthlyData[monthKey] = {
          totalScore: 0,
          count: 0
        };
      }
      monthlyData[monthKey].totalScore += review.scorePercentage || 0;
      monthlyData[monthKey].count++;
      
      // Weekly trend
      const weekNumber = getWeekNumber(date);
      const weekKey = `${date.getFullYear()}-W${String(weekNumber).padStart(2, '0')}`;
      if (!weeklyData[weekKey]) {
        weeklyData[weekKey] = {
          totalScore: 0,
          count: 0
        };
      }
      weeklyData[weekKey].totalScore += review.scorePercentage || 0;
      weeklyData[weekKey].count++;
    });
    
    // Calculate averages
    Object.keys(monthlyData).forEach(key => {
      monthlyData[key].average = monthlyData[key].totalScore / monthlyData[key].count;
    });
    
    Object.keys(weeklyData).forEach(key => {
      weeklyData[key].average = weeklyData[key].totalScore / weeklyData[key].count;
    });
    
    return {
      monthly: monthlyData,
      weekly: weeklyData
    };
  } catch (e) {
    logError('getQATrendData', e.toString(), {options: JSON.stringify(options)});
    return {
      monthly: {},
      weekly: {}
    };
  }
}

/**
 * Helper function to get week number from date
 * @param {Date} date - Date to get week number for
 * @return {number} Week number (1-53)
 */
function getWeekNumber(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

/**
 * Gets team members who need QA reviews
 * @param {Number} days - Days threshold (default: 30)
 * @return {Array} Team members needing reviews
 */
function getTeamMembersNeedingQAReview(days = 30) {
  try {
    const teamService = getTeamService();
    const qaService = getQAService();
    
    // Get active team members
    const teamMembers = teamService.getTeamMembers({status: 'Active'});
    
    // Get QA reviews for each team member
    const result = [];
    const now = new Date();
    const threshold = days * 24 * 60 * 60 * 1000; // Convert days to milliseconds
    
    teamMembers.forEach(member => {
      const reviews = qaService.getQAReviews({counselorEmail: member.email});
      
      // Sort reviews by date (newest first)
      reviews.sort((a, b) => new Date(b.interactionDate) - new Date(a.interactionDate));
      
      if (reviews.length === 0) {
        // No reviews ever
        result.push({
          ...member,
          lastReviewDate: null,
          daysSinceLastReview: null,
          needsReview: true,
          reason: 'No previous reviews'
        });
      } else {
        // Check the most recent review date
        const lastReview = reviews[0];
        const lastReviewDate = new Date(lastReview.interactionDate);
        const timeSince = now.getTime() - lastReviewDate.getTime();
        const daysSince = Math.floor(timeSince / (24 * 60 * 60 * 1000));
        
        if (timeSince > threshold) {
          result.push({
            ...member,
            lastReviewDate: lastReviewDate,
            daysSinceLastReview: daysSince,
            needsReview: true,
            reason: 'Last review was ' + daysSince + ' days ago'
          });
        }
      }
    });
    
    return result;
  } catch (e) {
    logError('getTeamMembersNeedingQAReview', e.toString(), {days: days});
    return [];
  }
}

/**
 * Creates a new QA review
 * @param {Object} reviewData - Review data
 * @return {Object} Result with success flag
 */
function createQAReview(reviewData) {
  try {
    const qaService = getQAService();
    const result = qaService.createReview(reviewData);
    
    return {
      success: true,
      reviewId: result,
      message: 'QA review created successfully'
    };
  } catch (e) {
    logError('createQAReview', e.toString(), {reviewData: JSON.stringify(reviewData)});
    return {
      success: false,
      message: 'Error creating QA review: ' + e.toString()
    };
  }
}

/**
 * Updates an existing QA review
 * @param {String} reviewId - ID of review to update
 * @param {Object} reviewData - Updated review data
 * @return {Object} Result with success flag
 */
function updateQAReview(reviewId, reviewData) {
  try {
    const qaService = getQAService();
    const result = qaService.updateReview(reviewId, reviewData);
    
    return {
      success: result,
      reviewId: reviewId,
      message: result ? 'QA review updated successfully' : 'Failed to update QA review'
    };
  } catch (e) {
    logError('updateQAReview', e.toString(), {
      reviewId: reviewId,
      reviewData: JSON.stringify(reviewData)
    });
    return {
      success: false,
      message: 'Error updating QA review: ' + e.toString()
    };
  }
}

/**
 * Deletes a QA review
 * @param {String} reviewId - ID of review to delete
 * @return {Object} Result with success flag
 */
function deleteQAReview(reviewId) {
  try {
    const qaService = getQAService();
    const result = qaService.deleteReview(reviewId);
    
    return {
      success: result,
      message: result ? 'QA review deleted successfully' : 'Review not found'
    };
  } catch (e) {
    logError('deleteQAReview', e.toString(), {reviewId: reviewId});
    return {
      success: false,
      message: 'Error deleting QA review: ' + e.toString()
    };
  }
}

/**
 * Opens the QA team comparison view
 */
function openQATeamComparison() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/QA/qa-team-comparison')
      .evaluate()
      .setWidth(1200)
      .setHeight(800)
      .setTitle('QA Team Comparison');
    
    SpreadsheetApp.getUi().showModalDialog(html, 'QA Team Comparison');
  } catch (e) {
    logError('openQATeamComparison', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the QA trend analysis view
 */
function openQATrendAnalysis() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/QA/qa-trend-analysis')
      .evaluate()
      .setWidth(1200)
      .setHeight(800)
      .setTitle('QA Trend Analysis');
    
    SpreadsheetApp.getUi().showModalDialog(html, 'QA Trend Analysis');
  } catch (e) {
    logError('openQATrendAnalysis', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the QA settings page
 */
function openQASettings() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/QA/qa-settings')
      .evaluate()
      .setWidth(800)
      .setHeight(600)
      .setTitle('QA Settings');
    
    SpreadsheetApp.getUi().showModalDialog(html, 'QA Settings');
  } catch (e) {
    logError('openQASettings', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the QA team comparison view
 */
function openQATeamComparison() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/QA/qa-team-comparison')
      .evaluate()
      .setWidth(1200)
      .setHeight(800)
      .setTitle('QA Team Comparison');
    
    SpreadsheetApp.getUi().showModalDialog(html, 'QA Team Comparison');
  } catch (e) {
    logError('openQATeamComparison', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the QA trend analysis view
 */
function openQATrendAnalysis() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/QA/qa-trend-analysis')
      .evaluate()
      .setWidth(1200)
      .setHeight(800)
      .setTitle('QA Trend Analysis');
    
    SpreadsheetApp.getUi().showModalDialog(html, 'QA Trend Analysis');
  } catch (e) {
    logError('openQATrendAnalysis', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Opens the QA backup and maintenance view
 */
function openQABackupMaintenance() {
  try {
    var html = HtmlService.createTemplateFromFile('HTML/QA/qa-backup-maintenance')
      .evaluate()
      .setWidth(800)
      .setHeight(600)
      .setTitle('QA Backup & Maintenance');
    
    SpreadsheetApp.getUi().showModalDialog(html, 'QA Backup & Maintenance');
  } catch (e) {
    logError('openQABackupMaintenance', e.toString());
    SpreadsheetApp.getUi().alert('Error: ' + e.toString());
  }
}

/**
 * Gets current QA system settings
 * @return {Object} Current QA settings
 */
function getQASystemSettings() {
  try {
    // Attempt to get settings from ConfigService if available
    if (typeof getConfigService === 'function') {
      const configService = getConfigService();
      
      return {
        reviewRubric: configService.getSetting('qa_review_rubric') || getQAService().getScoringRubric(),
        reviewCriteria: configService.getSetting('qa_review_criteria') || getQAService().getDefaultEvaluationCriteria(),
        emailTemplates: configService.getSetting('qa_email_templates') || getDefaultEmailTemplates(),
        retentionPeriod: parseInt(configService.getSetting('qa_retention_days')) || 365,
        autoBackupEnabled: configService.getSetting('qa_auto_backup') === 'true',
        backupFrequency: configService.getSetting('qa_backup_frequency') || 'monthly'
      };
    }
    
    // Fallback to defaults if ConfigService not available
    return {
      reviewRubric: getQAService().getScoringRubric(),
      reviewCriteria: getQAService().getDefaultEvaluationCriteria(),
      emailTemplates: getDefaultEmailTemplates(),
      retentionPeriod: 365,
      autoBackupEnabled: false,
      backupFrequency: 'monthly'
    };
  } catch (e) {
    logError('getQASystemSettings', e.toString());
    return {
      reviewRubric: {},
      reviewCriteria: {},
      emailTemplates: {},
      retentionPeriod: 365,
      autoBackupEnabled: false,
      backupFrequency: 'monthly'
    };
  }
}

/**
 * Saves QA system settings
 * @param {Object} settings - QA settings to save
 * @return {Object} Result with success flag
 */
function saveQASystemSettings(settings) {
  try {
    // Validate settings
    if (!settings) {
      return {
        success: false,
        message: 'No settings provided'
      };
    }
    
    // Save settings using ConfigService if available
    if (typeof getConfigService === 'function') {
      const configService = getConfigService();
      
      // Save each setting
      if (settings.reviewRubric) {
        configService.saveSetting('qa_review_rubric', settings.reviewRubric);
      }
      
      if (settings.reviewCriteria) {
        configService.saveSetting('qa_review_criteria', settings.reviewCriteria);
      }
      
      if (settings.emailTemplates) {
        configService.saveSetting('qa_email_templates', settings.emailTemplates);
      }
      
      if (settings.retentionPeriod) {
        configService.saveSetting('qa_retention_days', settings.retentionPeriod.toString());
      }
      
      if (settings.autoBackupEnabled !== undefined) {
        configService.saveSetting('qa_auto_backup', settings.autoBackupEnabled.toString());
      }
      
      if (settings.backupFrequency) {
        configService.saveSetting('qa_backup_frequency', settings.backupFrequency);
      }
      
      return {
        success: true,
        message: 'QA settings saved successfully'
      };
    } else {
      return {
        success: false,
        message: 'Configuration service not available'
      };
    }
  } catch (e) {
    logError('saveQASystemSettings', e.toString());
    return {
      success: false,
      message: 'Error saving QA settings: ' + e.toString()
    };
  }
}

/**
 * Gets default email templates for QA reviews
 * @return {Object} Default email templates
 */
function getDefaultEmailTemplates() {
  return {
    standard: {
      name: 'Standard',
      description: 'Standard template for all QA reviews'
    },
    development: {
      name: 'Development Focus',
      description: 'Template focused on areas needing improvement'
    },
    recognition: {
      name: 'Recognition',
      description: 'Template highlighting strengths and accomplishments'
    }
  };
}

/**
 * Gets a date range based on range type
 * @param {String} rangeType - Type of range (week, month, quarter, year, etc.)
 * @param {Date} customStart - Custom start date (optional)
 * @param {Date} customEnd - Custom end date (optional)
 * @return {Object} Date range with start and end dates
 */
function getDateRange(rangeType, customStart, customEnd) {
  try {
    const now = new Date();
    let startDate, endDate;
    
    if (rangeType === 'custom' && customStart && customEnd) {
      startDate = new Date(customStart);
      endDate = new Date(customEnd);
    } else if (rangeType === 'today') {
      startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
    } else if (rangeType === 'yesterday') {
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      startDate = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
      endDate = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);
    } else if (rangeType === 'week') {
      // Current week (Sunday to Saturday)
      const day = now.getDay(); // 0 = Sunday, 6 = Saturday
      startDate = new Date(now);
      startDate.setDate(now.getDate() - day);
      startDate.setHours(0, 0, 0, 0);
      
      endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
    } else if (rangeType === 'last_week') {
      // Last week
      const day = now.getDay();
      startDate = new Date(now);
      startDate.setDate(now.getDate() - day - 7);
      startDate.setHours(0, 0, 0, 0);
      
      endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
    } else if (rangeType === 'month') {
      // Current month
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
    } else if (rangeType === 'last_month') {
      // Last month
      startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      endDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
    } else if (rangeType === 'quarter') {
      // Current quarter
      const quarter = Math.floor(now.getMonth() / 3);
      startDate = new Date(now.getFullYear(), quarter * 3, 1);
      endDate = new Date(now.getFullYear(), (quarter + 1) * 3, 0, 23, 59, 59, 999);
    } else if (rangeType === 'last_quarter') {
      // Last quarter
      const quarter = Math.floor(now.getMonth() / 3) - 1;
      const year = quarter < 0 ? now.getFullYear() - 1 : now.getFullYear();
      const adjustedQuarter = quarter < 0 ? 3 : quarter;
      
      startDate = new Date(year, adjustedQuarter * 3, 1);
      endDate = new Date(year, (adjustedQuarter + 1) * 3, 0, 23, 59, 59, 999);
    } else if (rangeType === 'year') {
      // Current year
      startDate = new Date(now.getFullYear(), 0, 1);
      endDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
    } else if (rangeType === 'last_year') {
      // Last year
      startDate = new Date(now.getFullYear() - 1, 0, 1);
      endDate = new Date(now.getFullYear() - 1, 11, 31, 23, 59, 59, 999);
    } else if (rangeType === 'all_time') {
      // All time
      startDate = new Date(0); // Beginning of time (1970-01-01)
      endDate = new Date(now.getFullYear() + 1, 11, 31, 23, 59, 59, 999); // Far future
    } else {
      // Default to last 30 days
      startDate = new Date(now);
      startDate.setDate(now.getDate() - 30);
      startDate.setHours(0, 0, 0, 0);
      
      endDate = new Date(now);
      endDate.setHours(23, 59, 59, 999);
    }
    
    return {
      startDate: startDate,
      endDate: endDate,
      rangeType: rangeType,
      description: getDateRangeDescription(rangeType, startDate, endDate)
    };
  } catch (e) {
    logError('getDateRange', e.toString());
    
    // Return a safe default (last 30 days)
    const now = new Date();
    const startDate = new Date(now);
    startDate.setDate(now.getDate() - 30);
    startDate.setHours(0, 0, 0, 0);
    
    return {
      startDate: startDate,
      endDate: now,
      rangeType: 'last_30_days',
      description: 'Last 30 days'
    };
  }
}

/**
 * Gets a human-readable description of a date range
 * @param {String} rangeType - Type of range
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @return {String} Human-readable description
 */
function getDateRangeDescription(rangeType, startDate, endDate) {
  try {
    const formatDate = (date) => {
      return Utilities.formatDate(date, Session.getScriptTimeZone(), 'MMM d, yyyy');
    };
    
    if (rangeType === 'custom') {
      return `${formatDate(startDate)} - ${formatDate(endDate)}`;
    } else if (rangeType === 'today') {
      return 'Today';
    } else if (rangeType === 'yesterday') {
      return 'Yesterday';
    } else if (rangeType === 'week') {
      return 'This Week';
    } else if (rangeType === 'last_week') {
      return 'Last Week';
    } else if (rangeType === 'month') {
      return 'This Month';
    } else if (rangeType === 'last_month') {
      return 'Last Month';
    } else if (rangeType === 'quarter') {
      return 'This Quarter';
    } else if (rangeType === 'last_quarter') {
      return 'Last Quarter';
    } else if (rangeType === 'year') {
      return 'This Year';
    } else if (rangeType === 'last_year') {
      return 'Last Year';
    } else if (rangeType === 'all_time') {
      return 'All Time';
    } else {
      return 'Last 30 Days';
    }
  } catch (e) {
    logError('getDateRangeDescription', e.toString());
    return 'Custom Date Range';
  }
}

/**
 * Gets the current user's info for QA
 * @return {Object} Current user info
 */
function getCurrentUserInfo() {
  try {
    const email = Session.getActiveUser().getEmail();
    let name = '';
    
    // Try to get full name if TeamService is available
    if (typeof getTeamService === 'function') {
      try {
        const teamService = getTeamService();
        const member = teamService.getTeamMemberByEmail(email);
        
        if (member) {
          name = `${member.firstName || ''} ${member.lastName || ''}`.trim();
        }
      } catch (e) {
        // Ignore error, continue with empty name
      }
    }
    
    // Default to email username if name not available
    if (!name) {
      name = email.split('@')[0];
    }
    
    return {
      email: email,
      name: name,
      timestamp: new Date().toISOString()
    };
  } catch (e) {
    logError('getCurrentUserInfo', e.toString());
    return {
      email: '',
      name: '',
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Logs an error from QA functions
 * @param {String} source - Source function name
 * @param {String} error - Error message
 * @param {Object} context - Additional context data
 */
function logError(source, error, context = {}) {
  try {
    Logger.log(`QA Error [${source}]: ${error}`);
    
    // Log to error tracking sheet if it exists
    if (typeof logSystemError === 'function') {
      logSystemError('QAService', source, error, JSON.stringify(context));
    }
  } catch (e) {
    // If even error logging fails, just use Logger as fallback
    Logger.log(`Failed to log error: ${e.toString()}`);
    Logger.log(`Original error [${source}]: ${error}`);
  }
}

/**
 * Automates scheduled QA tasks (to be triggered by time-driven triggers)
 */
function runScheduledQATasks() {
  try {
    const today = new Date();
    const settings = getQASystemSettings();
    
    // Check if auto-backup is enabled
    if (settings.autoBackupEnabled) {
      // Determine if backup should run today based on frequency
      let shouldRunBackup = false;
      
      if (settings.backupFrequency === 'daily') {
        shouldRunBackup = true;
      } else if (settings.backupFrequency === 'weekly' && today.getDay() === 0) {
        // Run on Sundays
        shouldRunBackup = true;
      } else if (settings.backupFrequency === 'monthly' && today.getDate() === 1) {
        // Run on the 1st of the month
        shouldRunBackup = true;
      } else if (settings.backupFrequency === 'quarterly' && 
                today.getDate() === 1 && 
                [0, 3, 6, 9].includes(today.getMonth())) {
        // Run on first day of each quarter
        shouldRunBackup = true;
      }
      
      if (shouldRunBackup) {
        getQAService().createQADataBackup();
      }
    }
    
    // Run data purge if retention period is set
    if (settings.retentionPeriod && settings.retentionPeriod > 0) {
      getQAService().purgeOldQAData(settings.retentionPeriod);
    }
    
    return {
      success: true,
      message: 'Scheduled QA tasks completed successfully',
      timestamp: today.toISOString()
    };
  } catch (e) {
    logError('runScheduledQATasks', e.toString());
    return {
      success: false,
      message: 'Error running scheduled QA tasks: ' + e.toString(),
      timestamp: new Date().toISOString()
    };
  }
}


/**
 * AsanaService.gs - Services for Asana integration
 */

var AsanaService = (function() {
  /**
   * Gets the API key for the current user
   * @return {String} - API Key
   */
  function getApiKey_() {
    var configService = getConfigService();
    var userInfo = configService.getUserInfoByEmail(Session.getActiveUser().getEmail());
    return userInfo.asanaApiKey;
  }
  
  /**
   * Makes an Asana API request
   * @param {String} endpoint - API endpoint
   * @param {String} method - HTTP method
   * @param {Object} payload - Request payload (optional)
   * @return {Object} - Response
   */
  function makeAsanaRequest_(endpoint, method, payload) {
    var apiKey = getApiKey_();
    
    if (!apiKey) {
      throw new Error('Asana API key not configured. Please add your API key in Settings.');
    }
    
    var url = 'https://app.asana.com/api/1.0/' + endpoint;
    var options = {
      method: method,
      headers: {
        'Authorization': 'Bearer ' + apiKey,
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      muteHttpExceptions: true
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    var response = UrlFetchApp.fetch(url, options);
    var responseCode = response.getResponseCode();
    var responseText = response.getContentText();
    
    if (responseCode >= 200 && responseCode < 300) {
      return JSON.parse(responseText);
    } else {
      Logger.log('Asana API Error: ' + responseText);
      throw new Error('Asana API Error: ' + responseCode + ' - ' + responseText);
    }
  }
  
  return {
    /**
     * Gets workspaces for the authenticated user
     * @return {Array} - List of workspaces
     */
    getWorkspaces: function() {
      var response = makeAsanaRequest_('workspaces', 'GET');
      return response.data;
    },
    
    /**
     * Gets projects for a workspace
     * @param {String} workspaceId - Asana workspace ID
     * @return {Array} - List of projects
     */
    getProjects: function(workspaceId) {
      var response = makeAsanaRequest_('workspaces/' + workspaceId + '/projects', 'GET');
      return response.data;
    },
    
    /**
     * Gets tasks for a project
     * @param {String} projectId - Asana project ID
     * @return {Array} - List of tasks
     */
    getTasks: function(projectId) {
      var response = makeAsanaRequest_('projects/' + projectId + '/tasks', 'GET');
      return response.data;
    },
    
    /**
     * Creates a task in Asana
     * @param {Object} taskData - Task data
     * @return {Object} - Created task data
     */
    createTask: function(taskData) {
      var configService = getConfigService();
      var userInfo = configService.getUserInfoByEmail(Session.getActiveUser().getEmail());
      var workspaceId = userInfo.asanaWorkspace;
      
      if (!workspaceId) {
        throw new Error('Asana workspace not configured. Please set your workspace in Settings.');
      }
      
      var payload = {
        data: {
          name: taskData.name,
          notes: taskData.notes || '',
          workspace: workspaceId
        }
      };
      
      if (taskData.assignee) {
        payload.data.assignee = taskData.assignee;
      }
      
      if (taskData.due_on) {
        payload.data.due_on = Utilities.formatDate(new Date(taskData.due_on), 
                                                 'GMT', 'yyyy-MM-dd');
      }
      
      if (taskData.projects) {
        payload.data.projects = taskData.projects;
      }
      
      var response = makeAsanaRequest_('tasks', 'POST', payload);
      return response.data;
    },
    
    /**
     * Creates a task in Asana from a one-on-one action item
     * @param {Object} actionItem - Action item data
     * @param {Object} sessionData - Session data
     * @return {Object} - Created task data
     */
    createTaskFromActionItem: function(actionItem, sessionData) {
      var notes = 'Action item from one-on-one session\n' +
                'Team Member: ' + sessionData.teamMember + '\n' +
                'Created: ' + Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd') + '\n\n' +
                (actionItem.notes || '');
      
      var taskData = {
        name: actionItem.description,
        notes: notes,
        due_on: actionItem.dueDate
      };
      
      return this.createTask(taskData);
    }
  };
})();

/**
 * Get the AsanaService instance
 * @return {Object} - AsanaService instance
 */
function getAsanaService() {
  return AsanaService;
}
